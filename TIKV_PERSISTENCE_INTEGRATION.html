<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>TiKV Persistence Layer Integration | Orbit-RS Documentation</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="TiKV Persistence Layer Integration" />
<meta name="author" content="TuringWorks" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The Next-Generation Distributed Database System - Production-Ready Multi-Model Platform" />
<meta property="og:description" content="The Next-Generation Distributed Database System - Production-Ready Multi-Model Platform" />
<link rel="canonical" href="https://turingworks.github.io/orbit-rs/TIKV_PERSISTENCE_INTEGRATION.html" />
<meta property="og:url" content="https://turingworks.github.io/orbit-rs/TIKV_PERSISTENCE_INTEGRATION.html" />
<meta property="og:site_name" content="Orbit-RS Documentation" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="TiKV Persistence Layer Integration" />
<meta name="twitter:site" content="@TuringWorksAI" />
<meta name="twitter:creator" content="@TuringWorks" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"TuringWorks"},"description":"The Next-Generation Distributed Database System - Production-Ready Multi-Model Platform","headline":"TiKV Persistence Layer Integration","url":"https://turingworks.github.io/orbit-rs/TIKV_PERSISTENCE_INTEGRATION.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/orbit-rs/assets/main.css">
  <link rel="stylesheet" href="/orbit-rs/assets/css/custom.css"><link type="application/atom+xml" rel="alternate" href="https://turingworks.github.io/orbit-rs/feed.xml" title="Orbit-RS Documentation" /></head><body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/orbit-rs/">Orbit-RS Documentation</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/orbit-rs/">Orbit-RS Documentation</a><a class="page-link" href="/orbit-rs/project_overview.html">Orbit-RS: Comprehensive Project Overview</a><a class="page-link" href="/orbit-rs/quick_start.html">Quick Start Guide - Multi-Protocol Database Server</a><a class="page-link" href="/orbit-rs/roadmap/">Development Roadmap</a><a class="page-link" href="/orbit-rs/features/">Orbit-RS Feature Index</a><a class="page-link" href="/orbit-rs/compute-acceleration/">Hardware Acceleration Guide</a><a class="page-link" href="/orbit-rs/contributing.html">Contributing Guide</a><a class="page-link" href="/orbit-rs/overview.html">Architecture Overview</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h1 id="tikv-storage-provider-integration-for-orbit-rs">TiKV Storage Provider Integration for Orbit-RS</h1>

<p><strong>Date</strong>: October 13, 2025<br />
<strong>Author</strong>: AI Assistant<br />
<strong>Status</strong>: Proposal<br />
<strong>Version</strong>: 2.0</p>

<h2 id="executive-summary">Executive Summary</h2>

<p>This document outlines the integration of TiKV as a distributed storage provider for Orbit-RS, alongside RocksDB and other storage engines. TiKV provides an excellent storage option for Orbit-RS actors requiring distributed storage capabilities, leveraging its Rust implementation, ACID compliance, and proven Raft consensus algorithm.</p>

<p><strong>Key Benefits:</strong></p>
<ul>
  <li><strong>Storage Provider Option</strong>: Distributed storage choice alongside RocksDB</li>
  <li><strong>Native Rust Integration</strong>: Optimal performance and memory safety</li>
  <li><strong>Distributed ACID</strong>: Strong consistency for multi-actor scenarios</li>
  <li><strong>Raft Consensus</strong>: Battle-tested distributed consensus</li>
  <li><strong>Production Ready</strong>: Mature, operationally proven storage engine</li>
</ul>

<h2 id="table-of-contents">Table of Contents</h2>

<ol>
  <li><a href="#architecture-overview">Architecture Overview</a></li>
  <li><a href="#technical-integration-design">Technical Integration Design</a></li>
  <li><a href="#actor-to-region-mapping-strategy">Actor-to-Region Mapping Strategy</a></li>
  <li><a href="#multi-model-data-storage-patterns">Multi-Model Data Storage Patterns</a></li>
  <li><a href="#transaction-management">Transaction Management</a></li>
  <li><a href="#performance-optimization">Performance Optimization</a></li>
  <li><a href="#implementation-roadmap">Implementation Roadmap</a></li>
  <li><a href="#operational-considerations">Operational Considerations</a></li>
  <li><a href="#migration-strategy">Migration Strategy</a></li>
  <li><a href="#testing-and-validation">Testing and Validation</a></li>
</ol>

<h2 id="architecture-overview">Architecture Overview</h2>

<h3 id="current-orbit-rs-architecture">Current Orbit-RS Architecture</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Protocol      │    │   Query         │    │   Multi-Model   │
│   Adapters      │    │   Engines       │    │   Processors    │
│                 │    │                 │    │                 │
│ • PostgreSQL    │    │ • SQL           │    │ • Relational    │
│ • Redis         │────▶ • GraphQL       │────▶ • Vector        │
│ • gRPC          │    │ • Cypher        │    │ • Graph         │
│ • REST          │    │ • OrbitQL       │    │ • Time Series   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                                        │
                              ┌─────────────────────────▼─────────────────────────┐
                              │                Actor System                        │
                              │                                                    │
                              │  ┌───────────┐  ┌───────────┐  ┌───────────┐     │
                              │  │  Actor A  │  │  Actor B  │  │  Actor C  │     │
                              │  │           │  │           │  │           │     │
                              │  └───────────┘  └───────────┘  └───────────┘     │
                              └─────────────────────────┬─────────────────────────┘
                                                        │
                              ┌─────────────────────────▼─────────────────────────┐
                              │             Storage Backend (Current)              │
                              │                                                    │
                              │              • Local Storage                      │
                              │              • Limited Distribution               │
                              └────────────────────────────────────────────────────┘
</code></pre></div></div>

<h3 id="proposed-storage-provider-architecture">Proposed Storage Provider Architecture</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Protocol      │    │   Query         │    │   Multi-Model   │
│   Adapters      │    │   Engines       │    │   Processors    │
│                 │    │                 │    │                 │
│ • PostgreSQL    │    │ • SQL           │    │ • Relational    │
│ • Redis         │────▶ • GraphQL       │────▶ • Vector        │
│ • gRPC          │    │ • Cypher        │    │ • Graph         │
│ • REST          │    │ • OrbitQL       │    │ • Time Series   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                                        │
                              ┌─────────────────────────▼─────────────────────────┐
                              │                Actor System                        │
                              │                                                    │
                              │  ┌───────────┐  ┌───────────┐  ┌───────────┐     │
                              │  │  Actor A  │  │  Actor B  │  │  Actor C  │     │
                              │  │ RocksDB   │  │   TiKV    │  │ RocksDB   │     │
                              │  └───────────┘  └───────────┘  └───────────┘     │
                              └─────────────────────────┬─────────────────────────┘
                                                        │
                              ┌─────────────────────────▼─────────────────────────┐
                              │              Storage Provider Layer               │
                              │                                                    │
                              │  • Unified Storage Interface  • Provider Selection│
                              │  • Multi-Model Abstraction   • Configuration Mgmt│
                              │  • Transaction Coordination  • Performance Tuning│
                              └─────────────────────────┬─────────────────────────┘
                                                        │
                    ┌───────────────────────────────────┼───────────────────────────────────┐
                    │                                   │                                   │
          ┌─────────▼─────────┐                ┌────────▼────────┐                ┌───────▼───────┐
          │   RocksDB         │                │     TiKV        │                │    Future     │
          │   Provider        │                │    Provider     │                │   Providers   │
          │                   │                │                 │                │               │
          │ • Local Storage   │                │ • Distributed   │                │ • FoundationDB│
          │ • High Performance│                │ • ACID Txns     │                │ • Apache      │
          │ • Embedded        │                │ • Raft Consensus│                │   Cassandra   │
          └───────────────────┘                │ • Multi-Region  │                │ • Others...   │
                                               └─────────────────┘                └───────────────┘
</code></pre></div></div>

<h2 id="technical-integration-design">Technical Integration Design</h2>

<h3 id="core-integration-components">Core Integration Components</h3>

<h4 id="1-storage-provider-interface">1. Storage Provider Interface</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">orbit_core</span><span class="p">::</span><span class="nn">storage</span><span class="p">::{</span><span class="n">StorageProvider</span><span class="p">,</span> <span class="n">StorageError</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span> <span class="n">Value</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">tikv_client</span><span class="p">::{</span><span class="n">Client</span> <span class="k">as</span> <span class="n">TiKVClient</span><span class="p">,</span> <span class="n">Transaction</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">rocksdb</span><span class="p">::{</span><span class="n">DB</span><span class="p">,</span> <span class="n">Options</span><span class="p">};</span>

<span class="c1">// Unified storage provider trait</span>
<span class="nd">#[async_trait]</span>
<span class="k">pub</span> <span class="k">trait</span> <span class="n">StorageProvider</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="p">{</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">StorageError</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">put</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Key</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Value</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">StorageError</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">delete</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">StorageError</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">batch_operations</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">StorageOperation</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">StorageError</span><span class="o">&gt;</span><span class="p">;</span>
    
    <span class="c1">// Provider-specific capabilities</span>
    <span class="k">fn</span> <span class="nf">supports_distributed_transactions</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">supports_multi_region</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">provider_type</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">StorageProviderType</span><span class="p">;</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">StorageProviderType</span> <span class="p">{</span>
    <span class="n">RocksDB</span><span class="p">,</span>
    <span class="n">TiKV</span><span class="p">,</span>
    <span class="n">FoundationDB</span><span class="p">,</span>
    <span class="c1">// Future providers...</span>
<span class="p">}</span>

<span class="c1">// TiKV Storage Provider Implementation</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TiKVProvider</span> <span class="p">{</span>
    <span class="n">client</span><span class="p">:</span> <span class="n">TiKVClient</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">TiKVConfig</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TiKVProvider</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">endpoints</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="n">StorageError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">client</span> <span class="o">=</span> <span class="nn">TiKVClient</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">config</span> <span class="o">=</span> <span class="nn">TiKVConfig</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">TiKVProvider</span> <span class="p">{</span> <span class="n">client</span><span class="p">,</span> <span class="n">config</span> <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[async_trait]</span>
<span class="k">impl</span> <span class="n">StorageProvider</span> <span class="k">for</span> <span class="n">TiKVProvider</span> <span class="p">{</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">StorageError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">txn</span> <span class="o">=</span> <span class="k">self</span><span class="py">.client</span><span class="nf">.begin_optimistic</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">txn</span><span class="nf">.get</span><span class="p">(</span><span class="n">key</span><span class="nf">.clone</span><span class="p">())</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">put</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Key</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Value</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">StorageError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">txn</span> <span class="o">=</span> <span class="k">self</span><span class="py">.client</span><span class="nf">.begin_optimistic</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="n">txn</span><span class="nf">.put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="n">txn</span><span class="nf">.commit</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">delete</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">StorageError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">txn</span> <span class="o">=</span> <span class="k">self</span><span class="py">.client</span><span class="nf">.begin_optimistic</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="n">txn</span><span class="nf">.delete</span><span class="p">(</span><span class="n">key</span><span class="nf">.clone</span><span class="p">())</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="n">txn</span><span class="nf">.commit</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">batch_operations</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">StorageOperation</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">StorageError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">txn</span> <span class="o">=</span> <span class="k">self</span><span class="py">.client</span><span class="nf">.begin_optimistic</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="k">for</span> <span class="n">op</span> <span class="k">in</span> <span class="n">ops</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">op</span> <span class="p">{</span>
                <span class="nn">StorageOperation</span><span class="p">::</span><span class="nf">Put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">txn</span><span class="nf">.put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
                <span class="nn">StorageOperation</span><span class="p">::</span><span class="nf">Delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">txn</span><span class="nf">.delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
                <span class="nn">StorageOperation</span><span class="p">::</span><span class="nf">Get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="cm">/* Handle get in batch */</span> <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="n">txn</span><span class="nf">.commit</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">supports_distributed_transactions</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span> <span class="k">true</span> <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">supports_multi_region</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span> <span class="k">true</span> <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">provider_type</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">StorageProviderType</span> <span class="p">{</span> <span class="nn">StorageProviderType</span><span class="p">::</span><span class="n">TiKV</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// RocksDB Storage Provider Implementation</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">RocksDBProvider</span> <span class="p">{</span>
    <span class="n">db</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">DB</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">RocksDBConfig</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[async_trait]</span>
<span class="k">impl</span> <span class="n">StorageProvider</span> <span class="k">for</span> <span class="n">RocksDBProvider</span> <span class="p">{</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">StorageError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="k">self</span><span class="py">.db</span><span class="nf">.get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">?</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">v</span><span class="nf">.into</span><span class="p">()))</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">put</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Key</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Value</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">StorageError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.db</span><span class="nf">.put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">delete</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">StorageError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.db</span><span class="nf">.delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">batch_operations</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">StorageOperation</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">StorageError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">batch</span> <span class="o">=</span> <span class="nn">rocksdb</span><span class="p">::</span><span class="nn">WriteBatch</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">op</span> <span class="k">in</span> <span class="n">ops</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">op</span> <span class="p">{</span>
                <span class="nn">StorageOperation</span><span class="p">::</span><span class="nf">Put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">batch</span><span class="nf">.put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">),</span>
                <span class="nn">StorageOperation</span><span class="p">::</span><span class="nf">Delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">batch</span><span class="nf">.delete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">),</span>
                <span class="nn">StorageOperation</span><span class="p">::</span><span class="nf">Get</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="cm">/* Handle get separately */</span> <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.db</span><span class="nf">.write</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">supports_distributed_transactions</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span> <span class="k">false</span> <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">supports_multi_region</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span> <span class="k">false</span> <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">provider_type</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">StorageProviderType</span> <span class="p">{</span> <span class="nn">StorageProviderType</span><span class="p">::</span><span class="n">RocksDB</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="2-storage-provider-manager">2. Storage Provider Manager</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Storage provider selection and management</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">StorageManager</span> <span class="p">{</span>
    <span class="n">providers</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">StorageProviderType</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">StorageProvider</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">actor_assignments</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">ActorId</span><span class="p">,</span> <span class="n">StorageProviderType</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">selection_strategy</span><span class="p">:</span> <span class="n">ProviderSelectionStrategy</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">StorageManagerConfig</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">ProviderSelectionStrategy</span> <span class="p">{</span>
    <span class="nf">Default</span><span class="p">(</span><span class="n">StorageProviderType</span><span class="p">),</span>
    <span class="nf">ByActorType</span><span class="p">(</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">ActorType</span><span class="p">,</span> <span class="n">StorageProviderType</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nf">ByDataPattern</span><span class="p">(</span><span class="n">DataPatternMatcher</span><span class="p">),</span>
    <span class="nf">Custom</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ActorContext</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">StorageProviderType</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DataPatternMatcher</span> <span class="p">{</span>
    <span class="n">distributed_threshold</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>  <span class="c1">// Use TiKV for actors with &gt;N cross-references</span>
    <span class="n">performance_requirements</span><span class="p">:</span> <span class="n">PerformanceProfile</span><span class="p">,</span>
    <span class="n">consistency_requirements</span><span class="p">:</span> <span class="n">ConsistencyLevel</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">StorageManager</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">config</span><span class="p">:</span> <span class="n">StorageManagerConfig</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="n">StorageError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">providers</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">StorageProviderType</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">StorageProvider</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        
        <span class="c1">// Initialize configured providers</span>
        <span class="k">if</span> <span class="n">config</span><span class="py">.enable_rocksdb</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">rocksdb</span> <span class="o">=</span> <span class="nn">RocksDBProvider</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="py">.rocksdb_config</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="n">providers</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">StorageProviderType</span><span class="p">::</span><span class="n">RocksDB</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">rocksdb</span><span class="p">));</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="n">config</span><span class="py">.enable_tikv</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">tikv</span> <span class="o">=</span> <span class="nn">TiKVProvider</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">config</span><span class="py">.tikv_endpoints</span><span class="nf">.clone</span><span class="p">())</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="n">providers</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">StorageProviderType</span><span class="p">::</span><span class="n">TiKV</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">tikv</span><span class="p">));</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">StorageManager</span> <span class="p">{</span>
            <span class="n">providers</span><span class="p">,</span>
            <span class="n">actor_assignments</span><span class="p">:</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="n">selection_strategy</span><span class="p">:</span> <span class="n">config</span><span class="py">.selection_strategy</span><span class="p">,</span>
            <span class="n">config</span><span class="p">,</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">get_provider_for_actor</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">actor_id</span><span class="p">:</span> <span class="n">ActorId</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ActorContext</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;&amp;</span><span class="k">dyn</span> <span class="n">StorageProvider</span><span class="p">,</span> <span class="n">StorageError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Check if actor already has assigned provider</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">provider_type</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.actor_assignments</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">actor_id</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">self</span><span class="py">.providers</span><span class="nf">.get</span><span class="p">(</span><span class="n">provider_type</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_ref</span><span class="p">());</span>
        <span class="p">}</span>
        
        <span class="c1">// Select provider based on strategy</span>
        <span class="k">let</span> <span class="n">provider_type</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.select_provider</span><span class="p">(</span><span class="n">actor_id</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.actor_assignments</span><span class="nf">.insert</span><span class="p">(</span><span class="n">actor_id</span><span class="p">,</span> <span class="n">provider_type</span><span class="nf">.clone</span><span class="p">());</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="k">self</span><span class="py">.providers</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">provider_type</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_ref</span><span class="p">())</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">select_provider</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">actor_id</span><span class="p">:</span> <span class="n">ActorId</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ActorContext</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">StorageProviderType</span><span class="p">,</span> <span class="n">StorageError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.selection_strategy</span> <span class="p">{</span>
            <span class="nn">ProviderSelectionStrategy</span><span class="p">::</span><span class="nf">Default</span><span class="p">(</span><span class="n">provider_type</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">provider_type</span><span class="nf">.clone</span><span class="p">()),</span>
            
            <span class="nn">ProviderSelectionStrategy</span><span class="p">::</span><span class="nf">ByActorType</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">mapping</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="py">.actor_type</span><span class="p">)</span>
                    <span class="nf">.cloned</span><span class="p">()</span>
                    <span class="nf">.unwrap_or</span><span class="p">(</span><span class="nn">StorageProviderType</span><span class="p">::</span><span class="n">RocksDB</span><span class="p">))</span>
            <span class="p">},</span>
            
            <span class="nn">ProviderSelectionStrategy</span><span class="p">::</span><span class="nf">ByDataPattern</span><span class="p">(</span><span class="n">matcher</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// Analyze data patterns to choose provider</span>
                <span class="k">let</span> <span class="n">cross_references</span> <span class="o">=</span> <span class="n">context</span><span class="nf">.get_cross_actor_references</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">performance_needs</span> <span class="o">=</span> <span class="n">context</span><span class="nf">.get_performance_requirements</span><span class="p">();</span>
                <span class="k">let</span> <span class="n">consistency_needs</span> <span class="o">=</span> <span class="n">context</span><span class="nf">.get_consistency_requirements</span><span class="p">();</span>
                
                <span class="k">if</span> <span class="n">cross_references</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">matcher</span><span class="py">.distributed_threshold</span> <span class="p">{</span>
                    <span class="nf">Ok</span><span class="p">(</span><span class="nn">StorageProviderType</span><span class="p">::</span><span class="n">TiKV</span><span class="p">)</span>  <span class="c1">// Use distributed storage</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">performance_needs</span><span class="py">.latency_sensitive</span> <span class="p">{</span>
                    <span class="nf">Ok</span><span class="p">(</span><span class="nn">StorageProviderType</span><span class="p">::</span><span class="n">RocksDB</span><span class="p">)</span>  <span class="c1">// Use local high-performance storage</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nf">Ok</span><span class="p">(</span><span class="nn">StorageProviderType</span><span class="p">::</span><span class="n">RocksDB</span><span class="p">)</span>  <span class="c1">// Default to RocksDB</span>
                <span class="p">}</span>
            <span class="p">},</span>
            
            <span class="nn">ProviderSelectionStrategy</span><span class="p">::</span><span class="nf">Custom</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="nf">selector</span><span class="p">(</span><span class="n">context</span><span class="p">))</span>
            <span class="p">},</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">migrate_actor_storage</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> 
        <span class="n">actor_id</span><span class="p">:</span> <span class="n">ActorId</span><span class="p">,</span> 
        <span class="n">from_provider</span><span class="p">:</span> <span class="n">StorageProviderType</span><span class="p">,</span> 
        <span class="n">to_provider</span><span class="p">:</span> <span class="n">StorageProviderType</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">StorageError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">from</span> <span class="o">=</span> <span class="k">self</span><span class="py">.providers</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">from_provider</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">to</span> <span class="o">=</span> <span class="k">self</span><span class="py">.providers</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to_provider</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        
        <span class="c1">// 1. Start migration transaction</span>
        <span class="k">let</span> <span class="n">migration_id</span> <span class="o">=</span> <span class="nn">MigrationId</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        
        <span class="c1">// 2. Copy data from source to target</span>
        <span class="k">let</span> <span class="n">actor_keys</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.get_actor_keys</span><span class="p">(</span><span class="n">actor_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="k">in</span> <span class="n">actor_keys</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="n">from</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span> <span class="p">{</span>
                <span class="n">to</span><span class="nf">.put</span><span class="p">(</span><span class="n">key</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">value</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// 3. Update assignment</span>
        <span class="k">self</span><span class="py">.actor_assignments</span><span class="nf">.insert</span><span class="p">(</span><span class="n">actor_id</span><span class="p">,</span> <span class="n">to_provider</span><span class="p">);</span>
        
        <span class="c1">// 4. Clean up old data (optional, can be done async)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.get_actor_keys</span><span class="p">(</span><span class="n">actor_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span> <span class="p">{</span>
            <span class="n">from</span><span class="nf">.delete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="3-configuration-management">3. Configuration Management</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TiKVConfig</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">endpoints</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">timeout</span><span class="p">:</span> <span class="n">Duration</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">max_batch_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">region_cache_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">enable_async_commit</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">enable_one_pc</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">gc_interval</span><span class="p">:</span> <span class="n">Duration</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">region_split_threshold</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">coprocessor_pool_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">TiKVConfig</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">TiKVConfig</span> <span class="p">{</span>
            <span class="n">endpoints</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="s">"127.0.0.1:2379"</span><span class="nf">.to_string</span><span class="p">()],</span>
            <span class="n">timeout</span><span class="p">:</span> <span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
            <span class="n">max_batch_size</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
            <span class="n">region_cache_size</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
            <span class="n">enable_async_commit</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
            <span class="n">enable_one_pc</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
            <span class="n">gc_interval</span><span class="p">:</span> <span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">600</span><span class="p">),</span>
            <span class="n">region_split_threshold</span><span class="p">:</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="c1">// 64MB</span>
            <span class="n">coprocessor_pool_size</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="actor-to-region-mapping-strategy">Actor-to-Region Mapping Strategy</h2>

<h3 id="region-assignment-algorithm">Region Assignment Algorithm</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">ActorRegionMapper</span> <span class="p">{</span>
    <span class="n">region_cache</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">RwLock</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">ActorId</span><span class="p">,</span> <span class="n">RegionId</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">region_manager</span><span class="p">:</span> <span class="n">RegionManager</span><span class="p">,</span>
    <span class="n">hash_ring</span><span class="p">:</span> <span class="n">ConsistentHashRing</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">ActorRegionMapper</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">get_region</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">actor_id</span><span class="p">:</span> <span class="n">ActorId</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">RegionId</span><span class="p">,</span> <span class="n">MappingError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Check cache first</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">region_id</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.region_cache</span><span class="nf">.read</span><span class="p">()</span><span class="k">.await</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">actor_id</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="o">*</span><span class="n">region_id</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="c1">// Calculate region based on actor_id hash</span>
        <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.calculate_actor_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">actor_id</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">region_id</span> <span class="o">=</span> <span class="k">self</span><span class="py">.hash_ring</span><span class="nf">.get_region</span><span class="p">(</span><span class="n">hash</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Cache the mapping</span>
        <span class="k">self</span><span class="py">.region_cache</span><span class="nf">.write</span><span class="p">()</span><span class="k">.await</span><span class="nf">.insert</span><span class="p">(</span><span class="n">actor_id</span><span class="p">,</span> <span class="n">region_id</span><span class="p">);</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">region_id</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">migrate_actor</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">actor_id</span><span class="p">:</span> <span class="n">ActorId</span><span class="p">,</span> <span class="n">target_region</span><span class="p">:</span> <span class="n">RegionId</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">MappingError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// 1. Begin distributed transaction</span>
        <span class="k">let</span> <span class="n">txn</span> <span class="o">=</span> <span class="k">self</span><span class="py">.region_manager</span><span class="nf">.begin_migration_txn</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// 2. Copy data from source to target region</span>
        <span class="k">let</span> <span class="n">source_region</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.get_region</span><span class="p">(</span><span class="n">actor_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">actor_data</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.export_actor_data</span><span class="p">(</span><span class="n">source_region</span><span class="p">,</span> <span class="n">actor_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="nf">.import_actor_data</span><span class="p">(</span><span class="n">target_region</span><span class="p">,</span> <span class="n">actor_id</span><span class="p">,</span> <span class="n">actor_data</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// 3. Update mapping</span>
        <span class="k">self</span><span class="py">.region_cache</span><span class="nf">.write</span><span class="p">()</span><span class="k">.await</span><span class="nf">.insert</span><span class="p">(</span><span class="n">actor_id</span><span class="p">,</span> <span class="n">target_region</span><span class="p">);</span>
        
        <span class="c1">// 4. Clean up source data</span>
        <span class="k">self</span><span class="nf">.cleanup_actor_data</span><span class="p">(</span><span class="n">source_region</span><span class="p">,</span> <span class="n">actor_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// 5. Commit transaction</span>
        <span class="n">txn</span><span class="nf">.commit</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">calculate_actor_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">actor_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ActorId</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">hash</span><span class="p">::{</span><span class="n">Hash</span><span class="p">,</span> <span class="n">Hasher</span><span class="p">};</span>
        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="nn">hash_map</span><span class="p">::</span><span class="n">DefaultHasher</span><span class="p">;</span>
        
        <span class="k">let</span> <span class="k">mut</span> <span class="n">hasher</span> <span class="o">=</span> <span class="nn">DefaultHasher</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">actor_id</span><span class="nf">.hash</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">hasher</span><span class="p">);</span>
        <span class="n">hasher</span><span class="nf">.finish</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="data-locality-optimization">Data Locality Optimization</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">DataLocalityOptimizer</span> <span class="p">{</span>
    <span class="n">region_manager</span><span class="p">:</span> <span class="n">RegionManager</span><span class="p">,</span>
    <span class="n">actor_mapper</span><span class="p">:</span> <span class="n">ActorRegionMapper</span><span class="p">,</span>
    <span class="n">metrics_collector</span><span class="p">:</span> <span class="n">MetricsCollector</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DataLocalityOptimizer</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">optimize_placement</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">OptimizationError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">actors</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.get_all_actors</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">regions</span> <span class="o">=</span> <span class="k">self</span><span class="py">.region_manager</span><span class="nf">.get_all_regions</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="k">for</span> <span class="n">actor</span> <span class="k">in</span> <span class="n">actors</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">current_region</span> <span class="o">=</span> <span class="k">self</span><span class="py">.actor_mapper</span><span class="nf">.get_region</span><span class="p">(</span><span class="n">actor</span><span class="py">.id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">optimal_region</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.calculate_optimal_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">actor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regions</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            
            <span class="k">if</span> <span class="n">current_region</span> <span class="o">!=</span> <span class="n">optimal_region</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">migration_cost</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.calculate_migration_cost</span><span class="p">(</span><span class="o">&amp;</span><span class="n">actor</span><span class="p">,</span> <span class="n">current_region</span><span class="p">,</span> <span class="n">optimal_region</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">locality_benefit</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.calculate_locality_benefit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">actor</span><span class="p">,</span> <span class="n">optimal_region</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                
                <span class="k">if</span> <span class="n">locality_benefit</span> <span class="o">&gt;</span> <span class="n">migration_cost</span> <span class="p">{</span>
                    <span class="k">self</span><span class="py">.actor_mapper</span><span class="nf">.migrate_actor</span><span class="p">(</span><span class="n">actor</span><span class="py">.id</span><span class="p">,</span> <span class="n">optimal_region</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">calculate_optimal_region</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">actor</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Actor</span><span class="p">,</span> <span class="n">regions</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Region</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">RegionId</span><span class="p">,</span> <span class="n">OptimizationError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">best_region</span> <span class="o">=</span> <span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="py">.id</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">best_score</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
        
        <span class="k">for</span> <span class="n">region</span> <span class="k">in</span> <span class="n">regions</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">score</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.calculate_placement_score</span><span class="p">(</span><span class="n">actor</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">best_score</span> <span class="p">{</span>
                <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span><span class="p">;</span>
                <span class="n">best_region</span> <span class="o">=</span> <span class="n">region</span><span class="py">.id</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">best_region</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">calculate_placement_score</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">actor</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Actor</span><span class="p">,</span> <span class="n">region</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Region</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">f64</span><span class="p">,</span> <span class="n">OptimizationError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
        
        <span class="c1">// Factor 1: Network latency to frequently accessed data</span>
        <span class="k">let</span> <span class="n">network_score</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.calculate_network_score</span><span class="p">(</span><span class="n">actor</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="n">network_score</span> <span class="o">*</span> <span class="mf">0.4</span><span class="p">;</span>
        
        <span class="c1">// Factor 2: Resource utilization balance</span>
        <span class="k">let</span> <span class="n">resource_score</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.calculate_resource_score</span><span class="p">(</span><span class="n">region</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="n">resource_score</span> <span class="o">*</span> <span class="mf">0.3</span><span class="p">;</span>
        
        <span class="c1">// Factor 3: Data affinity (related actors)</span>
        <span class="k">let</span> <span class="n">affinity_score</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.calculate_affinity_score</span><span class="p">(</span><span class="n">actor</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="n">affinity_score</span> <span class="o">*</span> <span class="mf">0.3</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="multi-model-data-storage-patterns">Multi-Model Data Storage Patterns</h2>

<h3 id="key-design-patterns">Key Design Patterns</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">MultiModelKeyBuilder</span> <span class="p">{</span>
    <span class="n">namespace_separator</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">model_prefixes</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">DataModel</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">MultiModelKeyBuilder</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">model_prefixes</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">model_prefixes</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">DataModel</span><span class="p">::</span><span class="n">Relational</span><span class="p">,</span> <span class="s">"rel"</span><span class="p">);</span>
        <span class="n">model_prefixes</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">DataModel</span><span class="p">::</span><span class="n">Document</span><span class="p">,</span> <span class="s">"doc"</span><span class="p">);</span>
        <span class="n">model_prefixes</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">DataModel</span><span class="p">::</span><span class="n">Graph</span><span class="p">,</span> <span class="s">"grp"</span><span class="p">);</span>
        <span class="n">model_prefixes</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">DataModel</span><span class="p">::</span><span class="n">Vector</span><span class="p">,</span> <span class="s">"vec"</span><span class="p">);</span>
        <span class="n">model_prefixes</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">DataModel</span><span class="p">::</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="s">"ts"</span><span class="p">);</span>
        
        <span class="n">MultiModelKeyBuilder</span> <span class="p">{</span>
            <span class="n">namespace_separator</span><span class="p">:</span> <span class="s">":"</span><span class="p">,</span>
            <span class="n">model_prefixes</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">build_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">DataModel</span><span class="p">,</span> <span class="n">entity</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Key</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">prefix</span> <span class="o">=</span> <span class="k">self</span><span class="py">.model_prefixes</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">model</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="o">&amp;</span><span class="s">"unk"</span><span class="p">);</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{}{}{}{}{}"</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="k">self</span><span class="py">.namespace_separator</span><span class="p">,</span> <span class="n">entity</span><span class="p">,</span> <span class="k">self</span><span class="py">.namespace_separator</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>
            <span class="nf">.into_bytes</span><span class="p">()</span>
            <span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="c1">// Relational data keys</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">table_row_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">table</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">row_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Key</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"rel:table:{}:row:{}"</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">row_id</span><span class="p">)</span><span class="nf">.into_bytes</span><span class="p">()</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">index_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">table</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Key</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"rel:index:{}:{}:{}"</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="nf">.into_bytes</span><span class="p">()</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="c1">// Vector data keys</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">vector_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">collection</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">vector_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Key</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"vec:collection:{}:id:{}"</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">vector_id</span><span class="p">)</span><span class="nf">.into_bytes</span><span class="p">()</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">vector_index_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">collection</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">index_type</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">bucket</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Key</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"vec:index:{}:{}:bucket:{}"</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">index_type</span><span class="p">,</span> <span class="n">bucket</span><span class="p">)</span><span class="nf">.into_bytes</span><span class="p">()</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="c1">// Graph data keys</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">node_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Key</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"grp:node:{}:{}"</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span><span class="nf">.into_bytes</span><span class="p">()</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">edge_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">from_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">relation</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">to_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Key</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"grp:edge:{}:{}:{}:{}"</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">from_id</span><span class="p">,</span> <span class="n">relation</span><span class="p">,</span> <span class="n">to_id</span><span class="p">)</span><span class="nf">.into_bytes</span><span class="p">()</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">adjacency_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">Direction</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Key</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">dir</span> <span class="o">=</span> <span class="k">match</span> <span class="n">direction</span> <span class="p">{</span>
            <span class="nn">Direction</span><span class="p">::</span><span class="n">Outbound</span> <span class="k">=&gt;</span> <span class="s">"out"</span><span class="p">,</span>
            <span class="nn">Direction</span><span class="p">::</span><span class="n">Inbound</span> <span class="k">=&gt;</span> <span class="s">"in"</span><span class="p">,</span>
            <span class="nn">Direction</span><span class="p">::</span><span class="n">Both</span> <span class="k">=&gt;</span> <span class="s">"both"</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"grp:adj:{}:{}:{}"</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span><span class="nf">.into_bytes</span><span class="p">()</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="c1">// Time series data keys</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">timeseries_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">series_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span> <span class="n">sequence</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Key</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"ts:series:{}:time:{}:seq:{}"</span><span class="p">,</span> <span class="n">series_id</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">sequence</span><span class="p">)</span><span class="nf">.into_bytes</span><span class="p">()</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">timeseries_index_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">series_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">granularity</span><span class="p">:</span> <span class="n">Granularity</span><span class="p">,</span> <span class="n">bucket</span><span class="p">:</span> <span class="nb">i64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Key</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"ts:index:{}:{}:bucket:{}"</span><span class="p">,</span> <span class="n">series_id</span><span class="p">,</span> <span class="n">granularity</span><span class="nf">.as_str</span><span class="p">(),</span> <span class="n">bucket</span><span class="p">)</span><span class="nf">.into_bytes</span><span class="p">()</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="storage-value-formats">Storage Value Formats</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">serde</span><span class="p">::{</span><span class="n">Serialize</span><span class="p">,</span> <span class="n">Deserialize</span><span class="p">};</span>

<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">StoredRecord</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">model_type</span><span class="p">:</span> <span class="n">DataModel</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">schema_version</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">RecordMetadata</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">created_at</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">updated_at</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">RecordMetadata</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">actor_id</span><span class="p">:</span> <span class="n">ActorId</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">transaction_id</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">TransactionId</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">version</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">checksum</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">compression</span><span class="p">:</span> <span class="n">CompressionType</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Relational data storage</span>
<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">RelationalRecord</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">table_name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">row_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">columns</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="n">ColumnValue</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">schema_hash</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Vector data storage</span>
<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">VectorRecord</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">collection</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">vector_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">dimensions</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">metadata</span><span class="p">:</span> <span class="nn">serde_json</span><span class="p">::</span><span class="n">Value</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">index_hints</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">IndexHint</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Graph data storage</span>
<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">GraphNodeRecord</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">graph</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">properties</span><span class="p">:</span> <span class="nn">serde_json</span><span class="p">::</span><span class="n">Value</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">adjacency_count</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Direction</span><span class="p">,</span> <span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">GraphEdgeRecord</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">graph</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">from_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">to_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">relation</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">properties</span><span class="p">:</span> <span class="nn">serde_json</span><span class="p">::</span><span class="n">Value</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">weight</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">f64</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Time series data storage</span>
<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TimeSeriesRecord</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">series_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">timestamp</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">sequence</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">value</span><span class="p">:</span> <span class="n">TimeSeriesValue</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">tags</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">TimeSeriesValue</span> <span class="p">{</span>
    <span class="nf">Int64</span><span class="p">(</span><span class="nb">i64</span><span class="p">),</span>
    <span class="nf">Float64</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
    <span class="nf">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
    <span class="nf">Boolean</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
    <span class="nf">JSON</span><span class="p">(</span><span class="nn">serde_json</span><span class="p">::</span><span class="n">Value</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="transaction-management">Transaction Management</h2>

<h3 id="cross-model-transaction-support">Cross-Model Transaction Support</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">OrbitTransaction</span> <span class="p">{</span>
    <span class="n">tikv_txn</span><span class="p">:</span> <span class="n">Transaction</span><span class="p">,</span>
    <span class="n">transaction_id</span><span class="p">:</span> <span class="n">TransactionId</span><span class="p">,</span>
    <span class="n">affected_models</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">DataModel</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">affected_actors</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">ActorId</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">isolation_level</span><span class="p">:</span> <span class="n">IsolationLevel</span><span class="p">,</span>
    <span class="n">timeout</span><span class="p">:</span> <span class="n">Duration</span><span class="p">,</span>
    <span class="n">start_time</span><span class="p">:</span> <span class="n">Instant</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">OrbitTransaction</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">begin</span><span class="p">(</span><span class="n">client</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TiKVClient</span><span class="p">,</span> <span class="n">isolation_level</span><span class="p">:</span> <span class="n">IsolationLevel</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="n">TransactionError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">tikv_txn</span> <span class="o">=</span> <span class="k">match</span> <span class="n">isolation_level</span> <span class="p">{</span>
            <span class="nn">IsolationLevel</span><span class="p">::</span><span class="n">ReadCommitted</span> <span class="k">=&gt;</span> <span class="n">client</span><span class="nf">.begin_optimistic</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
            <span class="nn">IsolationLevel</span><span class="p">::</span><span class="n">RepeatableRead</span> <span class="k">=&gt;</span> <span class="n">client</span><span class="nf">.begin_pessimistic</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
            <span class="nn">IsolationLevel</span><span class="p">::</span><span class="n">Serializable</span> <span class="k">=&gt;</span> <span class="n">client</span><span class="nf">.begin_pessimistic</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
        <span class="p">};</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">OrbitTransaction</span> <span class="p">{</span>
            <span class="n">tikv_txn</span><span class="p">,</span>
            <span class="n">transaction_id</span><span class="p">:</span> <span class="nn">TransactionId</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="n">affected_models</span><span class="p">:</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="n">affected_actors</span><span class="p">:</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="n">isolation_level</span><span class="p">,</span>
            <span class="n">timeout</span><span class="p">:</span> <span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
            <span class="n">start_time</span><span class="p">:</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">(),</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">put_relational</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">table</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">row_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">RelationalRecord</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TransactionError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.key_builder</span><span class="p">()</span><span class="nf">.table_row_key</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">row_id</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">stored_record</span> <span class="o">=</span> <span class="n">StoredRecord</span> <span class="p">{</span>
            <span class="n">model_type</span><span class="p">:</span> <span class="nn">DataModel</span><span class="p">::</span><span class="n">Relational</span><span class="p">,</span>
            <span class="n">schema_version</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="nn">bincode</span><span class="p">::</span><span class="nf">serialize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">:</span> <span class="n">RecordMetadata</span> <span class="p">{</span>
                <span class="n">actor_id</span><span class="p">:</span> <span class="nn">ActorId</span><span class="p">::</span><span class="nf">from_table_row</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">row_id</span><span class="p">),</span>
                <span class="n">transaction_id</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="py">.transaction_id</span><span class="p">),</span>
                <span class="n">version</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">checksum</span><span class="p">:</span> <span class="nf">calculate_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">),</span>
                <span class="n">compression</span><span class="p">:</span> <span class="nn">CompressionType</span><span class="p">::</span><span class="nb">None</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">created_at</span><span class="p">:</span> <span class="nn">chrono</span><span class="p">::</span><span class="nn">Utc</span><span class="p">::</span><span class="nf">now</span><span class="p">()</span><span class="nf">.timestamp</span><span class="p">(),</span>
            <span class="n">updated_at</span><span class="p">:</span> <span class="nn">chrono</span><span class="p">::</span><span class="nn">Utc</span><span class="p">::</span><span class="nf">now</span><span class="p">()</span><span class="nf">.timestamp</span><span class="p">(),</span>
        <span class="p">};</span>
        
        <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="nn">bincode</span><span class="p">::</span><span class="nf">serialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stored_record</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.tikv_txn</span><span class="nf">.put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.affected_models</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">DataModel</span><span class="p">::</span><span class="n">Relational</span><span class="p">);</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">put_vector</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">collection</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">vector_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">VectorRecord</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TransactionError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.key_builder</span><span class="p">()</span><span class="nf">.vector_key</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">vector_id</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">stored_record</span> <span class="o">=</span> <span class="n">StoredRecord</span> <span class="p">{</span>
            <span class="n">model_type</span><span class="p">:</span> <span class="nn">DataModel</span><span class="p">::</span><span class="n">Vector</span><span class="p">,</span>
            <span class="n">schema_version</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="nn">bincode</span><span class="p">::</span><span class="nf">serialize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">:</span> <span class="n">RecordMetadata</span> <span class="p">{</span>
                <span class="n">actor_id</span><span class="p">:</span> <span class="nn">ActorId</span><span class="p">::</span><span class="nf">from_vector</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">vector_id</span><span class="p">),</span>
                <span class="n">transaction_id</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="py">.transaction_id</span><span class="p">),</span>
                <span class="n">version</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">checksum</span><span class="p">:</span> <span class="nf">calculate_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">),</span>
                <span class="n">compression</span><span class="p">:</span> <span class="nn">CompressionType</span><span class="p">::</span><span class="nb">None</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">created_at</span><span class="p">:</span> <span class="nn">chrono</span><span class="p">::</span><span class="nn">Utc</span><span class="p">::</span><span class="nf">now</span><span class="p">()</span><span class="nf">.timestamp</span><span class="p">(),</span>
            <span class="n">updated_at</span><span class="p">:</span> <span class="nn">chrono</span><span class="p">::</span><span class="nn">Utc</span><span class="p">::</span><span class="nf">now</span><span class="p">()</span><span class="nf">.timestamp</span><span class="p">(),</span>
        <span class="p">};</span>
        
        <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="nn">bincode</span><span class="p">::</span><span class="nf">serialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stored_record</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.tikv_txn</span><span class="nf">.put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.affected_models</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">DataModel</span><span class="p">::</span><span class="n">Vector</span><span class="p">);</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">create_graph_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">from_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">relation</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">to_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">properties</span><span class="p">:</span> <span class="nn">serde_json</span><span class="p">::</span><span class="n">Value</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TransactionError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// 1. Create edge record</span>
        <span class="k">let</span> <span class="n">edge_key</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.key_builder</span><span class="p">()</span><span class="nf">.edge_key</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">from_id</span><span class="p">,</span> <span class="n">relation</span><span class="p">,</span> <span class="n">to_id</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">edge_record</span> <span class="o">=</span> <span class="n">GraphEdgeRecord</span> <span class="p">{</span>
            <span class="n">graph</span><span class="p">:</span> <span class="n">graph</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">from_id</span><span class="p">:</span> <span class="n">from_id</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">to_id</span><span class="p">:</span> <span class="n">to_id</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">relation</span><span class="p">:</span> <span class="n">relation</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">properties</span><span class="p">,</span>
            <span class="n">weight</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">};</span>
        
        <span class="k">let</span> <span class="n">stored_edge</span> <span class="o">=</span> <span class="n">StoredRecord</span> <span class="p">{</span>
            <span class="n">model_type</span><span class="p">:</span> <span class="nn">DataModel</span><span class="p">::</span><span class="n">Graph</span><span class="p">,</span>
            <span class="n">schema_version</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="nn">bincode</span><span class="p">::</span><span class="nf">serialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edge_record</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">:</span> <span class="n">RecordMetadata</span> <span class="p">{</span>
                <span class="n">actor_id</span><span class="p">:</span> <span class="nn">ActorId</span><span class="p">::</span><span class="nf">from_graph_edge</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">from_id</span><span class="p">,</span> <span class="n">to_id</span><span class="p">),</span>
                <span class="n">transaction_id</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="py">.transaction_id</span><span class="p">),</span>
                <span class="n">version</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">checksum</span><span class="p">:</span> <span class="nf">calculate_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edge_record</span><span class="p">),</span>
                <span class="n">compression</span><span class="p">:</span> <span class="nn">CompressionType</span><span class="p">::</span><span class="nb">None</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">created_at</span><span class="p">:</span> <span class="nn">chrono</span><span class="p">::</span><span class="nn">Utc</span><span class="p">::</span><span class="nf">now</span><span class="p">()</span><span class="nf">.timestamp</span><span class="p">(),</span>
            <span class="n">updated_at</span><span class="p">:</span> <span class="nn">chrono</span><span class="p">::</span><span class="nn">Utc</span><span class="p">::</span><span class="nf">now</span><span class="p">()</span><span class="nf">.timestamp</span><span class="p">(),</span>
        <span class="p">};</span>
        
        <span class="k">self</span><span class="py">.tikv_txn</span><span class="nf">.put</span><span class="p">(</span><span class="n">edge_key</span><span class="p">,</span> <span class="nn">bincode</span><span class="p">::</span><span class="nf">serialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stored_edge</span><span class="p">)</span><span class="o">?</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// 2. Update adjacency lists</span>
        <span class="k">self</span><span class="nf">.update_adjacency_list</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">from_id</span><span class="p">,</span> <span class="nn">Direction</span><span class="p">::</span><span class="n">Outbound</span><span class="p">,</span> <span class="n">to_id</span><span class="p">,</span> <span class="n">relation</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="nf">.update_adjacency_list</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">to_id</span><span class="p">,</span> <span class="nn">Direction</span><span class="p">::</span><span class="n">Inbound</span><span class="p">,</span> <span class="n">from_id</span><span class="p">,</span> <span class="n">relation</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="k">self</span><span class="py">.affected_models</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">DataModel</span><span class="p">::</span><span class="n">Graph</span><span class="p">);</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">commit</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TransactionError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Check timeout</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.start_time</span><span class="nf">.elapsed</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">self</span><span class="py">.timeout</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">TransactionError</span><span class="p">::</span><span class="n">Timeout</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="c1">// Validate cross-model constraints</span>
        <span class="k">self</span><span class="nf">.validate_cross_model_constraints</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Commit TiKV transaction</span>
        <span class="k">self</span><span class="py">.tikv_txn</span><span class="nf">.commit</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Notify affected actors</span>
        <span class="k">self</span><span class="nf">.notify_affected_actors</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">rollback</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TransactionError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.tikv_txn</span><span class="nf">.rollback</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">validate_cross_model_constraints</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TransactionError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Validate foreign key constraints across models</span>
        <span class="c1">// Validate vector dimension consistency</span>
        <span class="c1">// Validate graph relationship integrity</span>
        <span class="c1">// etc.</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">notify_affected_actors</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TransactionError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">actor_id</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.affected_actors</span> <span class="p">{</span>
            <span class="c1">// Send notification to actor about committed changes</span>
            <span class="nn">ActorSystem</span><span class="p">::</span><span class="nf">notify_transaction_commit</span><span class="p">(</span><span class="o">*</span><span class="n">actor_id</span><span class="p">,</span> <span class="k">self</span><span class="py">.transaction_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">key_builder</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">MultiModelKeyBuilder</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="n">GLOBAL_KEY_BUILDER</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="distributed-transaction-coordination">Distributed Transaction Coordination</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">DistributedTransactionCoordinator</span> <span class="p">{</span>
    <span class="n">client</span><span class="p">:</span> <span class="n">TiKVClient</span><span class="p">,</span>
    <span class="n">region_manager</span><span class="p">:</span> <span class="n">RegionManager</span><span class="p">,</span>
    <span class="n">transaction_registry</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">RwLock</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">TransactionId</span><span class="p">,</span> <span class="n">TransactionState</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TransactionState</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">transaction_id</span><span class="p">:</span> <span class="n">TransactionId</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">coordinator_region</span><span class="p">:</span> <span class="n">RegionId</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">participant_regions</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">RegionId</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">state</span><span class="p">:</span> <span class="n">TxnState</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">created_at</span><span class="p">:</span> <span class="n">Instant</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">timeout</span><span class="p">:</span> <span class="n">Duration</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">TxnState</span> <span class="p">{</span>
    <span class="n">Active</span><span class="p">,</span>
    <span class="n">Preparing</span><span class="p">,</span>
    <span class="n">Prepared</span><span class="p">,</span>
    <span class="n">Committing</span><span class="p">,</span>
    <span class="n">Committed</span><span class="p">,</span>
    <span class="n">Aborted</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DistributedTransactionCoordinator</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">begin_distributed_transaction</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">regions</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">RegionId</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">TransactionId</span><span class="p">,</span> <span class="n">TransactionError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">transaction_id</span> <span class="o">=</span> <span class="nn">TransactionId</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">coordinator_region</span> <span class="o">=</span> <span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// First region is coordinator</span>
        <span class="k">let</span> <span class="n">participant_regions</span> <span class="o">=</span> <span class="n">regions</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
        
        <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="n">TransactionState</span> <span class="p">{</span>
            <span class="n">transaction_id</span><span class="p">,</span>
            <span class="n">coordinator_region</span><span class="p">,</span>
            <span class="n">participant_regions</span><span class="p">:</span> <span class="n">participant_regions</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">state</span><span class="p">:</span> <span class="nn">TxnState</span><span class="p">::</span><span class="n">Active</span><span class="p">,</span>
            <span class="n">created_at</span><span class="p">:</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">(),</span>
            <span class="n">timeout</span><span class="p">:</span> <span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
        <span class="p">};</span>
        
        <span class="c1">// Register transaction</span>
        <span class="k">self</span><span class="py">.transaction_registry</span><span class="nf">.write</span><span class="p">()</span><span class="k">.await</span><span class="nf">.insert</span><span class="p">(</span><span class="n">transaction_id</span><span class="p">,</span> <span class="n">state</span><span class="nf">.clone</span><span class="p">());</span>
        
        <span class="c1">// Send begin transaction to all participants</span>
        <span class="k">for</span> <span class="n">region_id</span> <span class="k">in</span> <span class="n">participant_regions</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.send_begin_transaction</span><span class="p">(</span><span class="n">region_id</span><span class="p">,</span> <span class="n">transaction_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">transaction_id</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">prepare_transaction</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">transaction_id</span><span class="p">:</span> <span class="n">TransactionId</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TransactionError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">registry</span> <span class="o">=</span> <span class="k">self</span><span class="py">.transaction_registry</span><span class="nf">.write</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="n">registry</span><span class="nf">.get_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction_id</span><span class="p">)</span><span class="nf">.ok_or</span><span class="p">(</span><span class="nn">TransactionError</span><span class="p">::</span><span class="n">NotFound</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="n">state</span><span class="py">.state</span> <span class="o">!=</span> <span class="nn">TxnState</span><span class="p">::</span><span class="n">Active</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">TransactionError</span><span class="p">::</span><span class="n">InvalidState</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="n">state</span><span class="py">.state</span> <span class="o">=</span> <span class="nn">TxnState</span><span class="p">::</span><span class="n">Preparing</span><span class="p">;</span>
        <span class="nf">drop</span><span class="p">(</span><span class="n">registry</span><span class="p">);</span>
        
        <span class="c1">// Phase 1: Prepare</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">prepare_results</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">region_id</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">state</span><span class="py">.participant_regions</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.send_prepare</span><span class="p">(</span><span class="n">region_id</span><span class="p">,</span> <span class="n">transaction_id</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
            <span class="n">prepare_results</span><span class="nf">.push</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="c1">// Check if all participants voted to commit</span>
        <span class="k">let</span> <span class="n">all_prepared</span> <span class="o">=</span> <span class="n">prepare_results</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="n">r</span><span class="p">|</span> <span class="n">r</span><span class="nf">.is_ok</span><span class="p">());</span>
        
        <span class="k">let</span> <span class="k">mut</span> <span class="n">registry</span> <span class="o">=</span> <span class="k">self</span><span class="py">.transaction_registry</span><span class="nf">.write</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="n">registry</span><span class="nf">.get_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction_id</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        
        <span class="k">if</span> <span class="n">all_prepared</span> <span class="p">{</span>
            <span class="n">state</span><span class="py">.state</span> <span class="o">=</span> <span class="nn">TxnState</span><span class="p">::</span><span class="n">Prepared</span><span class="p">;</span>
            <span class="nf">Ok</span><span class="p">(())</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">state</span><span class="py">.state</span> <span class="o">=</span> <span class="nn">TxnState</span><span class="p">::</span><span class="n">Aborted</span><span class="p">;</span>
            <span class="nf">Err</span><span class="p">(</span><span class="nn">TransactionError</span><span class="p">::</span><span class="n">PrepareFailed</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">commit_transaction</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">transaction_id</span><span class="p">:</span> <span class="n">TransactionId</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TransactionError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">registry</span> <span class="o">=</span> <span class="k">self</span><span class="py">.transaction_registry</span><span class="nf">.write</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="n">registry</span><span class="nf">.get_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction_id</span><span class="p">)</span><span class="nf">.ok_or</span><span class="p">(</span><span class="nn">TransactionError</span><span class="p">::</span><span class="n">NotFound</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="n">state</span><span class="py">.state</span> <span class="o">!=</span> <span class="nn">TxnState</span><span class="p">::</span><span class="n">Prepared</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">TransactionError</span><span class="p">::</span><span class="n">InvalidState</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="n">state</span><span class="py">.state</span> <span class="o">=</span> <span class="nn">TxnState</span><span class="p">::</span><span class="n">Committing</span><span class="p">;</span>
        <span class="nf">drop</span><span class="p">(</span><span class="n">registry</span><span class="p">);</span>
        
        <span class="c1">// Phase 2: Commit</span>
        <span class="k">for</span> <span class="n">region_id</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">state</span><span class="py">.participant_regions</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.send_commit</span><span class="p">(</span><span class="n">region_id</span><span class="p">,</span> <span class="n">transaction_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">let</span> <span class="k">mut</span> <span class="n">registry</span> <span class="o">=</span> <span class="k">self</span><span class="py">.transaction_registry</span><span class="nf">.write</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="n">registry</span><span class="nf">.get_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction_id</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="n">state</span><span class="py">.state</span> <span class="o">=</span> <span class="nn">TxnState</span><span class="p">::</span><span class="n">Committed</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">send_begin_transaction</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">region_id</span><span class="p">:</span> <span class="n">RegionId</span><span class="p">,</span> <span class="n">transaction_id</span><span class="p">:</span> <span class="n">TransactionId</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TransactionError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Send begin transaction message to region</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">send_prepare</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">region_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">RegionId</span><span class="p">,</span> <span class="n">transaction_id</span><span class="p">:</span> <span class="n">TransactionId</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TransactionError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Send prepare message to region</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">send_commit</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">region_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">RegionId</span><span class="p">,</span> <span class="n">transaction_id</span><span class="p">:</span> <span class="n">TransactionId</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TransactionError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Send commit message to region</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="performance-optimization">Performance Optimization</h2>

<h3 id="query-optimization-strategies">Query Optimization Strategies</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">TiKVQueryOptimizer</span> <span class="p">{</span>
    <span class="n">statistics</span><span class="p">:</span> <span class="n">StatisticsManager</span><span class="p">,</span>
    <span class="n">cost_model</span><span class="p">:</span> <span class="n">CostModel</span><span class="p">,</span>
    <span class="n">region_manager</span><span class="p">:</span> <span class="n">RegionManager</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TiKVQueryOptimizer</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">optimize_multi_model_query</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">MultiModelQuery</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">OptimizedQuery</span><span class="p">,</span> <span class="n">OptimizerError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">optimized</span> <span class="o">=</span> <span class="nn">OptimizedQuery</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        
        <span class="c1">// 1. Analyze query patterns</span>
        <span class="k">let</span> <span class="n">patterns</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.analyze_query_patterns</span><span class="p">(</span><span class="n">query</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// 2. Determine optimal execution strategy</span>
        <span class="k">let</span> <span class="n">strategy</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.determine_execution_strategy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">patterns</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// 3. Generate region-aware execution plan</span>
        <span class="k">let</span> <span class="n">execution_plan</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.generate_execution_plan</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">strategy</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// 4. Apply TiKV-specific optimizations</span>
        <span class="k">let</span> <span class="n">tikv_optimized</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.apply_tikv_optimizations</span><span class="p">(</span><span class="n">execution_plan</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="n">optimized</span><span class="py">.execution_plan</span> <span class="o">=</span> <span class="n">tikv_optimized</span><span class="p">;</span>
        <span class="n">optimized</span><span class="py">.estimated_cost</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.calculate_execution_cost</span><span class="p">(</span><span class="o">&amp;</span><span class="n">optimized</span><span class="py">.execution_plan</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">optimized</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">determine_execution_strategy</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">patterns</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">QueryPattern</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">ExecutionStrategy</span><span class="p">,</span> <span class="n">OptimizerError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">strategy</span> <span class="o">=</span> <span class="nn">ExecutionStrategy</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
        
        <span class="k">for</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">patterns</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">pattern</span> <span class="p">{</span>
                <span class="nn">QueryPattern</span><span class="p">::</span><span class="n">PointLookup</span> <span class="p">{</span> <span class="n">model</span><span class="p">,</span> <span class="n">key</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">strategy</span><span class="nf">.add_point_lookup</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
                <span class="p">},</span>
                <span class="nn">QueryPattern</span><span class="p">::</span><span class="n">RangeScan</span> <span class="p">{</span> <span class="n">model</span><span class="p">,</span> <span class="n">start_key</span><span class="p">,</span> <span class="n">end_key</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">region_splits</span> <span class="o">=</span> <span class="k">self</span><span class="py">.region_manager</span><span class="nf">.get_region_splits</span><span class="p">(</span><span class="n">start_key</span><span class="p">,</span> <span class="n">end_key</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                    <span class="n">strategy</span><span class="nf">.add_distributed_scan</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">region_splits</span><span class="p">);</span>
                <span class="p">},</span>
                <span class="nn">QueryPattern</span><span class="p">::</span><span class="n">Join</span> <span class="p">{</span> <span class="n">left_model</span><span class="p">,</span> <span class="n">right_model</span><span class="p">,</span> <span class="n">join_type</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">join_strategy</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.choose_join_strategy</span><span class="p">(</span><span class="n">left_model</span><span class="p">,</span> <span class="n">right_model</span><span class="p">,</span> <span class="n">join_type</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                    <span class="n">strategy</span><span class="nf">.add_join</span><span class="p">(</span><span class="n">join_strategy</span><span class="p">);</span>
                <span class="p">},</span>
                <span class="nn">QueryPattern</span><span class="p">::</span><span class="n">Aggregation</span> <span class="p">{</span> <span class="n">model</span><span class="p">,</span> <span class="n">aggregation_type</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">strategy</span><span class="nf">.add_pushdown_aggregation</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">aggregation_type</span><span class="p">);</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">strategy</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">apply_tikv_optimizations</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">plan</span><span class="p">:</span> <span class="n">ExecutionPlan</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">ExecutionPlan</span><span class="p">,</span> <span class="n">OptimizerError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">optimized_plan</span> <span class="o">=</span> <span class="n">plan</span><span class="p">;</span>
        
        <span class="c1">// 1. Coprocessor pushdown</span>
        <span class="n">optimized_plan</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.apply_coprocessor_pushdown</span><span class="p">(</span><span class="n">optimized_plan</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// 2. Batch operations</span>
        <span class="n">optimized_plan</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.batch_operations</span><span class="p">(</span><span class="n">optimized_plan</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// 3. Region-aware parallelization</span>
        <span class="n">optimized_plan</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.parallelize_by_region</span><span class="p">(</span><span class="n">optimized_plan</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// 4. Index utilization</span>
        <span class="n">optimized_plan</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.optimize_index_usage</span><span class="p">(</span><span class="n">optimized_plan</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">optimized_plan</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">apply_coprocessor_pushdown</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">plan</span><span class="p">:</span> <span class="n">ExecutionPlan</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">ExecutionPlan</span><span class="p">,</span> <span class="n">OptimizerError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Identify operations that can be pushed to TiKV coprocessors</span>
        <span class="c1">// Transform plan to use coprocessor requests</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">plan</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">parallelize_by_region</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">plan</span><span class="p">:</span> <span class="n">ExecutionPlan</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">ExecutionPlan</span><span class="p">,</span> <span class="n">OptimizerError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Split operations across regions for parallel execution</span>
        <span class="c1">// Generate region-specific sub-plans</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">plan</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="caching-strategies">Caching Strategies</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">TiKVCacheManager</span> <span class="p">{</span>
    <span class="n">region_cache</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">LruCache</span><span class="o">&lt;</span><span class="n">RegionId</span><span class="p">,</span> <span class="n">RegionInfo</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">schema_cache</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">LruCache</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="n">SchemaInfo</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">query_result_cache</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">LruCache</span><span class="o">&lt;</span><span class="n">QueryHash</span><span class="p">,</span> <span class="n">QueryResult</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">statistics_cache</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">LruCache</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="n">TableStatistics</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TiKVCacheManager</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">get_cached_query_result</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">query_hash</span><span class="p">:</span> <span class="n">QueryHash</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">QueryResult</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.query_result_cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">query_hash</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">r</span><span class="p">|</span> <span class="n">r</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">cache_query_result</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">query_hash</span><span class="p">:</span> <span class="n">QueryHash</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">QueryResult</span><span class="p">,</span> <span class="n">ttl</span><span class="p">:</span> <span class="n">Duration</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cached_result</span> <span class="o">=</span> <span class="n">CachedQueryResult</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">,</span>
            <span class="n">created_at</span><span class="p">:</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">(),</span>
            <span class="n">ttl</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="k">self</span><span class="py">.query_result_cache</span><span class="nf">.put</span><span class="p">(</span><span class="n">query_hash</span><span class="p">,</span> <span class="n">cached_result</span><span class="py">.result</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">invalidate_region_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">region_id</span><span class="p">:</span> <span class="n">RegionId</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.region_cache</span><span class="nf">.pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">region_id</span><span class="p">);</span>
        
        <span class="c1">// Invalidate related query results</span>
        <span class="k">self</span><span class="nf">.invalidate_region_related_queries</span><span class="p">(</span><span class="n">region_id</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">warm_up_caches</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">CacheError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Pre-load frequently accessed schemas</span>
        <span class="k">self</span><span class="nf">.preload_schemas</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Pre-load region information</span>
        <span class="k">self</span><span class="nf">.preload_regions</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Pre-load table statistics</span>
        <span class="k">self</span><span class="nf">.preload_statistics</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="implementation-roadmap">Implementation Roadmap</h2>

<h3 id="phase-1-foundation-months-1-2">Phase 1: Foundation (Months 1-2)</h3>

<h4 id="month-1-storage-provider-interface">Month 1: Storage Provider Interface</h4>
<p><strong>Objectives:</strong></p>
<ul>
  <li>Design unified storage provider trait</li>
  <li>Implement TiKV storage provider</li>
  <li>Create storage manager for provider selection</li>
</ul>

<p><strong>Deliverables:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">StorageProvider</code> trait definition</li>
  <li><code class="language-plaintext highlighter-rouge">TiKVProvider</code> implementation</li>
  <li><code class="language-plaintext highlighter-rouge">RocksDBProvider</code> implementation</li>
  <li><code class="language-plaintext highlighter-rouge">StorageManager</code> with provider selection</li>
</ul>

<p><strong>Technical Tasks:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Week 1-2: Provider Interface Design</span>
<span class="o">-</span> <span class="n">Define</span> <span class="n">StorageProvider</span> <span class="k">trait</span>
<span class="o">-</span> <span class="n">Implement</span> <span class="n">provider</span> <span class="n">capability</span> <span class="n">detection</span>
<span class="o">-</span> <span class="n">Create</span> <span class="n">provider</span> <span class="n">selection</span> <span class="n">strategies</span>
<span class="o">-</span> <span class="n">Basic</span> <span class="n">configuration</span> <span class="n">management</span>

<span class="c1">// Week 3-4: TiKV Provider Implementation</span>
<span class="o">-</span> <span class="n">Implement</span> <span class="n">TiKVProvider</span> <span class="k">struct</span>
<span class="o">-</span> <span class="nb">Add</span> <span class="n">tikv</span><span class="o">-</span><span class="n">client</span> <span class="n">integration</span>
<span class="o">-</span> <span class="n">Provider</span> <span class="n">registration</span> <span class="n">and</span> <span class="n">lifecycle</span>
<span class="o">-</span> <span class="n">Actor</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">provider</span> <span class="n">assignment</span> <span class="n">logic</span>
</code></pre></div></div>

<h4 id="month-2-multi-model-storage">Month 2: Multi-Model Storage</h4>
<p><strong>Objectives:</strong></p>
<ul>
  <li>Implement multi-model key design patterns</li>
  <li>Create storage format specifications</li>
  <li>Build data serialization/deserialization</li>
</ul>

<p><strong>Deliverables:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">MultiModelKeyBuilder</code> implementation</li>
  <li>Storage format definitions</li>
  <li>Serialization benchmarks</li>
  <li>Multi-model unit tests</li>
</ul>

<p><strong>Technical Tasks:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Week 5-6: Key Design</span>
<span class="o">-</span> <span class="n">Implement</span> <span class="n">key</span> <span class="n">building</span> <span class="n">patterns</span> <span class="k">for</span> <span class="n">all</span> <span class="n">data</span> <span class="n">models</span>
<span class="o">-</span> <span class="n">Create</span> <span class="n">namespace</span> <span class="n">separation</span> <span class="n">strategies</span>
<span class="o">-</span> <span class="n">Optimize</span> <span class="n">key</span> <span class="n">distribution</span> <span class="k">for</span> <span class="n">performance</span>
<span class="o">-</span> <span class="nb">Index</span> <span class="n">key</span> <span class="n">generation</span>

<span class="c1">// Week 7-8: Storage Formats</span>
<span class="o">-</span> <span class="n">Define</span> <span class="n">storage</span> <span class="n">record</span> <span class="n">structures</span>
<span class="o">-</span> <span class="n">Implement</span> <span class="n">compression</span> <span class="n">strategies</span>
<span class="o">-</span> <span class="n">Create</span> <span class="n">schema</span> <span class="n">versioning</span> <span class="n">system</span>
<span class="o">-</span> <span class="n">Metadata</span> <span class="n">management</span>
</code></pre></div></div>

<h4 id="month-3-transaction-integration">Month 3: Transaction Integration</h4>
<p><strong>Objectives:</strong></p>
<ul>
  <li>Integrate TiKV transactions with Orbit-RS</li>
  <li>Implement cross-model ACID guarantees</li>
  <li>Create transaction management layer</li>
</ul>

<p><strong>Deliverables:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">OrbitTransaction</code> implementation</li>
  <li>Cross-model constraint validation</li>
  <li>Transaction timeout and retry logic</li>
  <li>Performance benchmarks</li>
</ul>

<p><strong>Technical Tasks:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Week 9-10: Transaction Layer</span>
<span class="o">-</span> <span class="n">Implement</span> <span class="n">OrbitTransaction</span> <span class="n">wrapper</span>
<span class="o">-</span> <span class="n">Cross</span><span class="o">-</span><span class="n">model</span> <span class="n">operation</span> <span class="n">support</span>
<span class="o">-</span> <span class="n">Isolation</span> <span class="n">level</span> <span class="n">management</span>
<span class="o">-</span> <span class="n">Deadlock</span> <span class="n">detection</span> <span class="n">and</span> <span class="n">resolution</span>

<span class="c1">// Week 11-12: ACID Guarantees</span>
<span class="o">-</span> <span class="n">Cross</span><span class="o">-</span><span class="n">model</span> <span class="n">constraint</span> <span class="n">validation</span>
<span class="o">-</span> <span class="n">Referential</span> <span class="n">integrity</span> <span class="n">across</span> <span class="n">models</span>
<span class="o">-</span> <span class="n">Consistency</span> <span class="n">level</span> <span class="n">configuration</span>
<span class="o">-</span> <span class="n">Transaction</span> <span class="n">recovery</span> <span class="n">mechanisms</span>
</code></pre></div></div>

<h3 id="phase-2-optimization-months-4-6">Phase 2: Optimization (Months 4-6)</h3>

<h4 id="month-4-query-optimization">Month 4: Query Optimization</h4>
<p><strong>Objectives:</strong></p>
<ul>
  <li>Build TiKV-specific query optimizer</li>
  <li>Implement coprocessor pushdown</li>
  <li>Create region-aware execution plans</li>
</ul>

<p><strong>Deliverables:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">TiKVQueryOptimizer</code> implementation</li>
  <li>Coprocessor integration</li>
  <li>Execution plan generation</li>
  <li>Performance benchmarks</li>
</ul>

<h4 id="month-5-caching-and-performance">Month 5: Caching and Performance</h4>
<p><strong>Objectives:</strong></p>
<ul>
  <li>Implement multi-level caching</li>
  <li>Optimize data locality</li>
  <li>Build performance monitoring</li>
</ul>

<p><strong>Deliverables:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">TiKVCacheManager</code> implementation</li>
  <li>Data locality optimizer</li>
  <li>Metrics collection system</li>
  <li>Performance dashboard</li>
</ul>

<h4 id="month-6-advanced-features">Month 6: Advanced Features</h4>
<p><strong>Objectives:</strong></p>
<ul>
  <li>Implement advanced TiKV features</li>
  <li>Add backup and recovery</li>
  <li>Create monitoring and alerting</li>
</ul>

<p><strong>Deliverables:</strong></p>
<ul>
  <li>Point-in-time recovery</li>
  <li>Distributed backup system</li>
  <li>Comprehensive monitoring</li>
  <li>Operational runbooks</li>
</ul>

<h3 id="phase-3-production-readiness-months-7-9">Phase 3: Production Readiness (Months 7-9)</h3>

<h4 id="month-7-scalability-testing">Month 7: Scalability Testing</h4>
<p><strong>Objectives:</strong></p>
<ul>
  <li>Large-scale performance testing</li>
  <li>Auto-scaling implementation</li>
  <li>Load balancing optimization</li>
</ul>

<p><strong>Deliverables:</strong></p>
<ul>
  <li>Performance benchmarks at scale</li>
  <li>Auto-scaling algorithms</li>
  <li>Load testing results</li>
  <li>Capacity planning tools</li>
</ul>

<h4 id="month-8-operations-and-monitoring">Month 8: Operations and Monitoring</h4>
<p><strong>Objectives:</strong></p>
<ul>
  <li>Production monitoring system</li>
  <li>Alerting and incident response</li>
  <li>Operational automation</li>
</ul>

<p><strong>Deliverables:</strong></p>
<ul>
  <li>Comprehensive monitoring dashboard</li>
  <li>Alerting rules and runbooks</li>
  <li>Automated deployment scripts</li>
  <li>Disaster recovery procedures</li>
</ul>

<h4 id="month-9-documentation-and-training">Month 9: Documentation and Training</h4>
<p><strong>Objectives:</strong></p>
<ul>
  <li>Complete documentation</li>
  <li>Training materials</li>
  <li>Migration tools</li>
</ul>

<p><strong>Deliverables:</strong></p>
<ul>
  <li>Technical documentation</li>
  <li>Operational guides</li>
  <li>Training workshops</li>
  <li>Migration automation tools</li>
</ul>

<h3 id="implementation-milestones">Implementation Milestones</h3>

<table>
  <thead>
    <tr>
      <th>Milestone</th>
      <th>Timeline</th>
      <th>Success Criteria</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Storage Provider MVP</strong></td>
      <td>Month 2</td>
      <td>TiKV and RocksDB providers working with basic operations</td>
    </tr>
    <tr>
      <td><strong>Provider Selection</strong></td>
      <td>Month 4</td>
      <td>Intelligent provider selection based on actor patterns</td>
    </tr>
    <tr>
      <td><strong>Production Alpha</strong></td>
      <td>Month 6</td>
      <td>Successful deployment with multiple storage providers</td>
    </tr>
    <tr>
      <td><strong>Performance Optimization</strong></td>
      <td>Month 9</td>
      <td>Provider-specific optimizations delivering expected benefits</td>
    </tr>
    <tr>
      <td><strong>General Availability</strong></td>
      <td>Month 12</td>
      <td>Full production readiness with monitoring and migration tools</td>
    </tr>
  </tbody>
</table>

<h2 id="operational-considerations">Operational Considerations</h2>

<h3 id="deployment-architecture">Deployment Architecture</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># TiKV Cluster Configuration for Orbit-RS</span>
<span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.8"</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="c1"># Placement Driver (PD) - Cluster metadata management</span>
  <span class="na">pd1</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">pingcap/pd:latest</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">2379:2379"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">2380:2380"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">pd1-data:/data</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">PD_NAME=pd1</span>
      <span class="pi">-</span> <span class="s">PD_CLIENT_URLS=http://0.0.0.0:2379</span>
      <span class="pi">-</span> <span class="s">PD_PEER_URLS=http://0.0.0.0:2380</span>
      <span class="pi">-</span> <span class="s">PD_INITIAL_CLUSTER=pd1=http://pd1:2380,pd2=http://pd2:2380,pd3=http://pd3:2380</span>
    
  <span class="c1"># TiKV Storage Nodes</span>
  <span class="na">tikv1</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">pingcap/tikv:latest</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">20160:20160"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">tikv1-data:/data</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">TIKV_ADDR=0.0.0.0:20160</span>
      <span class="pi">-</span> <span class="s">PD_ENDPOINTS=http://pd1:2379,http://pd2:2379,http://pd3:2379</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">pd1</span>
      <span class="pi">-</span> <span class="s">pd2</span>
      <span class="pi">-</span> <span class="s">pd3</span>
      
  <span class="c1"># Orbit-RS Application Nodes</span>
  <span class="na">orbit-rs-1</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">orbit-rs:tikv-integration</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5432:5432"</span>  <span class="c1"># PostgreSQL protocol</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">6379:6379"</span>  <span class="c1"># Redis protocol</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8080:8080"</span>  <span class="c1"># HTTP/REST</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">ORBIT_TIKV_ENDPOINTS=http://pd1:2379,http://pd2:2379,http://pd3:2379</span>
      <span class="pi">-</span> <span class="s">ORBIT_ACTOR_REGIONS=region1,region2,region3</span>
      <span class="pi">-</span> <span class="s">ORBIT_CACHE_SIZE=1GB</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">tikv1</span>
      <span class="pi">-</span> <span class="s">tikv2</span>
      <span class="pi">-</span> <span class="s">tikv3</span>

<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">pd1-data</span><span class="pi">:</span>
  <span class="na">pd2-data</span><span class="pi">:</span>
  <span class="na">pd3-data</span><span class="pi">:</span>
  <span class="na">tikv1-data</span><span class="pi">:</span>
  <span class="na">tikv2-data</span><span class="pi">:</span>
  <span class="na">tikv3-data</span><span class="pi">:</span>
</code></pre></div></div>

<h3 id="monitoring-and-alerting">Monitoring and Alerting</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">TiKVMonitoringSystem</span> <span class="p">{</span>
    <span class="n">metrics_collector</span><span class="p">:</span> <span class="n">MetricsCollector</span><span class="p">,</span>
    <span class="n">alert_manager</span><span class="p">:</span> <span class="n">AlertManager</span><span class="p">,</span>
    <span class="n">dashboard</span><span class="p">:</span> <span class="n">MonitoringDashboard</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TiKVMonitoringSystem</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">collect_metrics</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">SystemMetrics</span><span class="p">,</span> <span class="n">MonitoringError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">tikv_metrics</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.collect_tikv_metrics</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">orbit_metrics</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.collect_orbit_metrics</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">integration_metrics</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.collect_integration_metrics</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">SystemMetrics</span> <span class="p">{</span>
            <span class="n">tikv</span><span class="p">:</span> <span class="n">tikv_metrics</span><span class="p">,</span>
            <span class="n">orbit</span><span class="p">:</span> <span class="n">orbit_metrics</span><span class="p">,</span>
            <span class="n">integration</span><span class="p">:</span> <span class="n">integration_metrics</span><span class="p">,</span>
            <span class="n">timestamp</span><span class="p">:</span> <span class="nn">chrono</span><span class="p">::</span><span class="nn">Utc</span><span class="p">::</span><span class="nf">now</span><span class="p">(),</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">collect_tikv_metrics</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">TiKVMetrics</span><span class="p">,</span> <span class="n">MonitoringError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Collect TiKV-specific metrics</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">TiKVMetrics</span> <span class="p">{</span>
            <span class="n">region_count</span><span class="p">:</span> <span class="k">self</span><span class="nf">.get_region_count</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
            <span class="n">qps</span><span class="p">:</span> <span class="k">self</span><span class="nf">.get_queries_per_second</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
            <span class="n">latency_p99</span><span class="p">:</span> <span class="k">self</span><span class="nf">.get_latency_percentile</span><span class="p">(</span><span class="mf">99.0</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
            <span class="n">storage_usage</span><span class="p">:</span> <span class="k">self</span><span class="nf">.get_storage_usage</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
            <span class="n">raft_log_lag</span><span class="p">:</span> <span class="k">self</span><span class="nf">.get_raft_log_lag</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
            <span class="n">coprocessor_usage</span><span class="p">:</span> <span class="k">self</span><span class="nf">.get_coprocessor_usage</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">collect_integration_metrics</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">IntegrationMetrics</span><span class="p">,</span> <span class="n">MonitoringError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">IntegrationMetrics</span> <span class="p">{</span>
            <span class="n">actor_region_mappings</span><span class="p">:</span> <span class="k">self</span><span class="nf">.get_actor_region_mappings</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
            <span class="n">cross_model_transactions</span><span class="p">:</span> <span class="k">self</span><span class="nf">.get_cross_model_transaction_count</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
            <span class="n">cache_hit_ratio</span><span class="p">:</span> <span class="k">self</span><span class="nf">.get_cache_hit_ratio</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
            <span class="n">data_locality_score</span><span class="p">:</span> <span class="k">self</span><span class="nf">.get_data_locality_score</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
            <span class="n">migration_operations</span><span class="p">:</span> <span class="k">self</span><span class="nf">.get_migration_operations</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="backup-and-recovery">Backup and Recovery</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">TiKVBackupManager</span> <span class="p">{</span>
    <span class="n">backup_storage</span><span class="p">:</span> <span class="n">BackupStorageConfig</span><span class="p">,</span>
    <span class="n">tikv_client</span><span class="p">:</span> <span class="n">TiKVClient</span><span class="p">,</span>
    <span class="n">scheduler</span><span class="p">:</span> <span class="n">BackupScheduler</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TiKVBackupManager</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">create_full_backup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">backup_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">BackupInfo</span><span class="p">,</span> <span class="n">BackupError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// 1. Create consistent snapshot across all regions</span>
        <span class="k">let</span> <span class="n">snapshot_ts</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tikv_client</span><span class="nf">.get_current_timestamp</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// 2. Backup each region to storage</span>
        <span class="k">let</span> <span class="n">regions</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tikv_client</span><span class="nf">.get_all_regions</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">backup_tasks</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        
        <span class="k">for</span> <span class="n">region</span> <span class="k">in</span> <span class="n">regions</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">task</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.backup_region</span><span class="p">(</span><span class="n">region</span><span class="py">.id</span><span class="p">,</span> <span class="n">snapshot_ts</span><span class="p">,</span> <span class="n">backup_id</span><span class="p">);</span>
            <span class="n">backup_tasks</span><span class="nf">.push</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="c1">// 3. Wait for all region backups to complete</span>
        <span class="k">let</span> <span class="n">backup_results</span> <span class="o">=</span> <span class="nn">futures</span><span class="p">::</span><span class="nn">future</span><span class="p">::</span><span class="nf">join_all</span><span class="p">(</span><span class="n">backup_tasks</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
        
        <span class="c1">// 4. Create backup metadata</span>
        <span class="k">let</span> <span class="n">backup_info</span> <span class="o">=</span> <span class="n">BackupInfo</span> <span class="p">{</span>
            <span class="n">backup_id</span><span class="p">:</span> <span class="n">backup_id</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">snapshot_timestamp</span><span class="p">:</span> <span class="n">snapshot_ts</span><span class="p">,</span>
            <span class="n">regions</span><span class="p">:</span> <span class="n">backup_results</span><span class="nf">.into_iter</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
            <span class="n">created_at</span><span class="p">:</span> <span class="nn">chrono</span><span class="p">::</span><span class="nn">Utc</span><span class="p">::</span><span class="nf">now</span><span class="p">(),</span>
            <span class="n">backup_type</span><span class="p">:</span> <span class="nn">BackupType</span><span class="p">::</span><span class="n">Full</span><span class="p">,</span>
            <span class="n">size_bytes</span><span class="p">:</span> <span class="k">self</span><span class="nf">.calculate_backup_size</span><span class="p">(</span><span class="n">backup_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
        <span class="p">};</span>
        
        <span class="c1">// 5. Store backup metadata</span>
        <span class="k">self</span><span class="nf">.store_backup_metadata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">backup_info</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">backup_info</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">restore_from_backup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">backup_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">target_timestamp</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">RestoreError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// 1. Load backup metadata</span>
        <span class="k">let</span> <span class="n">backup_info</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.load_backup_metadata</span><span class="p">(</span><span class="n">backup_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// 2. Determine restore timestamp</span>
        <span class="k">let</span> <span class="n">restore_ts</span> <span class="o">=</span> <span class="n">target_timestamp</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">backup_info</span><span class="py">.snapshot_timestamp</span><span class="p">);</span>
        
        <span class="c1">// 3. Restore each region</span>
        <span class="k">for</span> <span class="n">region_backup</span> <span class="k">in</span> <span class="n">backup_info</span><span class="py">.regions</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.restore_region</span><span class="p">(</span><span class="n">region_backup</span><span class="p">,</span> <span class="n">restore_ts</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="c1">// 4. Verify data consistency</span>
        <span class="k">self</span><span class="nf">.verify_restored_data</span><span class="p">(</span><span class="n">restore_ts</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">create_incremental_backup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">base_backup_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">backup_id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">BackupInfo</span><span class="p">,</span> <span class="n">BackupError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">base_backup</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.load_backup_metadata</span><span class="p">(</span><span class="n">base_backup_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">from_ts</span> <span class="o">=</span> <span class="n">base_backup</span><span class="py">.snapshot_timestamp</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">to_ts</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tikv_client</span><span class="nf">.get_current_timestamp</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Backup only changes since base backup</span>
        <span class="k">let</span> <span class="n">regions</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tikv_client</span><span class="nf">.get_all_regions</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">backup_tasks</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        
        <span class="k">for</span> <span class="n">region</span> <span class="k">in</span> <span class="n">regions</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">task</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.backup_region_incremental</span><span class="p">(</span><span class="n">region</span><span class="py">.id</span><span class="p">,</span> <span class="n">from_ts</span><span class="p">,</span> <span class="n">to_ts</span><span class="p">,</span> <span class="n">backup_id</span><span class="p">);</span>
            <span class="n">backup_tasks</span><span class="nf">.push</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="k">let</span> <span class="n">backup_results</span> <span class="o">=</span> <span class="nn">futures</span><span class="p">::</span><span class="nn">future</span><span class="p">::</span><span class="nf">join_all</span><span class="p">(</span><span class="n">backup_tasks</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
        
        <span class="k">let</span> <span class="n">backup_info</span> <span class="o">=</span> <span class="n">BackupInfo</span> <span class="p">{</span>
            <span class="n">backup_id</span><span class="p">:</span> <span class="n">backup_id</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">snapshot_timestamp</span><span class="p">:</span> <span class="n">to_ts</span><span class="p">,</span>
            <span class="n">regions</span><span class="p">:</span> <span class="n">backup_results</span><span class="nf">.into_iter</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
            <span class="n">created_at</span><span class="p">:</span> <span class="nn">chrono</span><span class="p">::</span><span class="nn">Utc</span><span class="p">::</span><span class="nf">now</span><span class="p">(),</span>
            <span class="n">backup_type</span><span class="p">:</span> <span class="nn">BackupType</span><span class="p">::</span><span class="n">Incremental</span> <span class="p">{</span> <span class="n">base_backup</span><span class="p">:</span> <span class="n">base_backup_id</span><span class="nf">.to_string</span><span class="p">()</span> <span class="p">},</span>
            <span class="n">size_bytes</span><span class="p">:</span> <span class="k">self</span><span class="nf">.calculate_backup_size</span><span class="p">(</span><span class="n">backup_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
        <span class="p">};</span>
        
        <span class="k">self</span><span class="nf">.store_backup_metadata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">backup_info</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">backup_info</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="migration-strategy">Migration Strategy</h2>

<h3 id="from-existing-storage-backends">From Existing Storage Backends</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">StorageBackendMigrator</span> <span class="p">{</span>
    <span class="n">source_backend</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">StorageBackend</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">tikv_backend</span><span class="p">:</span> <span class="n">TiKVStorageBackend</span><span class="p">,</span>
    <span class="n">migration_config</span><span class="p">:</span> <span class="n">MigrationConfig</span><span class="p">,</span>
    <span class="n">progress_tracker</span><span class="p">:</span> <span class="n">MigrationProgressTracker</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">StorageBackendMigrator</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">migrate_to_tikv</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">MigrationReport</span><span class="p">,</span> <span class="n">MigrationError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">migration_id</span> <span class="o">=</span> <span class="nn">MigrationId</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.progress_tracker</span><span class="nf">.start_migration</span><span class="p">(</span><span class="n">migration_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Phase 1: Schema Migration</span>
        <span class="k">self</span><span class="nf">.migrate_schemas</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.progress_tracker</span><span class="nf">.complete_phase</span><span class="p">(</span><span class="n">migration_id</span><span class="p">,</span> <span class="nn">MigrationPhase</span><span class="p">::</span><span class="n">Schema</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Phase 2: Data Migration</span>
        <span class="k">let</span> <span class="n">data_report</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.migrate_data</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.progress_tracker</span><span class="nf">.complete_phase</span><span class="p">(</span><span class="n">migration_id</span><span class="p">,</span> <span class="nn">MigrationPhase</span><span class="p">::</span><span class="n">Data</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Phase 3: Index Migration</span>
        <span class="k">self</span><span class="nf">.migrate_indexes</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.progress_tracker</span><span class="nf">.complete_phase</span><span class="p">(</span><span class="n">migration_id</span><span class="p">,</span> <span class="nn">MigrationPhase</span><span class="p">::</span><span class="n">Indexes</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Phase 4: Validation</span>
        <span class="k">let</span> <span class="n">validation_report</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.validate_migration</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.progress_tracker</span><span class="nf">.complete_phase</span><span class="p">(</span><span class="n">migration_id</span><span class="p">,</span> <span class="nn">MigrationPhase</span><span class="p">::</span><span class="n">Validation</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="k">let</span> <span class="n">migration_report</span> <span class="o">=</span> <span class="n">MigrationReport</span> <span class="p">{</span>
            <span class="n">migration_id</span><span class="p">,</span>
            <span class="n">data_migrated</span><span class="p">:</span> <span class="n">data_report</span><span class="py">.rows_migrated</span><span class="p">,</span>
            <span class="n">validation_results</span><span class="p">:</span> <span class="n">validation_report</span><span class="p">,</span>
            <span class="n">duration</span><span class="p">:</span> <span class="k">self</span><span class="py">.progress_tracker</span><span class="nf">.get_duration</span><span class="p">(</span><span class="n">migration_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">,</span>
            <span class="n">success</span><span class="p">:</span> <span class="n">validation_report</span><span class="py">.all_checks_passed</span><span class="p">,</span>
        <span class="p">};</span>
        
        <span class="k">self</span><span class="py">.progress_tracker</span><span class="nf">.complete_migration</span><span class="p">(</span><span class="n">migration_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">migration_report</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">migration_report</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">migrate_data</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">DataMigrationReport</span><span class="p">,</span> <span class="n">MigrationError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">report</span> <span class="o">=</span> <span class="nn">DataMigrationReport</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        
        <span class="c1">// Migrate each data model separately</span>
        <span class="n">report</span><span class="py">.relational</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.migrate_relational_data</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="n">report</span><span class="py">.document</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.migrate_document_data</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="n">report</span><span class="py">.graph</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.migrate_graph_data</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="n">report</span><span class="py">.vector</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.migrate_vector_data</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="n">report</span><span class="py">.timeseries</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.migrate_timeseries_data</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">report</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">migrate_relational_data</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">ModelMigrationReport</span><span class="p">,</span> <span class="n">MigrationError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">tables</span> <span class="o">=</span> <span class="k">self</span><span class="py">.source_backend</span><span class="nf">.list_tables</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">report</span> <span class="o">=</span> <span class="nn">ModelMigrationReport</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        
        <span class="k">for</span> <span class="n">table</span> <span class="k">in</span> <span class="n">tables</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">start_time</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>
            
            <span class="c1">// Stream data from source to target</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">stream</span> <span class="o">=</span> <span class="k">self</span><span class="py">.source_backend</span><span class="nf">.stream_table_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="py">.name</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">batch</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">row_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            
            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.next</span><span class="p">()</span><span class="k">.await</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">row</span> <span class="o">=</span> <span class="n">row</span><span class="o">?</span><span class="p">;</span>
                <span class="n">batch</span><span class="nf">.push</span><span class="p">(</span><span class="n">row</span><span class="p">);</span>
                
                <span class="k">if</span> <span class="n">batch</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.migration_config.batch_size</span> <span class="p">{</span>
                    <span class="k">self</span><span class="py">.tikv_backend</span><span class="nf">.batch_insert_relational</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="py">.name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">batch</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                    <span class="n">row_count</span> <span class="o">+=</span> <span class="n">batch</span><span class="nf">.len</span><span class="p">();</span>
                    <span class="n">batch</span><span class="nf">.clear</span><span class="p">();</span>
                    
                    <span class="c1">// Update progress</span>
                    <span class="k">self</span><span class="py">.progress_tracker</span><span class="nf">.update_progress</span><span class="p">(</span>
                        <span class="nn">MigrationPhase</span><span class="p">::</span><span class="n">Data</span><span class="p">,</span> 
                        <span class="n">row_count</span> <span class="k">as</span> <span class="nb">f64</span> <span class="o">/</span> <span class="n">table</span><span class="py">.estimated_rows</span> <span class="k">as</span> <span class="nb">f64</span>
                    <span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
            <span class="c1">// Insert remaining rows</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">batch</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.tikv_backend</span><span class="nf">.batch_insert_relational</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="py">.name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">batch</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                <span class="n">row_count</span> <span class="o">+=</span> <span class="n">batch</span><span class="nf">.len</span><span class="p">();</span>
            <span class="p">}</span>
            
            <span class="n">report</span><span class="py">.tables_migrated</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">report</span><span class="py">.rows_migrated</span> <span class="o">+=</span> <span class="n">row_count</span><span class="p">;</span>
            <span class="n">report</span><span class="py">.duration</span> <span class="o">+=</span> <span class="n">start_time</span><span class="nf">.elapsed</span><span class="p">();</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">report</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">validate_migration</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">ValidationReport</span><span class="p">,</span> <span class="n">MigrationError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">report</span> <span class="o">=</span> <span class="nn">ValidationReport</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        
        <span class="c1">// Row count validation</span>
        <span class="n">report</span><span class="py">.row_count_check</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.validate_row_counts</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Data integrity validation</span>
        <span class="n">report</span><span class="py">.integrity_check</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.validate_data_integrity</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Performance validation</span>
        <span class="n">report</span><span class="py">.performance_check</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.validate_performance</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Cross-model constraint validation</span>
        <span class="n">report</span><span class="py">.constraint_check</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.validate_cross_model_constraints</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="n">report</span><span class="py">.all_checks_passed</span> <span class="o">=</span> <span class="n">report</span><span class="py">.row_count_check.passed</span> 
            <span class="o">&amp;&amp;</span> <span class="n">report</span><span class="py">.integrity_check.passed</span>
            <span class="o">&amp;&amp;</span> <span class="n">report</span><span class="py">.performance_check.passed</span>
            <span class="o">&amp;&amp;</span> <span class="n">report</span><span class="py">.constraint_check.passed</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">report</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="gradual-rollout-strategy">Gradual Rollout Strategy</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">GradualRolloutManager</span> <span class="p">{</span>
    <span class="n">current_backend</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">StorageBackend</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">tikv_backend</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">TiKVStorageBackend</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">rollout_config</span><span class="p">:</span> <span class="n">RolloutConfig</span><span class="p">,</span>
    <span class="n">traffic_router</span><span class="p">:</span> <span class="n">TrafficRouter</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">GradualRolloutManager</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">start_rollout</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">RolloutId</span><span class="p">,</span> <span class="n">RolloutError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">rollout_id</span> <span class="o">=</span> <span class="nn">RolloutId</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        
        <span class="c1">// Phase 1: Read-only traffic (10%)</span>
        <span class="k">self</span><span class="py">.traffic_router</span><span class="nf">.route_read_traffic</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tikv_backend</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="nf">.monitor_phase</span><span class="p">(</span><span class="n">rollout_id</span><span class="p">,</span> <span class="nn">RolloutPhase</span><span class="p">::</span><span class="n">ReadOnly10</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Phase 2: Read-only traffic (50%)</span>
        <span class="k">self</span><span class="py">.traffic_router</span><span class="nf">.route_read_traffic</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tikv_backend</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="nf">.monitor_phase</span><span class="p">(</span><span class="n">rollout_id</span><span class="p">,</span> <span class="nn">RolloutPhase</span><span class="p">::</span><span class="n">ReadOnly50</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Phase 3: Read-only traffic (100%)</span>
        <span class="k">self</span><span class="py">.traffic_router</span><span class="nf">.route_read_traffic</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tikv_backend</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="nf">.monitor_phase</span><span class="p">(</span><span class="n">rollout_id</span><span class="p">,</span> <span class="nn">RolloutPhase</span><span class="p">::</span><span class="n">ReadOnly100</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Phase 4: Read-write traffic (10%)</span>
        <span class="k">self</span><span class="py">.traffic_router</span><span class="nf">.route_write_traffic</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tikv_backend</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="nf">.monitor_phase</span><span class="p">(</span><span class="n">rollout_id</span><span class="p">,</span> <span class="nn">RolloutPhase</span><span class="p">::</span><span class="n">ReadWrite10</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Phase 5: Read-write traffic (100%)</span>
        <span class="k">self</span><span class="py">.traffic_router</span><span class="nf">.route_write_traffic</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tikv_backend</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">self</span><span class="nf">.monitor_phase</span><span class="p">(</span><span class="n">rollout_id</span><span class="p">,</span> <span class="nn">RolloutPhase</span><span class="p">::</span><span class="n">ReadWrite100</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">rollout_id</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">monitor_phase</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">rollout_id</span><span class="p">:</span> <span class="n">RolloutId</span><span class="p">,</span> <span class="n">phase</span><span class="p">:</span> <span class="n">RolloutPhase</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">RolloutError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">monitoring_duration</span> <span class="o">=</span> <span class="k">self</span><span class="py">.rollout_config.phase_duration</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">start_time</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>
        
        <span class="k">while</span> <span class="n">start_time</span><span class="nf">.elapsed</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">monitoring_duration</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">health_check</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.perform_health_check</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            
            <span class="k">if</span> <span class="o">!</span><span class="n">health_check</span><span class="nf">.is_healthy</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// Rollback on issues</span>
                <span class="k">self</span><span class="nf">.rollback_phase</span><span class="p">(</span><span class="n">rollout_id</span><span class="p">,</span> <span class="n">phase</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">RolloutError</span><span class="p">::</span><span class="nf">HealthCheckFailed</span><span class="p">(</span><span class="n">health_check</span><span class="p">));</span>
            <span class="p">}</span>
            
            <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">rollback_phase</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">rollout_id</span><span class="p">:</span> <span class="n">RolloutId</span><span class="p">,</span> <span class="n">phase</span><span class="p">:</span> <span class="n">RolloutPhase</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">RolloutError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">phase</span> <span class="p">{</span>
            <span class="nn">RolloutPhase</span><span class="p">::</span><span class="n">ReadOnly10</span> <span class="p">|</span> <span class="nn">RolloutPhase</span><span class="p">::</span><span class="n">ReadOnly50</span> <span class="p">|</span> <span class="nn">RolloutPhase</span><span class="p">::</span><span class="n">ReadOnly100</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.traffic_router</span><span class="nf">.route_read_traffic</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tikv_backend</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="nn">RolloutPhase</span><span class="p">::</span><span class="n">ReadWrite10</span> <span class="p">|</span> <span class="nn">RolloutPhase</span><span class="p">::</span><span class="n">ReadWrite100</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.traffic_router</span><span class="nf">.route_write_traffic</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tikv_backend</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                <span class="k">self</span><span class="py">.traffic_router</span><span class="nf">.route_read_traffic</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tikv_backend</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="p">},</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="testing-and-validation">Testing and Validation</h2>

<h3 id="integration-test-suite">Integration Test Suite</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tikv_integration_tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">testcontainers</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
    
    <span class="k">struct</span> <span class="n">TiKVTestCluster</span> <span class="p">{</span>
        <span class="n">pd_container</span><span class="p">:</span> <span class="n">Container</span><span class="o">&lt;</span><span class="nn">clients</span><span class="p">::</span><span class="n">Cli</span><span class="p">,</span> <span class="nn">images</span><span class="p">::</span><span class="nn">generic</span><span class="p">::</span><span class="n">GenericImage</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">tikv_containers</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&lt;</span><span class="nn">clients</span><span class="p">::</span><span class="n">Cli</span><span class="p">,</span> <span class="nn">images</span><span class="p">::</span><span class="nn">generic</span><span class="p">::</span><span class="n">GenericImage</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">client</span><span class="p">:</span> <span class="n">TiKVClient</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="k">impl</span> <span class="n">TiKVTestCluster</span> <span class="p">{</span>
        <span class="k">async</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="n">TestError</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">docker</span> <span class="o">=</span> <span class="nn">clients</span><span class="p">::</span><span class="nn">Cli</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
            
            <span class="c1">// Start PD node</span>
            <span class="k">let</span> <span class="n">pd_container</span> <span class="o">=</span> <span class="n">docker</span><span class="nf">.run</span><span class="p">(</span>
                <span class="nn">images</span><span class="p">::</span><span class="nn">generic</span><span class="p">::</span><span class="nn">GenericImage</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"pingcap/pd"</span><span class="p">,</span> <span class="s">"latest"</span><span class="p">)</span>
                    <span class="nf">.with_exposed_port</span><span class="p">(</span><span class="mi">2379</span><span class="p">)</span>
                    <span class="nf">.with_exposed_port</span><span class="p">(</span><span class="mi">2380</span><span class="p">)</span>
            <span class="p">);</span>
            
            <span class="k">let</span> <span class="n">pd_endpoint</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"127.0.0.1:{}"</span><span class="p">,</span> <span class="n">pd_container</span><span class="nf">.get_host_port</span><span class="p">(</span><span class="mi">2379</span><span class="p">));</span>
            
            <span class="c1">// Start TiKV nodes</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">tikv_containers</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">3</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">tikv_container</span> <span class="o">=</span> <span class="n">docker</span><span class="nf">.run</span><span class="p">(</span>
                    <span class="nn">images</span><span class="p">::</span><span class="nn">generic</span><span class="p">::</span><span class="nn">GenericImage</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"pingcap/tikv"</span><span class="p">,</span> <span class="s">"latest"</span><span class="p">)</span>
                        <span class="nf">.with_exposed_port</span><span class="p">(</span><span class="mi">20160</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
                        <span class="nf">.with_env_var</span><span class="p">(</span><span class="s">"PD_ENDPOINTS"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pd_endpoint</span><span class="p">)</span>
                <span class="p">);</span>
                <span class="n">tikv_containers</span><span class="nf">.push</span><span class="p">(</span><span class="n">tikv_container</span><span class="p">);</span>
            <span class="p">}</span>
            
            <span class="c1">// Wait for cluster to be ready</span>
            <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
            
            <span class="c1">// Create client</span>
            <span class="k">let</span> <span class="n">client</span> <span class="o">=</span> <span class="nn">TiKVClient</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="n">pd_endpoint</span><span class="p">])</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            
            <span class="nf">Ok</span><span class="p">(</span><span class="n">TiKVTestCluster</span> <span class="p">{</span>
                <span class="n">pd_container</span><span class="p">,</span>
                <span class="n">tikv_containers</span><span class="p">,</span>
                <span class="n">client</span><span class="p">,</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="nd">#[tokio::test]</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">test_basic_operations</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TestError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cluster</span> <span class="o">=</span> <span class="nn">TiKVTestCluster</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">TiKVStorageBackend</span><span class="p">::</span><span class="nf">new_with_client</span><span class="p">(</span><span class="n">cluster</span><span class="py">.client</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Test basic put/get</span>
        <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">b"test_key"</span><span class="nf">.to_vec</span><span class="p">()</span><span class="nf">.into</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="s">b"test_value"</span><span class="nf">.to_vec</span><span class="p">();</span>
        
        <span class="n">backend</span><span class="nf">.put</span><span class="p">(</span><span class="n">key</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">value</span><span class="nf">.clone</span><span class="p">())</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">retrieved</span> <span class="o">=</span> <span class="n">backend</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">retrieved</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="nd">#[tokio::test]</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">test_multi_model_storage</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TestError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cluster</span> <span class="o">=</span> <span class="nn">TiKVTestCluster</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">TiKVStorageBackend</span><span class="p">::</span><span class="nf">new_with_client</span><span class="p">(</span><span class="n">cluster</span><span class="py">.client</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Test relational data</span>
        <span class="k">let</span> <span class="n">table_data</span> <span class="o">=</span> <span class="n">RelationalRecord</span> <span class="p">{</span>
            <span class="n">table_name</span><span class="p">:</span> <span class="s">"users"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">row_id</span><span class="p">:</span> <span class="s">"123"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">columns</span><span class="p">:</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">cols</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
                <span class="n">cols</span><span class="nf">.insert</span><span class="p">(</span><span class="s">"name"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="nn">ColumnValue</span><span class="p">::</span><span class="nf">String</span><span class="p">(</span><span class="s">"John"</span><span class="nf">.to_string</span><span class="p">()));</span>
                <span class="n">cols</span><span class="nf">.insert</span><span class="p">(</span><span class="s">"age"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="nn">ColumnValue</span><span class="p">::</span><span class="nf">Int64</span><span class="p">(</span><span class="mi">30</span><span class="p">));</span>
                <span class="n">cols</span>
            <span class="p">},</span>
            <span class="n">schema_hash</span><span class="p">:</span> <span class="mi">12345</span><span class="p">,</span>
        <span class="p">};</span>
        
        <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="nn">MultiModelKeyBuilder</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span><span class="nf">.table_row_key</span><span class="p">(</span><span class="s">"users"</span><span class="p">,</span> <span class="s">"123"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">stored_record</span> <span class="o">=</span> <span class="n">StoredRecord</span> <span class="p">{</span>
            <span class="n">model_type</span><span class="p">:</span> <span class="nn">DataModel</span><span class="p">::</span><span class="n">Relational</span><span class="p">,</span>
            <span class="n">schema_version</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="nn">bincode</span><span class="p">::</span><span class="nf">serialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table_data</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">:</span> <span class="n">RecordMetadata</span> <span class="p">{</span>
                <span class="n">actor_id</span><span class="p">:</span> <span class="nn">ActorId</span><span class="p">::</span><span class="nf">from_table_row</span><span class="p">(</span><span class="s">"users"</span><span class="p">,</span> <span class="s">"123"</span><span class="p">),</span>
                <span class="n">transaction_id</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
                <span class="n">version</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">checksum</span><span class="p">:</span> <span class="nf">calculate_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table_data</span><span class="p">),</span>
                <span class="n">compression</span><span class="p">:</span> <span class="nn">CompressionType</span><span class="p">::</span><span class="nb">None</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">created_at</span><span class="p">:</span> <span class="nn">chrono</span><span class="p">::</span><span class="nn">Utc</span><span class="p">::</span><span class="nf">now</span><span class="p">()</span><span class="nf">.timestamp</span><span class="p">(),</span>
            <span class="n">updated_at</span><span class="p">:</span> <span class="nn">chrono</span><span class="p">::</span><span class="nn">Utc</span><span class="p">::</span><span class="nf">now</span><span class="p">()</span><span class="nf">.timestamp</span><span class="p">(),</span>
        <span class="p">};</span>
        
        <span class="n">backend</span><span class="nf">.put</span><span class="p">(</span><span class="n">key</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nn">bincode</span><span class="p">::</span><span class="nf">serialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stored_record</span><span class="p">)</span><span class="o">?</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="k">let</span> <span class="n">retrieved</span> <span class="o">=</span> <span class="n">backend</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">retrieved</span><span class="nf">.is_some</span><span class="p">());</span>
        
        <span class="k">let</span> <span class="n">decoded</span><span class="p">:</span> <span class="n">StoredRecord</span> <span class="o">=</span> <span class="nn">bincode</span><span class="p">::</span><span class="nf">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retrieved</span><span class="nf">.unwrap</span><span class="p">())</span><span class="o">?</span><span class="p">;</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">decoded</span><span class="py">.model_type</span><span class="p">,</span> <span class="nn">DataModel</span><span class="p">::</span><span class="n">Relational</span><span class="p">);</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="nd">#[tokio::test]</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">test_cross_model_transaction</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TestError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cluster</span> <span class="o">=</span> <span class="nn">TiKVTestCluster</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">TiKVStorageBackend</span><span class="p">::</span><span class="nf">new_with_client</span><span class="p">(</span><span class="n">cluster</span><span class="py">.client</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="k">let</span> <span class="k">mut</span> <span class="n">txn</span> <span class="o">=</span> <span class="nn">OrbitTransaction</span><span class="p">::</span><span class="nf">begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cluster</span><span class="py">.client</span><span class="p">,</span> <span class="nn">IsolationLevel</span><span class="p">::</span><span class="n">ReadCommitted</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Insert relational data</span>
        <span class="k">let</span> <span class="n">user_data</span> <span class="o">=</span> <span class="n">RelationalRecord</span> <span class="p">{</span>
            <span class="n">table_name</span><span class="p">:</span> <span class="s">"users"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">row_id</span><span class="p">:</span> <span class="s">"456"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">columns</span><span class="p">:</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">cols</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
                <span class="n">cols</span><span class="nf">.insert</span><span class="p">(</span><span class="s">"name"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="nn">ColumnValue</span><span class="p">::</span><span class="nf">String</span><span class="p">(</span><span class="s">"Jane"</span><span class="nf">.to_string</span><span class="p">()));</span>
                <span class="n">cols</span><span class="nf">.insert</span><span class="p">(</span><span class="s">"age"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="nn">ColumnValue</span><span class="p">::</span><span class="nf">Int64</span><span class="p">(</span><span class="mi">25</span><span class="p">));</span>
                <span class="n">cols</span>
            <span class="p">},</span>
            <span class="n">schema_hash</span><span class="p">:</span> <span class="mi">12345</span><span class="p">,</span>
        <span class="p">};</span>
        
        <span class="n">txn</span><span class="nf">.put_relational</span><span class="p">(</span><span class="s">"users"</span><span class="p">,</span> <span class="s">"456"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user_data</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Insert vector data for the same user</span>
        <span class="k">let</span> <span class="n">vector_data</span> <span class="o">=</span> <span class="n">VectorRecord</span> <span class="p">{</span>
            <span class="n">collection</span><span class="p">:</span> <span class="s">"user_embeddings"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">vector_id</span><span class="p">:</span> <span class="s">"456"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">dimensions</span><span class="p">:</span> <span class="mi">128</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="mf">0.1</span><span class="p">;</span> <span class="mi">128</span><span class="p">],</span>
            <span class="n">metadata</span><span class="p">:</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nd">json!</span><span class="p">({</span><span class="s">"user_id"</span><span class="p">:</span> <span class="s">"456"</span><span class="p">,</span> <span class="s">"model"</span><span class="p">:</span> <span class="s">"text-embedding-ada-002"</span><span class="p">}),</span>
            <span class="n">index_hints</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[],</span>
        <span class="p">};</span>
        
        <span class="n">txn</span><span class="nf">.put_vector</span><span class="p">(</span><span class="s">"user_embeddings"</span><span class="p">,</span> <span class="s">"456"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vector_data</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Create graph relationship</span>
        <span class="n">txn</span><span class="nf">.create_graph_edge</span><span class="p">(</span>
            <span class="s">"social_network"</span><span class="p">,</span>
            <span class="s">"456"</span><span class="p">,</span>
            <span class="s">"follows"</span><span class="p">,</span>
            <span class="s">"123"</span><span class="p">,</span>
            <span class="nn">serde_json</span><span class="p">::</span><span class="nd">json!</span><span class="p">({</span><span class="s">"created_at"</span><span class="p">:</span> <span class="nn">chrono</span><span class="p">::</span><span class="nn">Utc</span><span class="p">::</span><span class="nf">now</span><span class="p">()</span><span class="nf">.timestamp</span><span class="p">()})</span>
        <span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Commit transaction</span>
        <span class="n">txn</span><span class="nf">.commit</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Verify all data is present</span>
        <span class="k">let</span> <span class="n">user_key</span> <span class="o">=</span> <span class="nn">MultiModelKeyBuilder</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span><span class="nf">.table_row_key</span><span class="p">(</span><span class="s">"users"</span><span class="p">,</span> <span class="s">"456"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">vector_key</span> <span class="o">=</span> <span class="nn">MultiModelKeyBuilder</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span><span class="nf">.vector_key</span><span class="p">(</span><span class="s">"user_embeddings"</span><span class="p">,</span> <span class="s">"456"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">edge_key</span> <span class="o">=</span> <span class="nn">MultiModelKeyBuilder</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span><span class="nf">.edge_key</span><span class="p">(</span><span class="s">"social_network"</span><span class="p">,</span> <span class="s">"456"</span><span class="p">,</span> <span class="s">"follows"</span><span class="p">,</span> <span class="s">"123"</span><span class="p">);</span>
        
        <span class="k">let</span> <span class="n">user_exists</span> <span class="o">=</span> <span class="n">backend</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_key</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="nf">.is_some</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">vector_exists</span> <span class="o">=</span> <span class="n">backend</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_key</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="nf">.is_some</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">edge_exists</span> <span class="o">=</span> <span class="n">backend</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edge_key</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="nf">.is_some</span><span class="p">();</span>
        
        <span class="nd">assert!</span><span class="p">(</span><span class="n">user_exists</span> <span class="o">&amp;&amp;</span> <span class="n">vector_exists</span> <span class="o">&amp;&amp;</span> <span class="n">edge_exists</span><span class="p">);</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="nd">#[tokio::test]</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">test_actor_region_mapping</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TestError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cluster</span> <span class="o">=</span> <span class="nn">TiKVTestCluster</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">TiKVStorageBackend</span><span class="p">::</span><span class="nf">new_with_client</span><span class="p">(</span><span class="n">cluster</span><span class="py">.client</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="k">let</span> <span class="n">region_manager</span> <span class="o">=</span> <span class="nn">RegionManager</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cluster</span><span class="py">.client</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">mapper</span> <span class="o">=</span> <span class="nn">ActorRegionMapper</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">region_manager</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Test consistent mapping</span>
        <span class="k">let</span> <span class="n">actor_id</span> <span class="o">=</span> <span class="nn">ActorId</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"test_actor_123"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">region1</span> <span class="o">=</span> <span class="n">mapper</span><span class="nf">.get_region</span><span class="p">(</span><span class="n">actor_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">region2</span> <span class="o">=</span> <span class="n">mapper</span><span class="nf">.get_region</span><span class="p">(</span><span class="n">actor_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">region1</span><span class="p">,</span> <span class="n">region2</span><span class="p">,</span> <span class="s">"Actor should always map to the same region"</span><span class="p">);</span>
        
        <span class="c1">// Test different actors map to different regions (with high probability)</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">region_distribution</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">100</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">actor_id</span> <span class="o">=</span> <span class="nn">ActorId</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"test_actor_{}"</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
            <span class="k">let</span> <span class="n">region</span> <span class="o">=</span> <span class="n">mapper</span><span class="nf">.get_region</span><span class="p">(</span><span class="n">actor_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="o">*</span><span class="n">region_distribution</span><span class="nf">.entry</span><span class="p">(</span><span class="n">region</span><span class="p">)</span><span class="nf">.or_insert</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="nd">assert!</span><span class="p">(</span><span class="n">region_distribution</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"Actors should distribute across multiple regions"</span><span class="p">);</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="nd">#[tokio::test]</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">test_performance_benchmarks</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">TestError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cluster</span> <span class="o">=</span> <span class="nn">TiKVTestCluster</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">TiKVStorageBackend</span><span class="p">::</span><span class="nf">new_with_client</span><span class="p">(</span><span class="n">cluster</span><span class="py">.client</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="k">const</span> <span class="n">NUM_OPERATIONS</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
        
        <span class="c1">// Benchmark writes</span>
        <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">NUM_OPERATIONS</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"benchmark_key_{}"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="nf">.into_bytes</span><span class="p">()</span><span class="nf">.into</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"benchmark_value_{}"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="nf">.into_bytes</span><span class="p">();</span>
            <span class="n">backend</span><span class="nf">.put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">write_duration</span> <span class="o">=</span> <span class="n">start</span><span class="nf">.elapsed</span><span class="p">();</span>
        
        <span class="c1">// Benchmark reads</span>
        <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">NUM_OPERATIONS</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"benchmark_key_{}"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="nf">.into_bytes</span><span class="p">()</span><span class="nf">.into</span><span class="p">();</span>
            <span class="n">backend</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">read_duration</span> <span class="o">=</span> <span class="n">start</span><span class="nf">.elapsed</span><span class="p">();</span>
        
        <span class="k">let</span> <span class="n">writes_per_second</span> <span class="o">=</span> <span class="n">NUM_OPERATIONS</span> <span class="k">as</span> <span class="nb">f64</span> <span class="o">/</span> <span class="n">write_duration</span><span class="nf">.as_secs_f64</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">reads_per_second</span> <span class="o">=</span> <span class="n">NUM_OPERATIONS</span> <span class="k">as</span> <span class="nb">f64</span> <span class="o">/</span> <span class="n">read_duration</span><span class="nf">.as_secs_f64</span><span class="p">();</span>
        
        <span class="nd">println!</span><span class="p">(</span><span class="s">"TiKV Backend Performance:"</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  Writes/second: {:.2}"</span><span class="p">,</span> <span class="n">writes_per_second</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  Reads/second: {:.2}"</span><span class="p">,</span> <span class="n">reads_per_second</span><span class="p">);</span>
        
        <span class="c1">// Assert minimum performance requirements</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">writes_per_second</span> <span class="o">&gt;</span> <span class="mf">100.0</span><span class="p">,</span> <span class="s">"Write performance below minimum threshold"</span><span class="p">);</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">reads_per_second</span> <span class="o">&gt;</span> <span class="mf">500.0</span><span class="p">,</span> <span class="s">"Read performance below minimum threshold"</span><span class="p">);</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="load-testing-framework">Load Testing Framework</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">TiKVLoadTestFramework</span> <span class="p">{</span>
    <span class="n">backend</span><span class="p">:</span> <span class="n">TiKVStorageBackend</span><span class="p">,</span>
    <span class="n">test_config</span><span class="p">:</span> <span class="n">LoadTestConfig</span><span class="p">,</span>
    <span class="n">metrics_collector</span><span class="p">:</span> <span class="n">MetricsCollector</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TiKVLoadTestFramework</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">run_load_test</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">test_name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">LoadTestReport</span><span class="p">,</span> <span class="n">LoadTestError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Starting load test: {}"</span><span class="p">,</span> <span class="n">test_name</span><span class="p">);</span>
        
        <span class="k">let</span> <span class="n">start_time</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">test_report</span> <span class="o">=</span> <span class="nn">LoadTestReport</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">test_name</span><span class="p">);</span>
        
        <span class="c1">// Spawn concurrent workers</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">handles</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">worker_id</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="k">self</span><span class="py">.test_config.worker_count</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="k">self</span><span class="py">.backend</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">config</span> <span class="o">=</span> <span class="k">self</span><span class="py">.test_config</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">collector</span> <span class="o">=</span> <span class="k">self</span><span class="py">.metrics_collector</span><span class="nf">.clone</span><span class="p">();</span>
            
            <span class="k">let</span> <span class="n">handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">run_worker</span><span class="p">(</span><span class="n">worker_id</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">collector</span><span class="p">)</span><span class="k">.await</span>
            <span class="p">});</span>
            <span class="n">handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="c1">// Wait for all workers to complete</span>
        <span class="k">let</span> <span class="n">worker_results</span> <span class="o">=</span> <span class="nn">futures</span><span class="p">::</span><span class="nn">future</span><span class="p">::</span><span class="nf">join_all</span><span class="p">(</span><span class="n">handles</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
        
        <span class="c1">// Aggregate results</span>
        <span class="k">for</span> <span class="n">result</span> <span class="k">in</span> <span class="n">worker_results</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">worker_report</span> <span class="o">=</span> <span class="n">result</span><span class="o">??</span><span class="p">;</span>
            <span class="n">test_report</span><span class="nf">.aggregate</span><span class="p">(</span><span class="n">worker_report</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="n">test_report</span><span class="py">.duration</span> <span class="o">=</span> <span class="n">start_time</span><span class="nf">.elapsed</span><span class="p">();</span>
        <span class="n">test_report</span><span class="nf">.calculate_statistics</span><span class="p">();</span>
        
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Load test completed: {}"</span><span class="p">,</span> <span class="n">test_name</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  Duration: {:?}"</span><span class="p">,</span> <span class="n">test_report</span><span class="py">.duration</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  Operations: {}"</span><span class="p">,</span> <span class="n">test_report</span><span class="py">.total_operations</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  Throughput: {:.2} ops/sec"</span><span class="p">,</span> <span class="n">test_report</span><span class="py">.throughput</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  Average Latency: {:?}"</span><span class="p">,</span> <span class="n">test_report</span><span class="py">.avg_latency</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  P99 Latency: {:?}"</span><span class="p">,</span> <span class="n">test_report</span><span class="py">.p99_latency</span><span class="p">);</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">test_report</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">run_worker</span><span class="p">(</span>
        <span class="n">worker_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="n">TiKVStorageBackend</span><span class="p">,</span>
        <span class="n">config</span><span class="p">:</span> <span class="n">LoadTestConfig</span><span class="p">,</span>
        <span class="n">collector</span><span class="p">:</span> <span class="n">MetricsCollector</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">WorkerReport</span><span class="p">,</span> <span class="n">LoadTestError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">report</span> <span class="o">=</span> <span class="nn">WorkerReport</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">worker_id</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">operations_per_worker</span> <span class="o">=</span> <span class="n">config</span><span class="py">.total_operations</span> <span class="o">/</span> <span class="n">config</span><span class="py">.worker_count</span><span class="p">;</span>
        
        <span class="k">for</span> <span class="n">op_id</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">operations_per_worker</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">operation_start</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>
            
            <span class="k">match</span> <span class="n">config</span><span class="py">.workload_pattern</span> <span class="p">{</span>
                <span class="nn">WorkloadPattern</span><span class="p">::</span><span class="n">WriteHeavy</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">op_id</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="p">{</span>  <span class="c1">// 80% writes</span>
                        <span class="k">Self</span><span class="p">::</span><span class="nf">perform_write_operation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">backend</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">op_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">Self</span><span class="p">::</span><span class="nf">perform_read_operation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">backend</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">op_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">},</span>
                <span class="nn">WorkloadPattern</span><span class="p">::</span><span class="n">ReadHeavy</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">op_id</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">{</span>  <span class="c1">// 20% writes</span>
                        <span class="k">Self</span><span class="p">::</span><span class="nf">perform_write_operation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">backend</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">op_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">Self</span><span class="p">::</span><span class="nf">perform_read_operation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">backend</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">op_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">},</span>
                <span class="nn">WorkloadPattern</span><span class="p">::</span><span class="n">Mixed</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">op_id</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>  <span class="c1">// 50% writes</span>
                        <span class="k">Self</span><span class="p">::</span><span class="nf">perform_write_operation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">backend</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">op_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">Self</span><span class="p">::</span><span class="nf">perform_read_operation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">backend</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">,</span> <span class="n">op_id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">},</span>
            <span class="p">}</span>
            
            <span class="k">let</span> <span class="n">operation_duration</span> <span class="o">=</span> <span class="n">operation_start</span><span class="nf">.elapsed</span><span class="p">();</span>
            <span class="n">report</span><span class="nf">.record_operation</span><span class="p">(</span><span class="n">operation_duration</span><span class="p">);</span>
            
            <span class="n">collector</span><span class="nf">.record_operation_latency</span><span class="p">(</span><span class="n">operation_duration</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">report</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This comprehensive TiKV integration specification provides a solid foundation for implementing TiKV as the persistence layer for Orbit-RS. The combination of TiKV’s distributed ACID transactions with Orbit-RS’s multi-model capabilities creates a powerful and scalable database platform.</p>

<p>The implementation roadmap spans 15 months with clear milestones and success criteria. The integration leverages both systems’ strengths while maintaining Orbit-RS’s unique multi-model, multi-protocol, and actor-native advantages.</p>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/orbit-rs/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Orbit-RS Documentation</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">TuringWorks</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>The Next-Generation Distributed Database System - Production-Ready Multi-Model Platform</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>