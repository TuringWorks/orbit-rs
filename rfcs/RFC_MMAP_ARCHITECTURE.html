<h1 id="rfc-memory-mapped-file-architecture-for-orbit-rs">RFC: Memory-Mapped File Architecture for Orbit-RS</h1>

<p><strong>RFC ID</strong>: RFC-2024-001<br />
<strong>Title</strong>: Memory-Mapped File Persistence Architecture<br />
<strong>Author</strong>: Orbit-RS Team<br />
<strong>Status</strong>: Draft<br />
<strong>Created</strong>: 2025-01-08<br />
<strong>Updated</strong>: 2025-01-08</p>

<h2 id="abstract">Abstract</h2>

<p>This RFC proposes implementing a memory-mapped file (mmap) based persistence architecture for Orbit-RS to dramatically reduce memory requirements and infrastructure costs while maintaining high performance. The proposed architecture enables handling petabyte-scale data with 50-75% fewer resources compared to traditional approaches.</p>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#motivation">Motivation</a></li>
  <li><a href="#design-overview">Design Overview</a></li>
  <li><a href="#technical-specification">Technical Specification</a></li>
  <li><a href="#implementation-plan">Implementation Plan</a></li>
  <li><a href="#deployment-strategies">Deployment Strategies</a></li>
  <li><a href="#performance-analysis">Performance Analysis</a></li>
  <li><a href="#security-considerations">Security Considerations</a></li>
  <li><a href="#testing-strategy">Testing Strategy</a></li>
  <li><a href="#migration-path">Migration Path</a></li>
  <li><a href="#open-questions">Open Questions</a></li>
</ul>

<h2 id="motivation">Motivation</h2>

<h3 id="current-limitations">Current Limitations</h3>

<p>The existing persistence architecture in orbit-rs has several limitations for large-scale deployments:</p>

<ol>
  <li><strong>High Memory Requirements</strong>: Traditional approaches require 32-128GB RAM per node</li>
  <li><strong>Node Count</strong>: Need 100-200 nodes for petabyte-scale data</li>
  <li><strong>Cost</strong>: Infrastructure costs of ~$100K/month for 1PB deployments</li>
  <li><strong>Complexity</strong>: Manual cache management and data tiering</li>
</ol>

<h3 id="proposed-benefits">Proposed Benefits</h3>

<p>Memory-mapped files offer significant advantages:</p>

<ol>
  <li><strong>Reduced Infrastructure</strong>: 30-50 nodes instead of 100-200 (3x reduction)</li>
  <li><strong>Lower Memory</strong>: 16-48GB RAM per node (50-75% reduction)</li>
  <li><strong>Cost Savings</strong>: ~$27K/month savings vs traditional approach</li>
  <li><strong>Automatic Tiering</strong>: OS handles hot/cold data management</li>
  <li><strong>Near-RAM Performance</strong>: Modern NVMe provides &lt;10μs latency</li>
</ol>

<h2 id="design-overview">Design Overview</h2>

<h3 id="architecture-components">Architecture Components</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">┌─────────────────────────────────────────────────────────────┐</span>
<span class="err">│</span>                    <span class="n">Application</span> <span class="n">Layer</span>                        <span class="err">│</span>
<span class="err">├─────────────────────────────────────────────────────────────┤</span>
<span class="err">│</span>           <span class="n">Orbit</span><span class="o">-</span><span class="n">RS</span> <span class="n">Actor</span> <span class="n">System</span> <span class="o">&amp;</span> <span class="n">Virtual</span> <span class="n">Actors</span>           <span class="err">│</span>
<span class="err">├─────────────────────────────────────────────────────────────┤</span>
<span class="err">│</span>              <span class="n">Memory</span><span class="o">-</span><span class="n">Mapped</span> <span class="n">Persistence</span> <span class="n">Layer</span>               <span class="err">│</span>
<span class="err">│</span>  <span class="err">┌─────────────┐</span>  <span class="err">┌─────────────┐</span>  <span class="err">┌─────────────────────┐</span>  <span class="err">│</span>
<span class="err">│</span>  <span class="err">│</span> <span class="n">MMap</span>        <span class="err">│</span>  <span class="err">│</span> <span class="n">Page</span>        <span class="err">│</span>  <span class="err">│</span> <span class="n">NUMA</span> <span class="o">&amp;</span> <span class="n">THP</span>          <span class="err">│</span>  <span class="err">│</span>
<span class="err">│</span>  <span class="err">│</span> <span class="n">Provider</span>    <span class="err">│</span>  <span class="err">│</span> <span class="n">Manager</span>     <span class="err">│</span>  <span class="err">│</span> <span class="n">Optimization</span>        <span class="err">│</span>  <span class="err">│</span>
<span class="err">│</span>  <span class="err">└─────────────┘</span>  <span class="err">└─────────────┘</span>  <span class="err">└─────────────────────┘</span>  <span class="err">│</span>
<span class="err">├─────────────────────────────────────────────────────────────┤</span>
<span class="err">│</span>                  <span class="n">Operating</span> <span class="n">System</span>                           <span class="err">│</span>
<span class="err">│</span>  <span class="err">┌─────────────┐</span>  <span class="err">┌─────────────┐</span>  <span class="err">┌─────────────────────┐</span>  <span class="err">│</span>
<span class="err">│</span>  <span class="err">│</span> <span class="n">Virtual</span>     <span class="err">│</span>  <span class="err">│</span> <span class="n">Page</span>        <span class="err">│</span>  <span class="err">│</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">Subsystem</span>       <span class="err">│</span>  <span class="err">│</span>
<span class="err">│</span>  <span class="err">│</span> <span class="n">Memory</span>      <span class="err">│</span>  <span class="err">│</span> <span class="n">Cache</span>       <span class="err">│</span>  <span class="err">│</span> <span class="p">(</span><span class="n">io_uring</span><span class="p">)</span>          <span class="err">│</span>  <span class="err">│</span>
<span class="err">│</span>  <span class="err">└─────────────┘</span>  <span class="err">└─────────────┘</span>  <span class="err">└─────────────────────┘</span>  <span class="err">│</span>
<span class="err">├─────────────────────────────────────────────────────────────┤</span>
<span class="err">│</span>                    <span class="n">Storage</span> <span class="n">Layer</span>                            <span class="err">│</span>
<span class="err">│</span>          <span class="n">High</span><span class="o">-</span><span class="n">Performance</span> <span class="n">NVMe</span> <span class="nf">SSDs</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">10</span><span class="n">TB</span> <span class="n">per</span> <span class="n">node</span><span class="p">)</span>       <span class="err">│</span>
<span class="err">└─────────────────────────────────────────────────────────────┘</span>
</code></pre></div></div>

<h3 id="key-design-principles">Key Design Principles</h3>

<ol>
  <li><strong>Zero-Copy Operations</strong>: Direct memory access to storage</li>
  <li><strong>OS Integration</strong>: Leverage kernel page cache and virtual memory</li>
  <li><strong>NUMA Awareness</strong>: Optimize for multi-socket server architectures</li>
  <li><strong>Huge Page Support</strong>: Use 2MB/1GB pages for better TLB efficiency</li>
  <li><strong>Configurable</strong>: Support various workload patterns and deployment types</li>
</ol>

<h2 id="technical-specification">Technical Specification</h2>

<h3 id="core-components">Core Components</h3>

<h4 id="1-mmap-persistence-provider">1. MMap Persistence Provider</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Primary memory-mapped file persistence provider</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">MMapPersistenceProvider</span> <span class="p">{</span>
    <span class="cd">/// Configuration for the mmap provider</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">MMapConfig</span><span class="p">,</span>
    <span class="cd">/// Memory-mapped regions for different data types</span>
    <span class="n">regions</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">DataType</span><span class="p">,</span> <span class="n">MMapRegion</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// Page access tracking for optimization</span>
    <span class="n">page_tracker</span><span class="p">:</span> <span class="n">PageAccessTracker</span><span class="p">,</span>
    <span class="cd">/// NUMA topology information</span>
    <span class="n">numa_topology</span><span class="p">:</span> <span class="n">NumaTopology</span><span class="p">,</span>
    <span class="cd">/// I/O ring for async operations</span>
    <span class="n">io_ring</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">IoUring</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// Performance metrics</span>
    <span class="n">metrics</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">RwLock</span><span class="o">&lt;</span><span class="n">MMapMetrics</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/// Configuration for memory-mapped file provider</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">MMapConfig</span> <span class="p">{</span>
    <span class="cd">/// Base directory for memory-mapped files</span>
    <span class="k">pub</span> <span class="n">data_dir</span><span class="p">:</span> <span class="n">PathBuf</span><span class="p">,</span>
    <span class="cd">/// Size of each memory-mapped file in GB</span>
    <span class="k">pub</span> <span class="n">file_size_gb</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="cd">/// Maximum total mapped size per node in GB</span>
    <span class="k">pub</span> <span class="n">max_mapped_size_gb</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="cd">/// Enable transparent huge pages</span>
    <span class="k">pub</span> <span class="n">enable_huge_pages</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="cd">/// Huge page size (2MB or 1GB)</span>
    <span class="k">pub</span> <span class="n">huge_page_size</span><span class="p">:</span> <span class="n">HugePageSize</span><span class="p">,</span>
    <span class="cd">/// Prefault pages on mapping</span>
    <span class="k">pub</span> <span class="n">prefault_pages</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="cd">/// Memory advice for access patterns</span>
    <span class="k">pub</span> <span class="n">memory_advice</span><span class="p">:</span> <span class="n">MemoryAdvice</span><span class="p">,</span>
    <span class="cd">/// NUMA policy for memory allocation</span>
    <span class="k">pub</span> <span class="n">numa_policy</span><span class="p">:</span> <span class="n">NumaPolicy</span><span class="p">,</span>
    <span class="cd">/// Enable io_uring for async I/O</span>
    <span class="k">pub</span> <span class="n">enable_io_uring</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="cd">/// I/O queue depth for io_uring</span>
    <span class="k">pub</span> <span class="n">io_queue_depth</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="cd">/// Sync mode for durability</span>
    <span class="k">pub</span> <span class="n">sync_mode</span><span class="p">:</span> <span class="n">SyncMode</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="2-memory-mapped-region-management">2. Memory-Mapped Region Management</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Represents a memory-mapped file region</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">MMapRegion</span> <span class="p">{</span>
    <span class="cd">/// File descriptor</span>
    <span class="n">file</span><span class="p">:</span> <span class="n">File</span><span class="p">,</span>
    <span class="cd">/// Memory mapping</span>
    <span class="n">mmap</span><span class="p">:</span> <span class="n">MmapMut</span><span class="p">,</span>
    <span class="cd">/// Region size in bytes</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="cd">/// Base address of the mapping</span>
    <span class="n">base_addr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="cd">/// NUMA node where this region is allocated</span>
    <span class="n">numa_node</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// Access pattern statistics</span>
    <span class="n">access_stats</span><span class="p">:</span> <span class="n">AccessStats</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">MMapRegion</span> <span class="p">{</span>
    <span class="cd">/// Create a new memory-mapped region</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span>
        <span class="n">path</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Path</span><span class="p">,</span> 
        <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> 
        <span class="n">config</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">MMapConfig</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">OrbitResult</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">create_file</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">mmap</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">create_mapping</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
            <span class="n">file</span><span class="p">,</span>
            <span class="n">mmap</span><span class="p">,</span>
            <span class="n">size</span><span class="p">,</span>
            <span class="n">base_addr</span><span class="p">:</span> <span class="n">mmap</span><span class="nf">.as_mut_ptr</span><span class="p">(),</span>
            <span class="n">numa_node</span><span class="p">:</span> <span class="k">Self</span><span class="p">::</span><span class="nf">detect_numa_node</span><span class="p">(),</span>
            <span class="n">access_stats</span><span class="p">:</span> <span class="nn">AccessStats</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="cd">/// Perform zero-copy read</span>
    <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">read_at</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">OrbitResult</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> 
    <span class="k">where</span> 
        <span class="n">T</span><span class="p">:</span> <span class="nb">Copy</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="o">+</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">self</span><span class="py">.size</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">OrbitError</span><span class="p">::</span><span class="nf">invalid_argument</span><span class="p">(</span><span class="s">"Offset out of bounds"</span><span class="p">));</span>
        <span class="p">}</span>
        
        <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">self</span><span class="py">.base_addr</span><span class="nf">.add</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">T</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">ptr</span><span class="nf">.read_volatile</span><span class="p">())</span>
    <span class="p">}</span>
    
    <span class="cd">/// Perform zero-copy write</span>
    <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">write_at</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">OrbitResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span>
    <span class="k">where</span> 
        <span class="n">T</span><span class="p">:</span> <span class="nb">Copy</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="o">+</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">self</span><span class="py">.size</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">OrbitError</span><span class="p">::</span><span class="nf">invalid_argument</span><span class="p">(</span><span class="s">"Offset out of bounds"</span><span class="p">));</span>
        <span class="p">}</span>
        
        <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">self</span><span class="py">.base_addr</span><span class="nf">.add</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">;</span>
        <span class="n">ptr</span><span class="nf">.write_volatile</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
        
        <span class="c1">// Update access statistics</span>
        <span class="k">self</span><span class="py">.access_stats</span><span class="nf">.record_write</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="3-transparent-huge-page-management">3. Transparent Huge Page Management</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Transparent Huge Page (THP) configuration</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">HugePageSize</span> <span class="p">{</span>
    <span class="cd">/// 2MB huge pages (default)</span>
    <span class="n">Size2MB</span><span class="p">,</span>
    <span class="cd">/// 1GB huge pages (for very large datasets)</span>
    <span class="n">Size1GB</span><span class="p">,</span>
    <span class="cd">/// System default</span>
    <span class="n">SystemDefault</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/// Huge page manager</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">HugePageManager</span> <span class="p">{</span>
    <span class="cd">/// Current huge page configuration</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">HugePageConfig</span><span class="p">,</span>
    <span class="cd">/// Available huge page sizes</span>
    <span class="n">available_sizes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">HugePageSize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// Huge page statistics</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">HugePageStats</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">HugePageManager</span> <span class="p">{</span>
    <span class="cd">/// Enable transparent huge pages for a memory region</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">enable_thp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">addr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">OrbitResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">libc</span><span class="p">::</span><span class="nf">madvise</span><span class="p">(</span>
                <span class="n">addr</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nn">libc</span><span class="p">::</span><span class="nb">c_void</span><span class="p">,</span>
                <span class="n">size</span><span class="p">,</span>
                <span class="nn">libc</span><span class="p">::</span><span class="n">MADV_HUGEPAGE</span>
            <span class="p">);</span>
            
            <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">OrbitError</span><span class="p">::</span><span class="nf">system</span><span class="p">(</span>
                    <span class="nd">format!</span><span class="p">(</span><span class="s">"Failed to enable THP: {}"</span><span class="p">,</span> <span class="nn">errno</span><span class="p">::</span><span class="nf">errno</span><span class="p">())</span>
                <span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">self</span><span class="py">.stats.thp_enabled_regions</span><span class="nf">.fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">);</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="cd">/// Configure transparent huge page behavior</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">configure_thp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">MMapConfig</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">OrbitResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">config</span><span class="py">.huge_page_size</span> <span class="p">{</span>
            <span class="nn">HugePageSize</span><span class="p">::</span><span class="n">Size2MB</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.write_sys_file</span><span class="p">(</span><span class="s">"/sys/kernel/mm/transparent_hugepage/enabled"</span><span class="p">,</span> <span class="s">"madvise"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="k">self</span><span class="nf">.write_sys_file</span><span class="p">(</span><span class="s">"/sys/kernel/mm/transparent_hugepage/defrag"</span><span class="p">,</span> <span class="s">"defer"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="nn">HugePageSize</span><span class="p">::</span><span class="n">Size1GB</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// Configure 1GB huge pages (requires kernel support)</span>
                <span class="k">self</span><span class="nf">.configure_1gb_pages</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="nn">HugePageSize</span><span class="p">::</span><span class="n">SystemDefault</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// Use system defaults</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="4-numa-optimization">4. NUMA Optimization</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// NUMA topology and optimization</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">NumaTopology</span> <span class="p">{</span>
    <span class="cd">/// Number of NUMA nodes</span>
    <span class="n">node_count</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="cd">/// CPU to NUMA node mapping</span>
    <span class="n">cpu_to_node</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// Memory information per NUMA node</span>
    <span class="n">node_memory</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="n">NumaNodeMemory</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// Distance matrix between NUMA nodes</span>
    <span class="n">distance_matrix</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/// NUMA-aware memory allocation policy</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">NumaPolicy</span> <span class="p">{</span>
    <span class="cd">/// Allocate memory on the local NUMA node</span>
    <span class="n">Local</span><span class="p">,</span>
    <span class="cd">/// Interleave memory across all NUMA nodes</span>
    <span class="n">Interleave</span><span class="p">,</span>
    <span class="cd">/// Bind memory to specific NUMA nodes</span>
    <span class="nf">Bind</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="cd">/// Prefer specific NUMA nodes but allow fallback</span>
    <span class="nf">Preferred</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">NumaTopology</span> <span class="p">{</span>
    <span class="cd">/// Detect NUMA topology</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">detect</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">OrbitResult</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">node_count</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">get_numa_node_count</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">cpu_to_node</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">build_cpu_mapping</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">node_memory</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">get_node_memory_info</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">distance_matrix</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">build_distance_matrix</span><span class="p">(</span><span class="n">node_count</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
            <span class="n">node_count</span><span class="p">,</span>
            <span class="n">cpu_to_node</span><span class="p">,</span>
            <span class="n">node_memory</span><span class="p">,</span>
            <span class="n">distance_matrix</span><span class="p">,</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="cd">/// Allocate memory with NUMA awareness</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">numa_alloc</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> 
        <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> 
        <span class="n">policy</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">NumaPolicy</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">OrbitResult</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">policy</span> <span class="p">{</span>
            <span class="nn">NumaPolicy</span><span class="p">::</span><span class="n">Local</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">current_node</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.get_current_numa_node</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
                <span class="k">self</span><span class="nf">.alloc_on_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">current_node</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="nn">NumaPolicy</span><span class="p">::</span><span class="n">Interleave</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.alloc_interleaved</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="nn">NumaPolicy</span><span class="p">::</span><span class="nf">Bind</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.alloc_on_nodes</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="nn">NumaPolicy</span><span class="p">::</span><span class="nf">Preferred</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.alloc_preferred</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="5-io-ring-integration">5. I/O Ring Integration</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// I/O ring for high-performance async I/O</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">IoRingManager</span> <span class="p">{</span>
    <span class="cd">/// io_uring instance</span>
    <span class="n">ring</span><span class="p">:</span> <span class="n">IoUring</span><span class="p">,</span>
    <span class="cd">/// Submission queue entries</span>
    <span class="n">sq_entries</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="cd">/// Completion queue entries</span>
    <span class="n">cq_entries</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="cd">/// Features supported by the kernel</span>
    <span class="n">features</span><span class="p">:</span> <span class="n">IoUringFeatures</span><span class="p">,</span>
    <span class="cd">/// Performance counters</span>
    <span class="n">counters</span><span class="p">:</span> <span class="n">IoRingCounters</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">IoRingManager</span> <span class="p">{</span>
    <span class="cd">/// Initialize io_uring with optimal settings</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">config</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">MMapConfig</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">OrbitResult</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">ring</span> <span class="o">=</span> <span class="nn">IoUring</span><span class="p">::</span><span class="nf">builder</span><span class="p">()</span>
            <span class="nf">.setup_cqsize</span><span class="p">(</span><span class="n">config</span><span class="py">.io_queue_depth</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
            <span class="nf">.build</span><span class="p">(</span><span class="n">config</span><span class="py">.io_queue_depth</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            
        <span class="k">let</span> <span class="n">features</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">detect_features</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ring</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
            <span class="n">ring</span><span class="p">,</span>
            <span class="n">sq_entries</span><span class="p">:</span> <span class="n">config</span><span class="py">.io_queue_depth</span><span class="p">,</span>
            <span class="n">cq_entries</span><span class="p">:</span> <span class="n">config</span><span class="py">.io_queue_depth</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">features</span><span class="p">,</span>
            <span class="n">counters</span><span class="p">:</span> <span class="nn">IoRingCounters</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="cd">/// Submit async read operation</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">async_read</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">fd</span><span class="p">:</span> <span class="n">RawFd</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
        <span class="n">offset</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">OrbitResult</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">read_e</span> <span class="o">=</span> <span class="nn">opcode</span><span class="p">::</span><span class="nn">Read</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">types</span><span class="p">::</span><span class="nf">Fd</span><span class="p">(</span><span class="n">fd</span><span class="p">),</span> <span class="n">buf</span><span class="nf">.as_mut_ptr</span><span class="p">(),</span> <span class="n">buf</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">)</span>
            <span class="nf">.offset</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
            
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.ring</span><span class="nf">.submission</span><span class="p">()</span>
                <span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">read_e</span><span class="nf">.build</span><span class="p">())</span>
                <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nn">OrbitError</span><span class="p">::</span><span class="nf">io</span><span class="p">(</span><span class="n">e</span><span class="nf">.to_string</span><span class="p">()))</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">self</span><span class="py">.ring</span><span class="nf">.submit_and_wait</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        
        <span class="k">let</span> <span class="n">cqe</span> <span class="o">=</span> <span class="k">self</span><span class="py">.ring</span><span class="nf">.completion</span><span class="p">()</span><span class="nf">.next</span><span class="p">()</span>
            <span class="nf">.ok_or_else</span><span class="p">(||</span> <span class="nn">OrbitError</span><span class="p">::</span><span class="nf">io</span><span class="p">(</span><span class="s">"No completion event"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
            
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cqe</span><span class="nf">.result</span><span class="p">();</span>
        <span class="k">if</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">OrbitError</span><span class="p">::</span><span class="nf">io</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"Read failed: {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">)));</span>
        <span class="p">}</span>
        
        <span class="k">self</span><span class="py">.counters.reads_completed</span><span class="nf">.fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">);</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">result</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="cd">/// Submit async write operation</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">async_write</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">fd</span><span class="p">:</span> <span class="n">RawFd</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
        <span class="n">offset</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">OrbitResult</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">write_e</span> <span class="o">=</span> <span class="nn">opcode</span><span class="p">::</span><span class="nn">Write</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">types</span><span class="p">::</span><span class="nf">Fd</span><span class="p">(</span><span class="n">fd</span><span class="p">),</span> <span class="n">buf</span><span class="nf">.as_ptr</span><span class="p">(),</span> <span class="n">buf</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">)</span>
            <span class="nf">.offset</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
            
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.ring</span><span class="nf">.submission</span><span class="p">()</span>
                <span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">write_e</span><span class="nf">.build</span><span class="p">())</span>
                <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nn">OrbitError</span><span class="p">::</span><span class="nf">io</span><span class="p">(</span><span class="n">e</span><span class="nf">.to_string</span><span class="p">()))</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">self</span><span class="py">.ring</span><span class="nf">.submit_and_wait</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        
        <span class="k">let</span> <span class="n">cqe</span> <span class="o">=</span> <span class="k">self</span><span class="py">.ring</span><span class="nf">.completion</span><span class="p">()</span><span class="nf">.next</span><span class="p">()</span>
            <span class="nf">.ok_or_else</span><span class="p">(||</span> <span class="nn">OrbitError</span><span class="p">::</span><span class="nf">io</span><span class="p">(</span><span class="s">"No completion event"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
            
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cqe</span><span class="nf">.result</span><span class="p">();</span>
        <span class="k">if</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">OrbitError</span><span class="p">::</span><span class="nf">io</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"Write failed: {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">)));</span>
        <span class="p">}</span>
        
        <span class="k">self</span><span class="py">.counters.writes_completed</span><span class="nf">.fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">);</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">result</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="configuration-system">Configuration System</h3>

<h4 id="complete-configuration-structure">Complete Configuration Structure</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Complete configuration for memory-mapped file architecture</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">OrbitMMapConfig</span> <span class="p">{</span>
    <span class="cd">/// Memory-mapped file provider configuration</span>
    <span class="k">pub</span> <span class="n">mmap</span><span class="p">:</span> <span class="n">MMapConfig</span><span class="p">,</span>
    <span class="cd">/// Huge page configuration</span>
    <span class="k">pub</span> <span class="n">huge_pages</span><span class="p">:</span> <span class="n">HugePageConfig</span><span class="p">,</span>
    <span class="cd">/// NUMA optimization configuration</span>
    <span class="k">pub</span> <span class="n">numa</span><span class="p">:</span> <span class="n">NumaConfig</span><span class="p">,</span>
    <span class="cd">/// I/O ring configuration</span>
    <span class="k">pub</span> <span class="n">io_ring</span><span class="p">:</span> <span class="n">IoRingConfig</span><span class="p">,</span>
    <span class="cd">/// Performance tuning</span>
    <span class="k">pub</span> <span class="n">performance</span><span class="p">:</span> <span class="n">PerformanceConfig</span><span class="p">,</span>
    <span class="cd">/// Monitoring configuration</span>
    <span class="k">pub</span> <span class="n">monitoring</span><span class="p">:</span> <span class="n">MonitoringConfig</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/// Huge page specific configuration</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">HugePageConfig</span> <span class="p">{</span>
    <span class="cd">/// Enable transparent huge pages</span>
    <span class="k">pub</span> <span class="n">enabled</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="cd">/// Huge page size preference</span>
    <span class="k">pub</span> <span class="n">size</span><span class="p">:</span> <span class="n">HugePageSize</span><span class="p">,</span>
    <span class="cd">/// Defragmentation strategy</span>
    <span class="k">pub</span> <span class="n">defrag</span><span class="p">:</span> <span class="n">DefragStrategy</span><span class="p">,</span>
    <span class="cd">/// Reserve huge pages at startup</span>
    <span class="k">pub</span> <span class="n">reserve_pages</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/// NUMA configuration</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">NumaConfig</span> <span class="p">{</span>
    <span class="cd">/// Enable NUMA optimizations</span>
    <span class="k">pub</span> <span class="n">enabled</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="cd">/// Memory allocation policy</span>
    <span class="k">pub</span> <span class="n">policy</span><span class="p">:</span> <span class="n">NumaPolicy</span><span class="p">,</span>
    <span class="cd">/// CPU affinity settings</span>
    <span class="k">pub</span> <span class="n">cpu_affinity</span><span class="p">:</span> <span class="n">CpuAffinityConfig</span><span class="p">,</span>
    <span class="cd">/// Memory migration policy</span>
    <span class="k">pub</span> <span class="n">memory_migration</span><span class="p">:</span> <span class="n">MemoryMigrationPolicy</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/// I/O ring configuration</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">IoRingConfig</span> <span class="p">{</span>
    <span class="cd">/// Enable io_uring</span>
    <span class="k">pub</span> <span class="n">enabled</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="cd">/// Submission queue depth</span>
    <span class="k">pub</span> <span class="n">sq_entries</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="cd">/// Completion queue depth multiplier</span>
    <span class="k">pub</span> <span class="n">cq_multiplier</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
    <span class="cd">/// I/O polling mode</span>
    <span class="k">pub</span> <span class="n">polling_mode</span><span class="p">:</span> <span class="n">IoPollingMode</span><span class="p">,</span>
    <span class="cd">/// Kernel submission queue polling</span>
    <span class="k">pub</span> <span class="n">sq_polling</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="configuration-files">Configuration Files</h4>

<p><strong>Complete TOML Configuration Example:</strong></p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># Orbit-RS Memory-Mapped File Configuration</span>

<span class="k">[</span><span class="n">server</span><span class="k">]</span>
<span class="n">persistence_backend</span> <span class="o">=</span><span class="w"> </span><span class="s">"memory_mapped"</span>
<span class="n">bind_address</span> <span class="o">=</span><span class="w"> </span><span class="s">"0.0.0.0:50051"</span>

<span class="k">[</span><span class="n">mmap</span><span class="k">]</span>
<span class="n">data_dir</span> <span class="o">=</span><span class="w"> </span><span class="s">"/mnt/nvme/orbit-data"</span>
<span class="n">file_size_gb</span> <span class="o">=</span><span class="w"> </span><span class="mi">1000</span>
<span class="n">max_mapped_size_gb</span> <span class="o">=</span><span class="w"> </span><span class="mi">2000</span>
<span class="n">enable_huge_pages</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">huge_page_size</span> <span class="o">=</span><span class="w"> </span><span class="s">"2MB"</span>
<span class="n">prefault_pages</span> <span class="o">=</span><span class="w"> </span><span class="kc">false</span>
<span class="n">memory_advice</span> <span class="o">=</span><span class="w"> </span><span class="s">"random"</span>
<span class="n">numa_policy</span> <span class="o">=</span><span class="w"> </span><span class="s">"local"</span>
<span class="n">enable_io_uring</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">io_queue_depth</span> <span class="o">=</span><span class="w"> </span><span class="mi">128</span>
<span class="n">sync_mode</span> <span class="o">=</span><span class="w"> </span><span class="s">"async"</span>

<span class="k">[</span><span class="n">huge_pages</span><span class="k">]</span>
<span class="n">enabled</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">size</span> <span class="o">=</span><span class="w"> </span><span class="s">"2MB"</span>  <span class="c"># Options: "2MB", "1GB", "system_default"</span>
<span class="n">defrag</span> <span class="o">=</span><span class="w"> </span><span class="s">"defer"</span>  <span class="c"># Options: "always", "defer", "never"</span>
<span class="n">reserve_pages</span> <span class="o">=</span><span class="w"> </span><span class="mi">1024</span>  <span class="c"># Reserve 1024 * 2MB = 2GB huge pages</span>

<span class="k">[</span><span class="n">numa</span><span class="k">]</span>
<span class="n">enabled</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">policy</span> <span class="o">=</span><span class="w"> </span><span class="s">"local"</span>  <span class="c"># Options: "local", "interleave", "bind", "preferred"</span>
<span class="n">cpu_affinity</span> <span class="o">=</span><span class="w"> </span><span class="s">"numa_local"</span>  <span class="c"># Bind threads to local NUMA node CPUs</span>
<span class="n">memory_migration</span> <span class="o">=</span><span class="w"> </span><span class="s">"on_fault"</span>  <span class="c"># Options: "disabled", "on_fault", "proactive"</span>

<span class="k">[</span><span class="n">io_ring</span><span class="k">]</span>
<span class="n">enabled</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">sq_entries</span> <span class="o">=</span><span class="w"> </span><span class="mi">256</span>
<span class="n">cq_multiplier</span> <span class="o">=</span><span class="w"> </span><span class="mf">2.0</span>  <span class="c"># CQ size = SQ size * multiplier</span>
<span class="n">polling_mode</span> <span class="o">=</span><span class="w"> </span><span class="s">"interrupt"</span>  <span class="c"># Options: "interrupt", "polling", "hybrid"</span>
<span class="n">sq_polling</span> <span class="o">=</span><span class="w"> </span><span class="kc">false</span>  <span class="c"># Kernel-side SQ polling</span>

<span class="k">[</span><span class="n">performance</span><span class="k">]</span>
<span class="n">worker_threads</span> <span class="o">=</span><span class="w"> </span><span class="mi">0</span>  <span class="c"># Auto-detect based on CPU cores</span>
<span class="n">enable_cpu_affinity</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">memory_prefetch</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">page_access_tracking</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">adaptive_readahead</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>

<span class="k">[</span><span class="n">monitoring</span><span class="k">]</span>
<span class="n">enabled</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">page_fault_tracking</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">memory_usage_reporting</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">io_latency_histogram</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">numa_statistics</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
</code></pre></div></div>

<p><strong>Kubernetes ConfigMap Integration:</strong></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ConfigMap</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">orbit-mmap-config</span>
<span class="na">data</span><span class="pi">:</span>
  <span class="na">orbit-server.toml</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s"># Include the complete TOML configuration above</span>
    
  <span class="c1"># Environment-specific overrides</span>
  <span class="na">production.toml</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">[mmap]</span>
    <span class="s">file_size_gb = 2000</span>
    <span class="s">sync_mode = "sync"</span>
    
    <span class="s">[monitoring]</span>
    <span class="s">enabled = true</span>
    <span class="s">metrics_export_interval = 15</span>
    
  <span class="na">development.toml</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">[mmap]</span>
    <span class="s">file_size_gb = 10</span>
    <span class="s">enable_huge_pages = false</span>
    
    <span class="s">[io_ring]</span>
    <span class="s">enabled = false  # May not be available in dev environments</span>
</code></pre></div></div>

<h2 id="implementation-plan">Implementation Plan</h2>

<h3 id="phase-1-core-infrastructure-weeks-1-4">Phase 1: Core Infrastructure (Weeks 1-4)</h3>

<h4 id="week-1-2-basic-mmap-provider">Week 1-2: Basic MMap Provider</h4>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Implement <code class="language-plaintext highlighter-rouge">MMapPersistenceProvider</code> struct</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Basic memory mapping functionality</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />File creation and management</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Zero-copy read/write operations</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Integration with existing persistence traits</li>
</ul>

<h4 id="week-3-4-configuration-system">Week 3-4: Configuration System</h4>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Complete <code class="language-plaintext highlighter-rouge">MMapConfig</code> structure</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />TOML configuration parsing</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Environment variable overrides</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Configuration validation</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Default configuration profiles</li>
</ul>

<h3 id="phase-2-advanced-features-weeks-5-8">Phase 2: Advanced Features (Weeks 5-8)</h3>

<h4 id="week-5-6-transparent-huge-page-support">Week 5-6: Transparent Huge Page Support</h4>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><code class="language-plaintext highlighter-rouge">HugePageManager</code> implementation</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />THP detection and configuration</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />2MB huge page support</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />1GB huge page support (where available)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />THP monitoring and statistics</li>
</ul>

<h4 id="week-7-8-numa-optimization">Week 7-8: NUMA Optimization</h4>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><code class="language-plaintext highlighter-rouge">NumaTopology</code> detection</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />NUMA-aware memory allocation</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />CPU affinity management</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Memory migration policies</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />NUMA performance monitoring</li>
</ul>

<h3 id="phase-3-io-optimization-weeks-9-12">Phase 3: I/O Optimization (Weeks 9-12)</h3>

<h4 id="week-9-10-io-ring-integration">Week 9-10: I/O Ring Integration</h4>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><code class="language-plaintext highlighter-rouge">IoRingManager</code> implementation</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Async read/write operations</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Polling mode support</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Error handling and fallbacks</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Performance benchmarking</li>
</ul>

<h4 id="week-11-12-performance-tuning">Week 11-12: Performance Tuning</h4>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Page access tracking</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Adaptive prefetching</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Memory pressure handling</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Hot/cold data management</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Performance optimization algorithms</li>
</ul>

<h3 id="phase-4-deployment--operations-weeks-13-16">Phase 4: Deployment &amp; Operations (Weeks 13-16)</h3>

<h4 id="week-13-14-kubernetes-integration">Week 13-14: Kubernetes Integration</h4>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Optimized StatefulSet configurations</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Node preparation scripts</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Storage class definitions</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Monitoring and alerting</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Auto-scaling configurations</li>
</ul>

<h4 id="week-15-16-production-readiness">Week 15-16: Production Readiness</h4>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Comprehensive testing</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Performance benchmarks</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Documentation</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Migration tools</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Operational runbooks</li>
</ul>

<h2 id="deployment-strategies">Deployment Strategies</h2>

<h3 id="1-kubernetes-deployment">1. Kubernetes Deployment</h3>

<p><strong>Node Requirements:</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">nodeRequirements</span><span class="pi">:</span>
  <span class="na">cpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">16-32</span><span class="nv"> </span><span class="s">cores"</span>
  <span class="na">memory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">32-96</span><span class="nv"> </span><span class="s">GB"</span>
  <span class="na">storage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">2-10</span><span class="nv"> </span><span class="s">TB</span><span class="nv"> </span><span class="s">NVMe</span><span class="nv"> </span><span class="s">SSD"</span>
  <span class="na">network</span><span class="pi">:</span> <span class="s2">"</span><span class="s">25+</span><span class="nv"> </span><span class="s">Gbps"</span>
  <span class="na">kernel</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Linux</span><span class="nv"> </span><span class="s">5.4+</span><span class="nv"> </span><span class="s">(io_uring</span><span class="nv"> </span><span class="s">support)"</span>
</code></pre></div></div>

<p><strong>Example Deployment:</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># Label nodes for mmap optimization</span>
kubectl label nodes &lt;node-name&gt; orbit-rs/mmap-optimized<span class="o">=</span><span class="nb">true</span>

<span class="c"># Deploy storage classes</span>
kubectl apply <span class="nt">-f</span> k8s/mmap-optimized/01-storage-mmap.yaml

<span class="c"># Deploy configurations</span>
kubectl apply <span class="nt">-f</span> k8s/mmap-optimized/02-configmap-mmap.yaml

<span class="c"># Deploy the optimized StatefulSet</span>
kubectl apply <span class="nt">-f</span> k8s/mmap-optimized/03-statefulset-mmap.yaml

<span class="c"># Deploy monitoring and node preparation</span>
kubectl apply <span class="nt">-f</span> k8s/mmap-optimized/04-node-prep-monitoring.yaml
</code></pre></div></div>

<h3 id="2-single-node-deployment">2. Single Node Deployment</h3>

<p>For development and small-scale deployments:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># single-node-config.toml</span>
<span class="k">[</span><span class="n">mmap</span><span class="k">]</span>
<span class="n">data_dir</span> <span class="o">=</span><span class="w"> </span><span class="s">"/data/orbit-mmap"</span>
<span class="n">file_size_gb</span> <span class="o">=</span><span class="w"> </span><span class="mi">100</span>
<span class="n">max_mapped_size_gb</span> <span class="o">=</span><span class="w"> </span><span class="mi">200</span>
<span class="n">enable_huge_pages</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">huge_page_size</span> <span class="o">=</span><span class="w"> </span><span class="s">"2MB"</span>

<span class="k">[</span><span class="n">numa</span><span class="k">]</span>
<span class="n">enabled</span> <span class="o">=</span><span class="w"> </span><span class="kc">false</span>  <span class="c"># Single socket system</span>

<span class="k">[</span><span class="n">performance</span><span class="k">]</span>
<span class="n">worker_threads</span> <span class="o">=</span><span class="w"> </span><span class="mi">8</span>  <span class="c"># Match available cores</span>
</code></pre></div></div>

<p><strong>Setup Commands:</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># Prepare the system</span>
<span class="nb">sudo </span>sysctl <span class="nt">-w</span> vm.max_map_count<span class="o">=</span>2097152
<span class="nb">sudo echo </span>madvise <span class="o">&gt;</span> /sys/kernel/mm/transparent_hugepage/enabled

<span class="c"># Create data directory</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /data/orbit-mmap
<span class="nb">sudo chown</span> <span class="nv">$USER</span>:<span class="nv">$USER</span> /data/orbit-mmap

<span class="c"># Run orbit-rs</span>
./orbit-server <span class="nt">--config</span> single-node-config.toml
</code></pre></div></div>

<h3 id="3-vm-based-cluster-deployment">3. VM-Based Cluster Deployment</h3>

<p>For traditional VM deployments (AWS EC2, Azure VMs, GCP Compute):</p>

<p><strong>Terraform Configuration:</strong></p>
<div class="language-hcl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">resource</span> <span class="s2">"aws_instance"</span> <span class="s2">"orbit_mmap_nodes"</span> <span class="p">{</span>
  <span class="nx">count</span> <span class="o">=</span> <span class="mi">30</span>  <span class="c1"># Reduced from traditional 100+ nodes</span>
  
  <span class="c1"># High-performance instance types with NVMe</span>
  <span class="nx">instance_type</span> <span class="o">=</span> <span class="s2">"i3en.4xlarge"</span>  <span class="c1"># 16 vCPU, 128GB RAM, 2x1.9TB NVMe</span>
  
  <span class="c1"># Optimized AMI with kernel 5.4+</span>
  <span class="nx">ami</span> <span class="o">=</span> <span class="nx">var</span><span class="p">.</span><span class="nx">optimized_ami_id</span>
  
  <span class="c1"># Enhanced networking</span>
  <span class="nx">enhanced_networking</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="nx">sriov_net_support</span> <span class="o">=</span> <span class="s2">"simple"</span>
  
  <span class="c1"># Instance storage configuration</span>
  <span class="nx">ephemeral_block_device</span> <span class="p">{</span>
    <span class="nx">device_name</span> <span class="o">=</span> <span class="s2">"/dev/xvdb"</span>
    <span class="nx">virtual_name</span> <span class="o">=</span> <span class="s2">"ephemeral0"</span>
  <span class="p">}</span>
  
  <span class="c1"># User data for system optimization</span>
  <span class="nx">user_data</span> <span class="o">=</span> <span class="nx">base64encode</span><span class="p">(</span><span class="nx">templatefile</span><span class="p">(</span><span class="s2">"user-data.sh"</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">node_id</span> <span class="o">=</span> <span class="nx">count</span><span class="p">.</span><span class="nx">index</span>
  <span class="p">}))</span>
  
  <span class="nx">tags</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">Name</span> <span class="o">=</span> <span class="s2">"orbit-mmap-node-${count.index}"</span>
    <span class="nx">Type</span> <span class="o">=</span> <span class="s2">"orbit-rs-mmap"</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>VM Initialization Script:</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">#!/bin/bash</span>
<span class="c"># user-data.sh - VM initialization for mmap optimization</span>

<span class="c"># Update system</span>
yum update <span class="nt">-y</span>

<span class="c"># Install dependencies</span>
yum <span class="nb">install</span> <span class="nt">-y</span> nvme-cli fio

<span class="c"># Configure transparent huge pages</span>
<span class="nb">echo </span>madvise <span class="o">&gt;</span> /sys/kernel/mm/transparent_hugepage/enabled
<span class="nb">echo </span>defer <span class="o">&gt;</span> /sys/kernel/mm/transparent_hugepage/defrag

<span class="c"># Increase mmap limits</span>
<span class="nb">echo</span> <span class="s2">"vm.max_map_count=2097152"</span> <span class="o">&gt;&gt;</span> /etc/sysctl.conf
<span class="nb">echo</span> <span class="s2">"vm.mmap_min_addr=4096"</span> <span class="o">&gt;&gt;</span> /etc/sysctl.conf
<span class="nb">echo</span> <span class="s2">"kernel.shmmax=68719476736"</span> <span class="o">&gt;&gt;</span> /etc/sysctl.conf

<span class="c"># Apply sysctl changes</span>
sysctl <span class="nt">-p</span>

<span class="c"># Format and mount NVMe drives</span>
mkfs.ext4 <span class="nt">-F</span> /dev/nvme1n1
<span class="nb">mkdir</span> <span class="nt">-p</span> /mnt/orbit-data
mount <span class="nt">-o</span> noatime,nodiratime /dev/nvme1n1 /mnt/orbit-data

<span class="c"># Add to fstab</span>
<span class="nb">echo</span> <span class="s2">"/dev/nvme1n1 /mnt/orbit-data ext4 noatime,nodiratime 0 2"</span> <span class="o">&gt;&gt;</span> /etc/fstab

<span class="c"># Download and start orbit-rs</span>
wget https://releases.orbit-rs.com/latest/orbit-server
<span class="nb">chmod</span> +x orbit-server
./orbit-server <span class="nt">--config</span> /etc/orbit-rs/mmap-cluster.toml
</code></pre></div></div>

<p><strong>Cluster Configuration:</strong></p>
<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># mmap-cluster.toml</span>
<span class="k">[</span><span class="n">server</span><span class="k">]</span>
<span class="n">persistence_backend</span> <span class="o">=</span><span class="w"> </span><span class="s">"memory_mapped"</span>
<span class="n">node_id</span> <span class="o">=</span><span class="w"> </span><span class="s">"${NODE_ID}"</span>
<span class="n">cluster_discovery</span> <span class="o">=</span><span class="w"> </span><span class="s">"consul"</span>  <span class="c"># or "etcd", "kubernetes"</span>

<span class="k">[</span><span class="n">mmap</span><span class="k">]</span>
<span class="n">data_dir</span> <span class="o">=</span><span class="w"> </span><span class="s">"/mnt/orbit-data"</span>
<span class="n">file_size_gb</span> <span class="o">=</span><span class="w"> </span><span class="mi">1900</span>  <span class="c"># Match instance storage capacity</span>
<span class="n">max_mapped_size_gb</span> <span class="o">=</span><span class="w"> </span><span class="mi">3800</span>
<span class="n">enable_huge_pages</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>

<span class="k">[</span><span class="n">cluster</span><span class="k">]</span>
<span class="n">discovery_endpoints</span> <span class="o">=</span><span class="w"> </span><span class="p">[</span>
  <span class="s">"consul.orbit-cluster.internal:8500"</span>
<span class="p">]</span>
</code></pre></div></div>

<h3 id="4-ultra-dense-3-node-deployment-1pb-with-3-nodes">4. Ultra-Dense 3-Node Deployment (1PB with 3 Nodes)</h3>

<p><strong>Challenge</strong>: Handle 1PB of data with only 3 dedicated nodes</p>

<p><strong>Solution</strong>: Ultra-high density configuration with memory-mapped files</p>

<h4 id="resource-requirements-per-node">Resource Requirements Per Node</h4>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">ultra_dense_node_specs</span><span class="pi">:</span>
  <span class="na">data_per_node</span><span class="pi">:</span> <span class="s2">"</span><span class="s">334TB</span><span class="nv"> </span><span class="s">(1PB</span><span class="nv"> </span><span class="s">÷</span><span class="nv"> </span><span class="s">3</span><span class="nv"> </span><span class="s">nodes)"</span>
  <span class="na">storage_with_replication</span><span class="pi">:</span> <span class="s2">"</span><span class="s">800TB</span><span class="nv"> </span><span class="s">per</span><span class="nv"> </span><span class="s">node</span><span class="nv"> </span><span class="s">(2x</span><span class="nv"> </span><span class="s">replication</span><span class="nv"> </span><span class="s">+</span><span class="nv"> </span><span class="s">20%</span><span class="nv"> </span><span class="s">buffer)"</span>
  
  <span class="na">hardware</span><span class="pi">:</span>
    <span class="na">cpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">32-64</span><span class="nv"> </span><span class="s">cores"</span>
    <span class="na">memory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">256-512</span><span class="nv"> </span><span class="s">GB</span><span class="nv"> </span><span class="s">RAM"</span> 
    <span class="na">storage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">800TB</span><span class="nv"> </span><span class="s">NVMe</span><span class="nv"> </span><span class="s">(RAID</span><span class="nv"> </span><span class="s">0</span><span class="nv"> </span><span class="s">across</span><span class="nv"> </span><span class="s">multiple</span><span class="nv"> </span><span class="s">drives)"</span>
    <span class="na">network</span><span class="pi">:</span> <span class="s2">"</span><span class="s">100</span><span class="nv"> </span><span class="s">Gbps"</span>
    <span class="na">instance_type</span><span class="pi">:</span> <span class="s2">"</span><span class="s">AWS</span><span class="nv"> </span><span class="s">i4i.24xlarge</span><span class="nv"> </span><span class="s">or</span><span class="nv"> </span><span class="s">bare</span><span class="nv"> </span><span class="s">metal"</span>
    
  <span class="na">storage_calculation</span><span class="pi">:</span>
    <span class="na">raw_data</span><span class="pi">:</span> <span class="s2">"</span><span class="s">1</span><span class="nv"> </span><span class="s">PB"</span>
    <span class="na">replication</span><span class="pi">:</span> <span class="s2">"</span><span class="s">2x</span><span class="nv"> </span><span class="s">=</span><span class="nv"> </span><span class="s">2</span><span class="nv"> </span><span class="s">PB</span><span class="nv"> </span><span class="s">total"</span>
    <span class="na">safety_buffer</span><span class="pi">:</span> <span class="s2">"</span><span class="s">20%</span><span class="nv"> </span><span class="s">=</span><span class="nv"> </span><span class="s">2.4</span><span class="nv"> </span><span class="s">PB</span><span class="nv"> </span><span class="s">required"</span>
    <span class="na">per_node</span><span class="pi">:</span> <span class="s2">"</span><span class="s">2.4</span><span class="nv"> </span><span class="s">PB</span><span class="nv"> </span><span class="s">÷</span><span class="nv"> </span><span class="s">3</span><span class="nv"> </span><span class="s">=</span><span class="nv"> </span><span class="s">800</span><span class="nv"> </span><span class="s">TB</span><span class="nv"> </span><span class="s">per</span><span class="nv"> </span><span class="s">node"</span>
    
  <span class="na">memory_calculation</span><span class="pi">:</span>
    <span class="na">working_set</span><span class="pi">:</span> <span class="s2">"</span><span class="s">10%</span><span class="nv"> </span><span class="s">of</span><span class="nv"> </span><span class="s">334TB</span><span class="nv"> </span><span class="s">=</span><span class="nv"> </span><span class="s">33TB"</span>
    <span class="na">page_cache</span><span class="pi">:</span> <span class="s2">"</span><span class="s">64-128</span><span class="nv"> </span><span class="s">GB</span><span class="nv"> </span><span class="s">per</span><span class="nv"> </span><span class="s">node"</span>
    <span class="na">application</span><span class="pi">:</span> <span class="s2">"</span><span class="s">64-128</span><span class="nv"> </span><span class="s">GB</span><span class="nv"> </span><span class="s">per</span><span class="nv"> </span><span class="s">node"</span>
    <span class="na">total_memory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">256-512</span><span class="nv"> </span><span class="s">GB</span><span class="nv"> </span><span class="s">per</span><span class="nv"> </span><span class="s">node"</span>
</code></pre></div></div>

<h4 id="configuration-files-1">Configuration Files</h4>

<p><strong>Storage Configuration (<code class="language-plaintext highlighter-rouge">k8s/3-node-petabyte/01-storage-ultra-dense.yaml</code>)</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Ultra-high density storage class</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">storage.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">StorageClass</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">orbit-ultra-dense-nvme</span>
<span class="na">provisioner</span><span class="pi">:</span> <span class="s">ebs.csi.aws.com</span>
<span class="na">parameters</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">gp3</span>
  <span class="na">iops</span><span class="pi">:</span> <span class="s2">"</span><span class="s">64000"</span>                <span class="c1"># Maximum IOPS</span>
  <span class="na">throughput</span><span class="pi">:</span> <span class="s2">"</span><span class="s">4000"</span>           <span class="c1"># 4 GB/s throughput</span>
  <span class="na">encrypted</span><span class="pi">:</span> <span class="s2">"</span><span class="s">true"</span>
<span class="na">mountOptions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s2">"</span><span class="s">noatime,nodiratime"</span>
  <span class="pi">-</span> <span class="s2">"</span><span class="s">data=writeback"</span>
  <span class="pi">-</span> <span class="s2">"</span><span class="s">commit=60"</span>              <span class="c1"># Optimized for ultra-dense</span>
<span class="nn">---</span>

<span class="c1"># Node-specific 800TB volumes</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">PersistentVolume</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">orbit-ultra-node1-primary</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">capacity</span><span class="pi">:</span>
    <span class="na">storage</span><span class="pi">:</span> <span class="s">800Ti</span>  <span class="c1"># 800TB primary storage</span>
  <span class="na">storageClassName</span><span class="pi">:</span> <span class="s">orbit-ultra-dense-nvme</span>
  <span class="na">local</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">/mnt/orbit-ultra-storage</span>
</code></pre></div></div>

<p><strong>Application Configuration (<code class="language-plaintext highlighter-rouge">k8s/3-node-petabyte/02-configmap-3node.yaml</code>)</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ConfigMap</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">orbit-3node-config</span>
<span class="na">data</span><span class="pi">:</span>
  <span class="na">orbit-server.toml</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">[mmap]</span>
    <span class="s">data_dir = "/mnt/orbit-ultra-storage/data"</span>
    <span class="s">file_size_gb = 50000               # 50TB files</span>
    <span class="s">max_mapped_size_gb = 350000        # 350TB mapped per node</span>
    <span class="s">huge_page_size = "1GB"             # Use 1GB pages</span>
    
    <span class="s"># Replication for 3-node cluster</span>
    <span class="s">replication_factor = 2             # 2x replication</span>
    <span class="s">consistency_level = "quorum"       # Require 2/3 nodes</span>
    
    <span class="s">[memory]</span>
    <span class="s">page_cache_limit_gb = 128          # Large page cache</span>
    <span class="s">memory_pressure_threshold = 0.90   # High threshold</span>
    
    <span class="s">[cluster]</span>
    <span class="s">expected_nodes = 3</span>
    
    <span class="s"># System optimizations for ultra-dense</span>
    <span class="s">vm.max_map_count = 10485760         # 10M mmap regions</span>
    <span class="s">vm.nr_hugepages = 128               # 128GB of 1GB pages</span>
</code></pre></div></div>

<h4 id="deployment-commands">Deployment Commands</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># Label nodes for ultra-dense deployment</span>
kubectl label nodes node1 orbit-rs.io/node-id<span class="o">=</span>node1
kubectl label nodes node1 orbit-rs.io/storage-tier<span class="o">=</span>ultra-dense
kubectl label nodes node2 orbit-rs.io/node-id<span class="o">=</span>node2  
kubectl label nodes node3 orbit-rs.io/node-id<span class="o">=</span>node3

<span class="c"># Deploy ultra-dense storage</span>
kubectl apply <span class="nt">-f</span> k8s/3-node-petabyte/01-storage-ultra-dense.yaml

<span class="c"># Deploy 3-node configuration</span>
kubectl apply <span class="nt">-f</span> k8s/3-node-petabyte/02-configmap-3node.yaml

<span class="c"># Deploy ultra-dense StatefulSet</span>
kubectl apply <span class="nt">-f</span> k8s/3-node-petabyte/03-statefulset-3node.yaml
</code></pre></div></div>

<p><strong>StatefulSet Configuration (<code class="language-plaintext highlighter-rouge">k8s/3-node-petabyte/03-statefulset-3node.yaml</code>)</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">StatefulSet</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">orbit-rs-ultra-dense</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">orbit-rs</span>
    <span class="na">tier</span><span class="pi">:</span> <span class="s">ultra-dense</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
  <span class="na">serviceName</span><span class="pi">:</span> <span class="s">orbit-rs-ultra</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">orbit-rs</span>
      <span class="na">tier</span><span class="pi">:</span> <span class="s">ultra-dense</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">orbit-rs</span>
        <span class="na">tier</span><span class="pi">:</span> <span class="s">ultra-dense</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">affinity</span><span class="pi">:</span>
        <span class="na">podAntiAffinity</span><span class="pi">:</span>
          <span class="na">requiredDuringSchedulingIgnoredDuringExecution</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">labelSelector</span><span class="pi">:</span>
              <span class="na">matchExpressions</span><span class="pi">:</span>
              <span class="pi">-</span> <span class="na">key</span><span class="pi">:</span> <span class="s">app</span>
                <span class="na">operator</span><span class="pi">:</span> <span class="s">In</span>
                <span class="na">values</span><span class="pi">:</span>
                <span class="pi">-</span> <span class="s">orbit-rs</span>
            <span class="na">topologyKey</span><span class="pi">:</span> <span class="s">kubernetes.io/hostname</span>
      <span class="na">initContainers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">system-tuning</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">busybox:1.35</span>
        <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">sh"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">-c"</span><span class="pi">]</span>
        <span class="na">args</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="pi">|</span>
          <span class="s">echo "Configuring ultra-dense system settings..."</span>
          <span class="s"># Configure huge pages</span>
          <span class="s">echo 128 &gt; /sys/kernel/mm/hugepages/hugepages-1048576kB/nr_hugepages</span>
          
          <span class="s"># Configure memory mapping limits</span>
          <span class="s">echo 10485760 &gt; /proc/sys/vm/max_map_count</span>
          
          <span class="s"># Configure file handle limits</span>
          <span class="s">echo 16777216 &gt; /proc/sys/fs/file-max</span>
          
          <span class="s"># Configure network buffer sizes</span>
          <span class="s">echo 134217728 &gt; /proc/sys/net/core/rmem_max</span>
          <span class="s">echo 134217728 &gt; /proc/sys/net/core/wmem_max</span>
          
          <span class="s">echo "System tuning complete for ultra-dense deployment"</span>
        <span class="na">securityContext</span><span class="pi">:</span>
          <span class="na">privileged</span><span class="pi">:</span> <span class="kc">true</span>
        <span class="na">volumeMounts</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">sys</span>
          <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/sys</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">proc</span>
          <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/proc</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">orbit-rs</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">orbit-rs:ultra-dense</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">8080</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">http</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">9090</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">metrics</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">8000</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">cluster</span>
        <span class="na">env</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">POD_NAME</span>
          <span class="na">valueFrom</span><span class="pi">:</span>
            <span class="na">fieldRef</span><span class="pi">:</span>
              <span class="na">fieldPath</span><span class="pi">:</span> <span class="s">metadata.name</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">NODE_ID</span>
          <span class="na">valueFrom</span><span class="pi">:</span>
            <span class="na">fieldRef</span><span class="pi">:</span>
              <span class="na">fieldPath</span><span class="pi">:</span> <span class="s">spec.nodeName</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">TOTAL_MEMORY</span>
          <span class="na">valueFrom</span><span class="pi">:</span>
            <span class="na">resourceFieldRef</span><span class="pi">:</span>
              <span class="na">resource</span><span class="pi">:</span> <span class="s">limits.memory</span>
        <span class="na">resources</span><span class="pi">:</span>
          <span class="na">requests</span><span class="pi">:</span>
            <span class="na">cpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">16"</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">256Gi"</span>
            <span class="na">hugepages-1Gi</span><span class="pi">:</span> <span class="s2">"</span><span class="s">128Gi"</span>  <span class="c1"># 128GB huge pages</span>
          <span class="na">limits</span><span class="pi">:</span>
            <span class="na">cpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">32"</span>  
            <span class="na">memory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">512Gi"</span>
            <span class="na">hugepages-1Gi</span><span class="pi">:</span> <span class="s2">"</span><span class="s">128Gi"</span>
        <span class="na">volumeMounts</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">orbit-ultra-storage</span>
          <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/mnt/orbit-ultra-storage</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">config</span>
          <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/etc/orbit-rs</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">hugepage-1gi</span>
          <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/hugepages-1Gi</span>
        <span class="na">livenessProbe</span><span class="pi">:</span>
          <span class="na">httpGet</span><span class="pi">:</span>
            <span class="na">path</span><span class="pi">:</span> <span class="s">/health</span>
            <span class="na">port</span><span class="pi">:</span> <span class="m">8080</span>
          <span class="na">initialDelaySeconds</span><span class="pi">:</span> <span class="m">60</span>
          <span class="na">periodSeconds</span><span class="pi">:</span> <span class="m">30</span>
          <span class="na">timeoutSeconds</span><span class="pi">:</span> <span class="m">10</span>
          <span class="na">failureThreshold</span><span class="pi">:</span> <span class="m">5</span>
        <span class="na">readinessProbe</span><span class="pi">:</span>
          <span class="na">httpGet</span><span class="pi">:</span>
            <span class="na">path</span><span class="pi">:</span> <span class="s">/ready</span>
            <span class="na">port</span><span class="pi">:</span> <span class="m">8080</span>
          <span class="na">initialDelaySeconds</span><span class="pi">:</span> <span class="m">30</span>
          <span class="na">periodSeconds</span><span class="pi">:</span> <span class="m">15</span>
          <span class="na">timeoutSeconds</span><span class="pi">:</span> <span class="m">5</span>
          <span class="na">failureThreshold</span><span class="pi">:</span> <span class="m">3</span>
      <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">config</span>
        <span class="na">configMap</span><span class="pi">:</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">orbit-3node-config</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">sys</span>
        <span class="na">hostPath</span><span class="pi">:</span>
          <span class="na">path</span><span class="pi">:</span> <span class="s">/sys</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">proc</span>
        <span class="na">hostPath</span><span class="pi">:</span>
          <span class="na">path</span><span class="pi">:</span> <span class="s">/proc</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">hugepage-1gi</span>
        <span class="na">emptyDir</span><span class="pi">:</span>
          <span class="na">medium</span><span class="pi">:</span> <span class="s">HugePages-1Gi</span>
  <span class="na">volumeClaimTemplates</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">orbit-ultra-storage</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">accessModes</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">ReadWriteOnce"</span><span class="pi">]</span>
      <span class="na">storageClassName</span><span class="pi">:</span> <span class="s">orbit-ultra-dense-nvme</span>
      <span class="na">resources</span><span class="pi">:</span>
        <span class="na">requests</span><span class="pi">:</span>
          <span class="na">storage</span><span class="pi">:</span> <span class="s">800Ti</span>  <span class="c1"># 800TB per replica</span>
</code></pre></div></div>

<p><strong>Service Configuration (<code class="language-plaintext highlighter-rouge">k8s/3-node-petabyte/04-services.yaml</code>)</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>

<span class="c1"># Load balancer service for external access</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">orbit-rs-ultra-lb</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">orbit-rs</span>
    <span class="na">tier</span><span class="pi">:</span> <span class="s">ultra-dense</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">LoadBalancer</span>
  <span class="na">ports</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">port</span><span class="pi">:</span> <span class="m">8080</span>
    <span class="na">targetPort</span><span class="pi">:</span> <span class="m">8080</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">http</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">orbit-rs</span>
    <span class="na">tier</span><span class="pi">:</span> <span class="s">ultra-dense</span>
<span class="nn">---</span>

<span class="c1"># Headless service for StatefulSet</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">orbit-rs-ultra</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">orbit-rs</span>
    <span class="na">tier</span><span class="pi">:</span> <span class="s">ultra-dense</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">clusterIP</span><span class="pi">:</span> <span class="s">None</span>
  <span class="na">ports</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">port</span><span class="pi">:</span> <span class="m">8080</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">http</span>
  <span class="pi">-</span> <span class="na">port</span><span class="pi">:</span> <span class="m">9090</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">metrics</span>
  <span class="pi">-</span> <span class="na">port</span><span class="pi">:</span> <span class="m">8000</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">cluster</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">orbit-rs</span>
    <span class="na">tier</span><span class="pi">:</span> <span class="s">ultra-dense</span>
<span class="nn">---</span>

<span class="c1"># Monitoring service</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">orbit-rs-ultra-metrics</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">orbit-rs</span>
    <span class="na">tier</span><span class="pi">:</span> <span class="s">ultra-dense</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="na">prometheus.io/scrape</span><span class="pi">:</span> <span class="s2">"</span><span class="s">true"</span>
    <span class="na">prometheus.io/port</span><span class="pi">:</span> <span class="s2">"</span><span class="s">9090"</span>
    <span class="na">prometheus.io/path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/metrics"</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">ports</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">port</span><span class="pi">:</span> <span class="m">9090</span>
    <span class="na">targetPort</span><span class="pi">:</span> <span class="m">9090</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">metrics</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">orbit-rs</span>
    <span class="na">tier</span><span class="pi">:</span> <span class="s">ultra-dense</span>
</code></pre></div></div>

<p><strong>Health Check Script (<code class="language-plaintext highlighter-rouge">scripts/ultra-dense-health-check.sh</code>)</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">#!/bin/bash</span>
<span class="c"># Ultra-dense deployment health checker</span>

<span class="nb">set</span> <span class="nt">-euo</span> pipefail

<span class="nb">echo</span> <span class="s2">"=== Orbit-RS Ultra-Dense Health Check ==="</span>
<span class="nb">echo</span> <span class="s2">"Timestamp: </span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">"</span>

<span class="c"># Check cluster status</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">1. Checking cluster status..."</span>
kubectl get pods <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>orbit-rs,tier<span class="o">=</span>ultra-dense <span class="nt">-o</span> wide

<span class="c"># Check storage usage</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">2. Checking storage usage per node..."</span>
<span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>0..2<span class="o">}</span><span class="p">;</span> <span class="k">do
    </span><span class="nb">echo</span> <span class="s2">"Node </span><span class="nv">$i</span><span class="s2"> storage:"</span>
    kubectl <span class="nb">exec </span>orbit-rs-ultra-dense-<span class="nv">$i</span> <span class="nt">--</span> <span class="nb">df</span> <span class="nt">-h</span> /mnt/orbit-ultra-storage | <span class="nb">tail</span> <span class="nt">-1</span>
<span class="k">done</span>

<span class="c"># Check memory usage</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">3. Checking memory usage..."</span>
<span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>0..2<span class="o">}</span><span class="p">;</span> <span class="k">do
    </span><span class="nb">echo</span> <span class="s2">"Node </span><span class="nv">$i</span><span class="s2"> memory:"</span>
    kubectl <span class="nb">exec </span>orbit-rs-ultra-dense-<span class="nv">$i</span> <span class="nt">--</span> free <span class="nt">-h</span> | <span class="nb">head</span> <span class="nt">-2</span> | <span class="nb">tail</span> <span class="nt">-1</span>
<span class="k">done</span>

<span class="c"># Check huge page usage</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">4. Checking huge page utilization..."</span>
<span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>0..2<span class="o">}</span><span class="p">;</span> <span class="k">do
    </span><span class="nb">echo</span> <span class="s2">"Node </span><span class="nv">$i</span><span class="s2"> huge pages:"</span>
    kubectl <span class="nb">exec </span>orbit-rs-ultra-dense-<span class="nv">$i</span> <span class="nt">--</span> <span class="nb">cat</span> /proc/meminfo | <span class="nb">grep</span> <span class="nt">-i</span> hugepage
<span class="k">done</span>

<span class="c"># Check mmap region count</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">5. Checking mmap regions..."</span>
<span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>0..2<span class="o">}</span><span class="p">;</span> <span class="k">do
    </span><span class="nb">echo</span> <span class="s2">"Node </span><span class="nv">$i</span><span class="s2"> mmap regions:"</span>
    kubectl <span class="nb">exec </span>orbit-rs-ultra-dense-<span class="nv">$i</span> <span class="nt">--</span> <span class="nb">wc</span> <span class="nt">-l</span> /proc/self/maps
<span class="k">done</span>

<span class="c"># Check application health</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">6. Checking application health endpoints..."</span>
<span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>0..2<span class="o">}</span><span class="p">;</span> <span class="k">do
    </span><span class="nb">echo</span> <span class="s2">"Node </span><span class="nv">$i</span><span class="s2"> health:"</span>
    kubectl <span class="nb">exec </span>orbit-rs-ultra-dense-<span class="nv">$i</span> <span class="nt">--</span> curl <span class="nt">-s</span> http://localhost:8080/health <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"FAILED"</span>
<span class="k">done</span>

<span class="c"># Check performance metrics</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">7. Checking performance metrics..."</span>
<span class="nb">echo</span> <span class="s2">"Total throughput across cluster:"</span>
kubectl <span class="nb">exec </span>orbit-rs-ultra-dense-0 <span class="nt">--</span> curl <span class="nt">-s</span> http://localhost:9090/metrics | <span class="se">\</span>
    <span class="nb">grep</span> <span class="s1">'orbit_throughput_bytes_per_sec'</span> | <span class="nb">head</span> <span class="nt">-1</span>

<span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">=== Health Check Complete ==="</span>
</code></pre></div></div>

<h2 id="7-advanced-memory-management">7. Advanced Memory Management</h2>

<h3 id="71-overview">7.1 Overview</h3>

<p>For ultra-low latency data operations, orbit-rs implements advanced memory management techniques including <strong>object pinning</strong>, <strong>fragmentation strategies</strong>, and <strong>lifetime-aware garbage collection</strong>. These optimizations are critical for maintaining sub-10μs tail latencies in petabyte-scale deployments.</p>

<p><strong>Core Concepts:</strong></p>
<ul>
  <li><strong>Hot Object Pinning</strong>: Keep frequently accessed tables, graph nodes, and virtual objects resident in memory</li>
  <li><strong>Intelligent Fragmentation</strong>: Break large objects into connected slices with independent lifetime management</li>
  <li><strong>NUMA-Aware Placement</strong>: Optimize memory placement based on CPU topology and access patterns</li>
  <li><strong>Predictive Prefetching</strong>: Use query plans and access patterns to warm caches proactively</li>
</ul>

<h3 id="72-memory-pinning-strategies">7.2 Memory Pinning Strategies</h3>

<h4 id="721-pin-budget-and-priority-system">7.2.1 Pin Budget and Priority System</h4>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">pin_management</span><span class="pi">:</span>
  <span class="na">global_budget</span><span class="pi">:</span>
    <span class="na">max_pinned_percentage</span><span class="pi">:</span> <span class="m">40</span>          <span class="c1"># 40% of total RAM</span>
    <span class="na">numa_local_preference</span><span class="pi">:</span> <span class="m">80</span>          <span class="c1"># 80% prefer local NUMA node</span>
    <span class="na">huge_page_allocation</span><span class="pi">:</span> <span class="m">60</span>           <span class="c1"># 60% of pins use huge pages</span>
    
  <span class="na">priority_classes</span><span class="pi">:</span>
    <span class="na">tail_latency_critical</span><span class="pi">:</span> 
      <span class="na">budget_share</span><span class="pi">:</span> <span class="m">50</span>                 <span class="c1"># 50% of pin budget</span>
      <span class="na">max_pin_time_ms</span><span class="pi">:</span> <span class="m">5000</span>           <span class="c1"># 5 second maximum pin time</span>
      
    <span class="na">query_critical</span><span class="pi">:</span>
      <span class="na">budget_share</span><span class="pi">:</span> <span class="m">30</span>                 <span class="c1"># 30% of pin budget  </span>
      <span class="na">max_pin_time_ms</span><span class="pi">:</span> <span class="m">30000</span>          <span class="c1"># 30 second maximum</span>
      
    <span class="na">background_optimization</span><span class="pi">:</span>
      <span class="na">budget_share</span><span class="pi">:</span> <span class="m">20</span>                 <span class="c1"># 20% of pin budget</span>
      <span class="na">max_pin_time_ms</span><span class="pi">:</span> <span class="m">300000</span>         <span class="c1"># 5 minute maximum</span>
</code></pre></div></div>

<h4 id="722-pinning-techniques">7.2.2 Pinning Techniques</h4>

<p><strong>Page-Level Pinning:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Linux: mlock2(MLOCK_ONFAULT) - pin on first access</span>
<span class="c1">// macOS: mlock() fallback for development</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">pin_slice_lazy</span><span class="p">(</span><span class="n">addr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">PinError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[cfg(target_os</span> <span class="nd">=</span> <span class="s">"linux"</span><span class="nd">)]</span>
    <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">libc</span><span class="p">::</span><span class="nf">mlock2</span><span class="p">(</span><span class="n">addr</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">c_void</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nn">libc</span><span class="p">::</span><span class="n">MLOCK_ONFAULT</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="nd">#[cfg(not(target_os</span> <span class="nd">=</span> <span class="s">"linux"</span><span class="nd">))]</span>
    <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">libc</span><span class="p">::</span><span class="nf">mlock</span><span class="p">(</span><span class="n">addr</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">c_void</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>NUMA-Aware Placement:</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">numa_policies</span><span class="pi">:</span>
  <span class="na">hot_tables</span><span class="pi">:</span> <span class="s2">"</span><span class="s">bind_local"</span>           <span class="c1"># Bind to local NUMA node</span>
  <span class="na">cold_indices</span><span class="pi">:</span> <span class="s2">"</span><span class="s">interleave"</span>         <span class="c1"># Spread across NUMA nodes  </span>
  <span class="na">shared_metadata</span><span class="pi">:</span> <span class="s2">"</span><span class="s">preferred_local"</span> <span class="c1"># Prefer local, allow remote</span>
  
  <span class="na">migration_triggers</span><span class="pi">:</span>
    <span class="na">cpu_imbalance_threshold</span><span class="pi">:</span> <span class="m">0.3</span>     <span class="c1"># Migrate if 30%+ imbalanced</span>
    <span class="na">memory_pressure_threshold</span><span class="pi">:</span> <span class="m">0.85</span>  <span class="c1"># Migrate if 85%+ memory used</span>
    <span class="na">cross_numa_latency_penalty</span><span class="pi">:</span> <span class="m">2.5</span>  <span class="c1"># 2.5x latency penalty factor</span>
</code></pre></div></div>

<p><strong>Huge Page Optimization:</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">huge_pages</span><span class="pi">:</span>
  <span class="na">transparent_huge_pages</span><span class="pi">:</span> <span class="s2">"</span><span class="s">madvise"</span> <span class="c1"># THP only on explicit hint</span>
  <span class="na">explicit_1gb_pages</span><span class="pi">:</span> <span class="kc">true</span>         <span class="c1"># Use 1GB pages for large scans</span>
  <span class="na">explicit_2mb_pages</span><span class="pi">:</span> <span class="kc">true</span>         <span class="c1"># Use 2MB pages for indices</span>
  
  <span class="na">allocation_strategy</span><span class="pi">:</span>
    <span class="na">large_sequential_scans</span><span class="pi">:</span> <span class="s2">"</span><span class="s">1GB"</span>   <span class="c1"># 1GB pages for &gt; 100MB scans</span>
    <span class="na">btree_indices</span><span class="pi">:</span> <span class="s2">"</span><span class="s">2MB"</span>           <span class="c1"># 2MB pages for B-tree nodes</span>
    <span class="na">random_access_metadata</span><span class="pi">:</span> <span class="s2">"</span><span class="s">4KB"</span>  <span class="c1"># Standard pages for metadata</span>
</code></pre></div></div>

<h3 id="73-object-fragmentation-and-slicing">7.3 Object Fragmentation and Slicing</h3>

<h4 id="731-extent-based-storage">7.3.1 Extent-Based Storage</h4>

<p><strong>Tables - Column-Oriented Slicing:</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">table_slicing</span><span class="pi">:</span>
  <span class="na">extent_size</span><span class="pi">:</span> <span class="s2">"</span><span class="s">64MB"</span>              <span class="c1"># Base extent size</span>
  <span class="na">hot_column_extent_size</span><span class="pi">:</span> <span class="s2">"</span><span class="s">16MB"</span>   <span class="c1"># Smaller extents for hot columns</span>
  <span class="na">rowgroup_size</span><span class="pi">:</span> <span class="s2">"</span><span class="s">1M"</span>              <span class="c1"># 1M rows per group</span>
  
  <span class="na">slicing_policies</span><span class="pi">:</span>
    <span class="na">by_access_pattern</span><span class="pi">:</span>
      <span class="na">hot_columns</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">user_id"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">timestamp"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">amount"</span><span class="pi">]</span>
      <span class="na">cold_columns</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">description"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">metadata"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">audit_log"</span><span class="pi">]</span>
    
    <span class="na">by_query_selectivity</span><span class="pi">:</span>
      <span class="na">high_selectivity</span><span class="pi">:</span> <span class="s2">"</span><span class="s">16MB"</span>       <span class="c1"># Small extents for filters</span>
      <span class="na">scan_heavy</span><span class="pi">:</span> <span class="s2">"</span><span class="s">256MB"</span>            <span class="c1"># Large extents for scans</span>
</code></pre></div></div>

<p><strong>Graphs - Community-Based Partitioning:</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">graph_slicing</span><span class="pi">:</span>
  <span class="na">partition_strategy</span><span class="pi">:</span> <span class="s2">"</span><span class="s">community_detection"</span>
  <span class="na">max_partition_size</span><span class="pi">:</span> <span class="s2">"</span><span class="s">128MB"</span>
  <span class="na">min_partition_size</span><span class="pi">:</span> <span class="s2">"</span><span class="s">4MB"</span>
  
  <span class="na">edge_handling</span><span class="pi">:</span>
    <span class="na">intra_partition_edges</span><span class="pi">:</span> <span class="s2">"</span><span class="s">csr_blocks"</span>    <span class="c1"># Compressed sparse row</span>
    <span class="na">cross_partition_edges</span><span class="pi">:</span> <span class="s2">"</span><span class="s">portal_nodes"</span>  <span class="c1"># Lightweight connectors</span>
    
  <span class="na">property_storage</span><span class="pi">:</span>
    <span class="na">node_properties</span><span class="pi">:</span> <span class="s2">"</span><span class="s">separate_extents"</span>    <span class="c1"># Independent lifecycle</span>
    <span class="na">edge_properties</span><span class="pi">:</span> <span class="s2">"</span><span class="s">inline_with_csr"</span>     <span class="c1"># Co-located with edges</span>
</code></pre></div></div>

<h4 id="732-extent-indices-and-connection-graph">7.3.2 Extent Indices and Connection Graph</h4>

<p><strong>Extent Mapping Structure:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">#[derive(Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">ExtentRef</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">file_id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>          <span class="c1">// Which file contains this extent</span>
    <span class="k">pub</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>           <span class="c1">// Byte offset within file</span>
    <span class="k">pub</span> <span class="n">len</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>              <span class="c1">// Length in bytes</span>
    <span class="k">pub</span> <span class="n">flags</span><span class="p">:</span> <span class="n">ExtentFlags</span><span class="p">,</span>    <span class="c1">// HOT, COMPRESSED, HUGEPAGE, etc.</span>
<span class="p">}</span>

<span class="nd">#[bitflags]</span>
<span class="nd">#[repr(u32)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">ExtentFlags</span> <span class="p">{</span>
    <span class="n">HOT</span>         <span class="o">=</span> <span class="mi">0b00000001</span><span class="p">,</span>  <span class="c1">// Frequently accessed</span>
    <span class="n">COMPRESSED</span>  <span class="o">=</span> <span class="mi">0b00000010</span><span class="p">,</span>  <span class="c1">// Uses compression</span>
    <span class="n">HUGEPAGE</span>    <span class="o">=</span> <span class="mi">0b00000100</span><span class="p">,</span>  <span class="c1">// Prefers huge pages</span>
    <span class="n">NUMA_LOCAL</span>  <span class="o">=</span> <span class="mi">0b00001000</span><span class="p">,</span>  <span class="c1">// NUMA-local placement</span>
    <span class="n">PREFETCH</span>    <span class="o">=</span> <span class="mi">0b00010000</span><span class="p">,</span>  <span class="c1">// Prefetch adjacent extents</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Connection and Prefetch Hints:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">ExtentConnections</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">forward_extents</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ExtentRef</span><span class="o">&gt;</span><span class="p">,</span>   <span class="c1">// Next extents in sequence</span>
    <span class="k">pub</span> <span class="n">back_extents</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ExtentRef</span><span class="o">&gt;</span><span class="p">,</span>      <span class="c1">// Previous extents  </span>
    <span class="k">pub</span> <span class="n">hot_neighbors</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ExtentRef</span><span class="o">&gt;</span><span class="p">,</span>     <span class="c1">// Frequently co-accessed</span>
    <span class="k">pub</span> <span class="n">prefetch_weight</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>              <span class="c1">// 0.0-1.0 prefetch priority</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="74-lifetime-management-and-garbage-collection">7.4 Lifetime Management and Garbage Collection</h3>

<h4 id="741-lifetime-classes">7.4.1 Lifetime Classes</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">LifetimeClass</span> <span class="p">{</span>
    <span class="n">Ephemeral</span><span class="p">,</span>    <span class="c1">// Per-operator scratch, dropped at operator end</span>
    <span class="n">Session</span><span class="p">,</span>      <span class="c1">// Query/session caches, TTL-based expiration</span>
    <span class="n">Task</span><span class="p">,</span>         <span class="c1">// Analytical job windows, phase-based lifecycle  </span>
    <span class="n">LongLived</span><span class="p">,</span>    <span class="c1">// Base data and indices, manual management</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">LifetimePolicy</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">class</span><span class="p">:</span> <span class="n">LifetimeClass</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">ttl_ms</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">,</span>           <span class="c1">// Time-to-live in milliseconds</span>
    <span class="k">pub</span> <span class="n">max_memory_mb</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">,</span>    <span class="c1">// Memory limit for this class</span>
    <span class="k">pub</span> <span class="n">gc_trigger</span><span class="p">:</span> <span class="n">GcTrigger</span><span class="p">,</span>         <span class="c1">// When to start garbage collection</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">enum</span> <span class="n">GcTrigger</span> <span class="p">{</span>
    <span class="n">TimeBasedTtl</span><span class="p">,</span>                      <span class="c1">// TTL expiration</span>
    <span class="nf">MemoryPressure</span><span class="p">(</span><span class="nb">f32</span><span class="p">),</span>               <span class="c1">// Memory usage threshold (0.0-1.0)</span>
    <span class="n">OperatorCompletion</span><span class="p">,</span>                <span class="c1">// End of query operator</span>
    <span class="n">ExplicitDrop</span><span class="p">,</span>                      <span class="c1">// Manual deallocation</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="742-epoch-based-reclamation">7.4.2 Epoch-Based Reclamation</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">EpochManager</span> <span class="p">{</span>
    <span class="n">current_epoch</span><span class="p">:</span> <span class="n">AtomicU64</span><span class="p">,</span>
    <span class="n">retire_lists</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">RetiredSlice</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>  <span class="c1">// Per-epoch retire list</span>
    <span class="n">reader_epochs</span><span class="p">:</span> <span class="n">DashMap</span><span class="o">&lt;</span><span class="n">ThreadId</span><span class="p">,</span> <span class="nb">u64</span><span class="o">&gt;</span><span class="p">,</span>        <span class="c1">// Active reader epochs</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">RetiredSlice</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">slice_key</span><span class="p">:</span> <span class="n">PinKey</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">retire_epoch</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">unmap_fn</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">FnOnce</span><span class="p">()</span> <span class="o">+</span> <span class="nb">Send</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">EpochManager</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">enter_read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ReadGuard</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">epoch</span> <span class="o">=</span> <span class="k">self</span><span class="py">.current_epoch</span><span class="nf">.load</span><span class="p">(</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Acquire</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.reader_epochs</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">current</span><span class="p">()</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">epoch</span><span class="p">);</span>
        <span class="n">ReadGuard</span> <span class="p">{</span> <span class="n">epoch_mgr</span><span class="p">:</span> <span class="k">self</span> <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">retire_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">slice</span><span class="p">:</span> <span class="n">RetiredSlice</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">epoch</span> <span class="o">=</span> <span class="k">self</span><span class="py">.current_epoch</span><span class="nf">.load</span><span class="p">(</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Acquire</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.retire_lists</span><span class="p">[</span><span class="n">epoch</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">%</span> <span class="k">self</span><span class="py">.retire_lists</span><span class="nf">.len</span><span class="p">()]</span>
            <span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.push</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">advance_epoch</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">new_epoch</span> <span class="o">=</span> <span class="k">self</span><span class="py">.current_epoch</span><span class="nf">.fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">AcqRel</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.gc_old_slices</span><span class="p">(</span><span class="n">new_epoch</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="75-core-apis">7.5 Core APIs</h3>

<h4 id="751-pinmanager-interface">7.5.1 PinManager Interface</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">Hash,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nf">PinKey</span><span class="p">(</span><span class="k">pub</span> <span class="nb">u64</span><span class="p">);</span>  <span class="c1">// Logical object/slice identifier</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">PinPriority</span> <span class="p">{</span>
    <span class="n">Background</span><span class="p">,</span>              <span class="c1">// Best-effort, can be evicted anytime</span>
    <span class="n">QueryCritical</span><span class="p">,</span>          <span class="c1">// Important for query performance  </span>
    <span class="n">TailLatencyCritical</span><span class="p">,</span>    <span class="c1">// Must stay pinned for low tail latency</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PinOpts</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">priority</span><span class="p">:</span> <span class="n">PinPriority</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">numa_prefer</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">,</span>        <span class="c1">// NUMA node preference</span>
    <span class="k">pub</span> <span class="n">use_hugepages</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>             <span class="c1">// Request huge page allocation</span>
    <span class="k">pub</span> <span class="n">onfault</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>                   <span class="c1">// Use mlock2(MLOCK_ONFAULT) if available</span>
    <span class="k">pub</span> <span class="n">lifetime_class</span><span class="p">:</span> <span class="n">LifetimeClass</span><span class="p">,</span>   <span class="c1">// Lifetime management class</span>
    <span class="k">pub</span> <span class="n">prefetch_adjacent</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>        <span class="c1">// Number of adjacent extents to prefetch</span>
    <span class="k">pub</span> <span class="n">ttl_ms</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">,</span>             <span class="c1">// Auto-demote after TTL</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">PinManager</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="p">{</span>
    <span class="cd">/// Pin a slice with the given options</span>
    <span class="k">fn</span> <span class="nf">pin_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">PinKey</span><span class="p">,</span> <span class="n">opts</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PinOpts</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
    
    <span class="cd">/// Unpin a slice, allowing it to be swapped out</span>
    <span class="k">fn</span> <span class="nf">unpin_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">PinKey</span><span class="p">);</span>
    
    <span class="cd">/// Change the priority of an already pinned slice</span>
    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">PinKey</span><span class="p">,</span> <span class="n">new_priority</span><span class="p">:</span> <span class="n">PinPriority</span><span class="p">);</span>
    
    <span class="cd">/// Get current pinning statistics</span>
    <span class="k">fn</span> <span class="nf">stats</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">PinStats</span><span class="p">;</span>
    
    <span class="cd">/// Check if a slice is currently pinned</span>
    <span class="k">fn</span> <span class="nf">is_pinned</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">PinKey</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">;</span>
    
    <span class="cd">/// Force garbage collection of expired pins</span>
    <span class="k">fn</span> <span class="nf">gc_expired</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PinStats</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">total_pinned_bytes</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">total_pinned_count</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">budget_used_bytes</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">budget_total_bytes</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">huge_page_bytes</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">numa_local_bytes</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">by_priority</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">PinPriority</span><span class="p">,</span> <span class="n">PinPriorityStats</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PinPriorityStats</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">pinned_count</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">pinned_bytes</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">eviction_count</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">average_pin_time_ms</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="752-extentindex-interface">7.5.2 ExtentIndex Interface</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">ExtentIndex</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="p">{</span>
    <span class="cd">/// Look up extents for a table's row group</span>
    <span class="k">fn</span> <span class="nf">lookup_rowgroup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">table_id</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="n">rg_id</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">ExtentRef</span><span class="p">];</span>
    
    <span class="cd">/// Look up extents for a graph partition</span>
    <span class="k">fn</span> <span class="nf">lookup_graph_partition</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">part_id</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">ExtentRef</span><span class="p">];</span>
    
    <span class="cd">/// Look up extents for a vector index list</span>
    <span class="k">fn</span> <span class="nf">lookup_vector_list</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">list_id</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">ExtentRef</span><span class="p">];</span>
    
    <span class="cd">/// Get connection information for prefetching</span>
    <span class="k">fn</span> <span class="nf">get_connections</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">extent</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ExtentRef</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">ExtentConnections</span><span class="o">&gt;</span><span class="p">;</span>
    
    <span class="cd">/// Update hotness statistics for an extent</span>
    <span class="k">fn</span> <span class="nf">record_access</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">extent</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ExtentRef</span><span class="p">,</span> <span class="n">access_type</span><span class="p">:</span> <span class="n">AccessType</span><span class="p">);</span>
    
    <span class="cd">/// Get extents that should be considered for pinning</span>
    <span class="k">fn</span> <span class="nf">get_hot_extents</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">ExtentRef</span><span class="p">,</span> <span class="nb">f32</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// (extent, hotness_score)</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">AccessType</span> <span class="p">{</span>
    <span class="n">SequentialRead</span><span class="p">,</span>
    <span class="n">RandomRead</span><span class="p">,</span> 
    <span class="n">Write</span><span class="p">,</span>
    <span class="n">Scan</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="76-query-engine-integration">7.6 Query Engine Integration</h3>

<h4 id="761-planner-hints-and-prefetching">7.6.1 Planner Hints and Prefetching</h4>

<p><strong>SQL Query Planning:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">QueryPlanHints</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">predicted_rowgroups</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">,</span>     <span class="c1">// Rowgroups likely to be accessed</span>
    <span class="k">pub</span> <span class="n">join_order_extents</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ExtentRef</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// Extents needed for join execution</span>
    <span class="k">pub</span> <span class="n">filter_selectivity</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// Column selectivity estimates</span>
    <span class="k">pub</span> <span class="n">scan_pattern</span><span class="p">:</span> <span class="n">ScanPattern</span><span class="p">,</span>          <span class="c1">// Sequential vs random access</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">enum</span> <span class="n">ScanPattern</span> <span class="p">{</span>
    <span class="n">Sequential</span> <span class="p">{</span> <span class="n">prefetch_distance</span><span class="p">:</span> <span class="nb">usize</span> <span class="p">},</span>
    <span class="n">Random</span> <span class="p">{</span> <span class="n">locality_hint</span><span class="p">:</span> <span class="nb">f32</span> <span class="p">},</span>
    <span class="n">Hybrid</span> <span class="p">{</span> <span class="n">seq_threshold</span><span class="p">:</span> <span class="nb">usize</span> <span class="p">},</span>
<span class="p">}</span>

<span class="c1">// Integration with query planner</span>
<span class="k">impl</span> <span class="n">QueryPlanner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">generate_pin_hints</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">plan</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ExecutionPlan</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PinRequest</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">requests</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        
        <span class="c1">// Pin critical path extents</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="k">in</span> <span class="n">plan</span><span class="nf">.critical_path</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">table_scan</span><span class="p">)</span> <span class="o">=</span> <span class="n">operator</span><span class="nf">.as_table_scan</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">rowgroups</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.estimate_accessed_rowgroups</span><span class="p">(</span><span class="n">table_scan</span><span class="p">);</span>
                <span class="k">for</span> <span class="n">rg_id</span> <span class="k">in</span> <span class="n">rowgroups</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">extents</span> <span class="o">=</span> <span class="k">self</span><span class="py">.extent_index</span><span class="nf">.lookup_rowgroup</span><span class="p">(</span><span class="n">table_scan</span><span class="py">.table_id</span><span class="p">,</span> <span class="n">rg_id</span><span class="p">);</span>
                    <span class="k">for</span> <span class="n">extent</span> <span class="k">in</span> <span class="n">extents</span> <span class="p">{</span>
                        <span class="n">requests</span><span class="nf">.push</span><span class="p">(</span><span class="n">PinRequest</span> <span class="p">{</span>
                            <span class="n">key</span><span class="p">:</span> <span class="nf">PinKey</span><span class="p">(</span><span class="n">extent</span><span class="nf">.as_pin_key</span><span class="p">()),</span>
                            <span class="n">priority</span><span class="p">:</span> <span class="nn">PinPriority</span><span class="p">::</span><span class="n">QueryCritical</span><span class="p">,</span>
                            <span class="n">prefetch_neighbors</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
                        <span class="p">});</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="n">requests</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Graph Traversal Optimization:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">GraphTraversalHints</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">start_partitions</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">,</span>        <span class="c1">// Starting graph partitions</span>
    <span class="k">pub</span> <span class="n">max_hops</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>                   <span class="c1">// Maximum traversal depth</span>
    <span class="k">pub</span> <span class="n">expansion_factor</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>             <span class="c1">// Expected fan-out per hop</span>
    <span class="k">pub</span> <span class="n">community_locality</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>           <span class="c1">// Likelihood of staying in community</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">GraphEngine</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">prepare_traversal</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">hints</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">GraphTraversalHints</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Pin starting partitions</span>
        <span class="k">for</span> <span class="o">&amp;</span><span class="n">part_id</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">hints</span><span class="py">.start_partitions</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">extents</span> <span class="o">=</span> <span class="k">self</span><span class="py">.extent_index</span><span class="nf">.lookup_graph_partition</span><span class="p">(</span><span class="n">part_id</span><span class="p">);</span>
            <span class="k">for</span> <span class="n">extent</span> <span class="k">in</span> <span class="n">extents</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.pin_manager</span><span class="nf">.pin_slice</span><span class="p">(</span>
                    <span class="nf">PinKey</span><span class="p">(</span><span class="n">extent</span><span class="nf">.as_pin_key</span><span class="p">()),</span>
                    <span class="o">&amp;</span><span class="n">PinOpts</span> <span class="p">{</span>
                        <span class="n">priority</span><span class="p">:</span> <span class="nn">PinPriority</span><span class="p">::</span><span class="n">TailLatencyCritical</span><span class="p">,</span>
                        <span class="n">use_hugepages</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
                        <span class="n">prefetch_adjacent</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// Prefetch 2 neighbor partitions</span>
                        <span class="n">lifetime_class</span><span class="p">:</span> <span class="nn">LifetimeClass</span><span class="p">::</span><span class="n">Session</span><span class="p">,</span>
                        <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
                    <span class="p">},</span>
                <span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// Prefetch likely expansion targets</span>
        <span class="k">self</span><span class="nf">.prefetch_expansion_candidates</span><span class="p">(</span><span class="n">hints</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="762-performance-monitoring-and-adaptive-tuning">7.6.2 Performance Monitoring and Adaptive Tuning</h4>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">performance_monitoring</span><span class="pi">:</span>
  <span class="na">metrics</span><span class="pi">:</span>
    <span class="na">page_fault_rate</span><span class="pi">:</span> <span class="s2">"</span><span class="s">per_second"</span>        <span class="c1"># Page faults/sec per extent</span>
    <span class="na">cache_hit_ratio</span><span class="pi">:</span> <span class="s2">"</span><span class="s">percentage"</span>        <span class="c1"># % of accesses hitting pinned memory</span>
    <span class="na">numa_locality_score</span><span class="pi">:</span> <span class="s2">"</span><span class="s">0_to_1"</span>        <span class="c1"># % of accesses that are NUMA-local</span>
    <span class="na">huge_page_utilization</span><span class="pi">:</span> <span class="s2">"</span><span class="s">percentage"</span>  <span class="c1"># % of huge pages in use</span>
    <span class="na">pin_budget_pressure</span><span class="pi">:</span> <span class="s2">"</span><span class="s">0_to_1"</span>       <span class="c1"># How close to pin budget limit</span>
    
  <span class="na">adaptive_thresholds</span><span class="pi">:</span>
    <span class="na">pin_pressure_threshold</span><span class="pi">:</span> <span class="m">0.85</span>         <span class="c1"># Start evicting at 85% budget</span>
    <span class="na">page_fault_spike_threshold</span><span class="pi">:</span> <span class="m">1000</span>     <span class="c1"># Pin more aggressively above 1K faults/sec</span>
    <span class="na">numa_miss_threshold</span><span class="pi">:</span> <span class="m">0.3</span>             <span class="c1"># Rebalance if &gt;30% cross-NUMA accesses</span>
    
  <span class="na">auto_tuning</span><span class="pi">:</span>
    <span class="na">enable_adaptive_pinning</span><span class="pi">:</span> <span class="kc">true</span>        <span class="c1"># Automatically adjust pin priorities</span>
    <span class="na">learning_window_minutes</span><span class="pi">:</span> <span class="m">30</span>          <span class="c1"># Learn access patterns over 30 min</span>
    <span class="na">rebalancing_interval_minutes</span><span class="pi">:</span> <span class="m">10</span>     <span class="c1"># Rebalance NUMA placement every 10 min</span>
</code></pre></div></div>

<p><strong>Adaptive Pin Controller:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">AdaptivePinController</span> <span class="p">{</span>
    <span class="n">pin_manager</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">PinManager</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">extent_index</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">ExtentIndex</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">metrics_collector</span><span class="p">:</span> <span class="n">MetricsCollector</span><span class="p">,</span>
    <span class="n">learning_window</span><span class="p">:</span> <span class="n">Duration</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">AdaptivePinController</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">optimization_loop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">interval</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">interval</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">60</span><span class="p">));</span>
        
        <span class="k">loop</span> <span class="p">{</span>
            <span class="n">interval</span><span class="nf">.tick</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
            
            <span class="c1">// Collect recent access patterns</span>
            <span class="k">let</span> <span class="n">hot_extents</span> <span class="o">=</span> <span class="k">self</span><span class="py">.extent_index</span><span class="nf">.get_hot_extents</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">stats</span> <span class="o">=</span> <span class="k">self</span><span class="py">.pin_manager</span><span class="nf">.stats</span><span class="p">();</span>
            
            <span class="c1">// Check if we need to evict low-priority pins</span>
            <span class="k">if</span> <span class="n">stats</span><span class="py">.budget_used_bytes</span> <span class="k">as</span> <span class="nb">f64</span> <span class="o">/</span> <span class="n">stats</span><span class="py">.budget_total_bytes</span> <span class="k">as</span> <span class="nb">f64</span> <span class="o">&gt;</span> <span class="mf">0.85</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.evict_cold_pins</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hot_extents</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="c1">// Pin newly hot extents</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">hotness</span><span class="p">)</span> <span class="k">in</span> <span class="n">hot_extents</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">hotness</span> <span class="o">&gt;</span> <span class="mf">0.7</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">self</span><span class="py">.pin_manager</span><span class="nf">.is_pinned</span><span class="p">(</span><span class="nf">PinKey</span><span class="p">(</span><span class="n">extent</span><span class="nf">.as_pin_key</span><span class="p">()))</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">priority</span> <span class="o">=</span> <span class="k">if</span> <span class="n">hotness</span> <span class="o">&gt;</span> <span class="mf">0.9</span> <span class="p">{</span>
                        <span class="nn">PinPriority</span><span class="p">::</span><span class="n">TailLatencyCritical</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nn">PinPriority</span><span class="p">::</span><span class="n">QueryCritical</span>
                    <span class="p">};</span>
                    
                    <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="k">self</span><span class="py">.pin_manager</span><span class="nf">.pin_slice</span><span class="p">(</span>
                        <span class="nf">PinKey</span><span class="p">(</span><span class="n">extent</span><span class="nf">.as_pin_key</span><span class="p">()),</span>
                        <span class="o">&amp;</span><span class="n">PinOpts</span> <span class="p">{</span>
                            <span class="n">priority</span><span class="p">,</span>
                            <span class="n">use_hugepages</span><span class="p">:</span> <span class="n">extent</span><span class="py">.len</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="c1">// 2MB+</span>
                            <span class="n">lifetime_class</span><span class="p">:</span> <span class="nn">LifetimeClass</span><span class="p">::</span><span class="n">Task</span><span class="p">,</span>
                            <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
                        <span class="p">},</span>
                    <span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="77-virtual-actor-model-integration">7.7 Virtual Actor Model Integration</h3>

<h4 id="771-actor-centric-memory-management">7.7.1 Actor-Centric Memory Management</h4>

<p>The advanced memory management system integrates seamlessly with Orbit-RS’s virtual actor model, where <strong>actors become the fundamental unit of memory locality and pinning decisions</strong>.</p>

<p><strong>Actor Memory Ownership:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">ActorMemoryManager</span> <span class="p">{</span>
    <span class="cd">/// Pin memory for an actor's persistent state</span>
    <span class="k">fn</span> <span class="nf">pin_actor_state</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">actor_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">AddressableReference</span><span class="p">,</span> <span class="n">priority</span><span class="p">:</span> <span class="n">PinPriority</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
    
    <span class="cd">/// Pin memory for an actor's working set (temporary data)</span>
    <span class="k">fn</span> <span class="nf">pin_actor_working_set</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">actor_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">AddressableReference</span><span class="p">,</span> <span class="n">ttl_ms</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
    
    <span class="cd">/// Unpin all memory associated with an actor (on deactivation)</span>
    <span class="k">fn</span> <span class="nf">unpin_actor_memory</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">actor_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">AddressableReference</span><span class="p">);</span>
    
    <span class="cd">/// Get memory statistics for an actor</span>
    <span class="k">fn</span> <span class="nf">actor_memory_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">actor_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">AddressableReference</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ActorMemoryStats</span><span class="p">;</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">ActorMemoryStats</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">persistent_state_bytes</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">working_set_bytes</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">pinned_extents</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">ExtentRef</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">numa_node</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">last_access</span><span class="p">:</span> <span class="n">Instant</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="772-actor-lifecycle-integration">7.7.2 Actor Lifecycle Integration</h4>

<p><strong>OnActivate - Intelligent Warming:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">orbit_shared</span><span class="p">::</span><span class="nn">addressable</span><span class="p">::{</span><span class="n">Addressable</span><span class="p">,</span> <span class="n">AddressableReference</span><span class="p">};</span>

<span class="nd">#[async_trait]</span>
<span class="n">imppl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Addressable</span><span class="o">&gt;</span> <span class="n">ActorLifecycle</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">on_activate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">actor_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">AddressableReference</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">memory_manager</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.get_memory_manager</span><span class="p">();</span>
        
        <span class="c1">// 1. Pin persistent state based on actor type and access patterns</span>
        <span class="k">match</span> <span class="k">self</span><span class="nf">.get_memory_profile</span><span class="p">()</span> <span class="p">{</span>
            <span class="nn">ActorMemoryProfile</span><span class="p">::</span><span class="n">Hot</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// Critical path actors - pin immediately with tail latency priority</span>
                <span class="n">memory_manager</span><span class="nf">.pin_actor_state</span><span class="p">(</span><span class="n">actor_ref</span><span class="p">,</span> <span class="nn">PinPriority</span><span class="p">::</span><span class="n">TailLatencyCritical</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="nn">ActorMemoryProfile</span><span class="p">::</span><span class="n">Warm</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// Frequently accessed - pin with query critical priority</span>
                <span class="n">memory_manager</span><span class="nf">.pin_actor_state</span><span class="p">(</span><span class="n">actor_ref</span><span class="p">,</span> <span class="nn">PinPriority</span><span class="p">::</span><span class="n">QueryCritical</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="nn">ActorMemoryProfile</span><span class="p">::</span><span class="n">Cold</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// Infrequently accessed - use background priority or no pinning</span>
                <span class="n">memory_manager</span><span class="nf">.pin_actor_state</span><span class="p">(</span><span class="n">actor_ref</span><span class="p">,</span> <span class="nn">PinPriority</span><span class="p">::</span><span class="n">Background</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">},</span>
        <span class="p">}</span>
        
        <span class="c1">// 2. Prefetch connected actors' state based on actor relationships</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">connected_actors</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.get_connected_actors</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">connected_ref</span> <span class="k">in</span> <span class="n">connected_actors</span> <span class="p">{</span>
                <span class="n">memory_manager</span><span class="nf">.prefetch_actor_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">connected_ref</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">on_deactivate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">actor_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">AddressableReference</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Unpin all memory when actor is deactivated</span>
        <span class="k">self</span><span class="nf">.get_memory_manager</span><span class="p">()</span><span class="nf">.unpin_actor_memory</span><span class="p">(</span><span class="n">actor_ref</span><span class="p">);</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">ActorMemoryProfile</span> <span class="p">{</span>
    <span class="n">Hot</span><span class="p">,</span>    <span class="c1">// &lt;1ms response time requirements</span>
    <span class="n">Warm</span><span class="p">,</span>   <span class="c1">// &lt;10ms response time requirements</span>
    <span class="n">Cold</span><span class="p">,</span>   <span class="c1">// &gt;100ms acceptable</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="773-actor-type-specific-memory-strategies">7.7.3 Actor Type-Specific Memory Strategies</h4>

<p><strong>Graph Database Actors:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">orbit_protocols</span><span class="p">::</span><span class="nn">graph_database</span><span class="p">::</span><span class="n">GraphDatabaseActor</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">GraphDatabaseActor</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">get_memory_profile</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ActorMemoryProfile</span> <span class="p">{</span>
        <span class="c1">// Graph traversal actors need hot memory for low-latency path finding</span>
        <span class="nn">ActorMemoryProfile</span><span class="p">::</span><span class="n">Hot</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">get_connected_actors</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AddressableReference</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="c1">// Return neighboring graph partition actors for prefetching</span>
        <span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="nf">.get_adjacent_partition_actors</span><span class="p">())</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">on_activate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">actor_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">AddressableReference</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Pin the graph partition this actor manages</span>
        <span class="k">let</span> <span class="n">partition_id</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.get_partition_id</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">extents</span> <span class="o">=</span> <span class="k">self</span><span class="py">.extent_index</span><span class="nf">.lookup_graph_partition</span><span class="p">(</span><span class="n">partition_id</span><span class="p">);</span>
        
        <span class="k">for</span> <span class="n">extent</span> <span class="k">in</span> <span class="n">extents</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.pin_manager</span><span class="nf">.pin_slice</span><span class="p">(</span>
                <span class="nf">PinKey</span><span class="p">(</span><span class="n">extent</span><span class="nf">.as_pin_key</span><span class="p">()),</span>
                <span class="o">&amp;</span><span class="n">PinOpts</span> <span class="p">{</span>
                    <span class="n">priority</span><span class="p">:</span> <span class="nn">PinPriority</span><span class="p">::</span><span class="n">TailLatencyCritical</span><span class="p">,</span>
                    <span class="n">use_hugepages</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
                    <span class="n">numa_prefer</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="nf">.get_numa_node</span><span class="p">()),</span>
                    <span class="n">lifetime_class</span><span class="p">:</span> <span class="nn">LifetimeClass</span><span class="p">::</span><span class="n">LongLived</span><span class="p">,</span>
                    <span class="n">prefetch_adjacent</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="c1">// Prefetch 3 neighbor partitions</span>
                    <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
                <span class="p">},</span>
            <span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Time Series Actors:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">orbit_protocols</span><span class="p">::</span><span class="nn">time_series</span><span class="p">::</span><span class="n">TimeSeriesActor</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">TimeSeriesActor</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">get_memory_profile</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ActorMemoryProfile</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="nf">.get_query_pattern</span><span class="p">()</span> <span class="p">{</span>
            <span class="nn">QueryPattern</span><span class="p">::</span><span class="n">RealTimeAnalytics</span> <span class="k">=&gt;</span> <span class="nn">ActorMemoryProfile</span><span class="p">::</span><span class="n">Hot</span><span class="p">,</span>
            <span class="nn">QueryPattern</span><span class="p">::</span><span class="n">RecentDataQueries</span> <span class="k">=&gt;</span> <span class="nn">ActorMemoryProfile</span><span class="p">::</span><span class="n">Warm</span><span class="p">,</span>
            <span class="nn">QueryPattern</span><span class="p">::</span><span class="n">HistoricalAnalysis</span> <span class="k">=&gt;</span> <span class="nn">ActorMemoryProfile</span><span class="p">::</span><span class="n">Cold</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">on_activate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">actor_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">AddressableReference</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Pin recent time buckets for real-time queries</span>
        <span class="k">let</span> <span class="n">recent_buckets</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.get_recent_time_buckets</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">3600</span><span class="p">));</span> <span class="c1">// Last hour</span>
        
        <span class="k">for</span> <span class="n">bucket</span> <span class="k">in</span> <span class="n">recent_buckets</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">extents</span> <span class="o">=</span> <span class="k">self</span><span class="py">.extent_index</span><span class="nf">.lookup_time_bucket</span><span class="p">(</span><span class="n">bucket</span><span class="py">.bucket_id</span><span class="p">);</span>
            <span class="k">for</span> <span class="n">extent</span> <span class="k">in</span> <span class="n">extents</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.pin_manager</span><span class="nf">.pin_slice</span><span class="p">(</span>
                    <span class="nf">PinKey</span><span class="p">(</span><span class="n">extent</span><span class="nf">.as_pin_key</span><span class="p">()),</span>
                    <span class="o">&amp;</span><span class="n">PinOpts</span> <span class="p">{</span>
                        <span class="n">priority</span><span class="p">:</span> <span class="nn">PinPriority</span><span class="p">::</span><span class="n">QueryCritical</span><span class="p">,</span>
                        <span class="n">use_hugepages</span><span class="p">:</span> <span class="n">extent</span><span class="py">.len</span> <span class="o">&gt;=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="c1">// 64MB+</span>
                        <span class="n">lifetime_class</span><span class="p">:</span> <span class="nn">LifetimeClass</span><span class="p">::</span><span class="n">Session</span><span class="p">,</span>
                        <span class="n">ttl_ms</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">3600</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">),</span> <span class="c1">// 1 hour TTL</span>
                        <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
                    <span class="p">},</span>
                <span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="774-actor-communication-and-memory-locality">7.7.4 Actor Communication and Memory Locality</h4>

<p><strong>Message-Based Memory Hints:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">orbit_shared</span><span class="p">::</span><span class="nn">actor_communication</span><span class="p">::{</span><span class="n">Message</span><span class="p">,</span> <span class="n">MessageContent</span><span class="p">};</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">MemoryHint</span> <span class="p">{</span>
    <span class="n">WillAccessSoon</span> <span class="p">{</span>
        <span class="n">actor_refs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AddressableReference</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">estimated_delay_ms</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">AccessComplete</span> <span class="p">{</span>
        <span class="n">actor_refs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AddressableReference</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">MigrateActor</span> <span class="p">{</span>
        <span class="n">actor_ref</span><span class="p">:</span> <span class="n">AddressableReference</span><span class="p">,</span>
        <span class="n">target_numa_node</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span>
        <span class="n">reason</span><span class="p">:</span> <span class="n">MigrationReason</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">MigrationReason</span> <span class="p">{</span>
    <span class="n">NumaLocality</span><span class="p">,</span>     <span class="c1">// Move closer to frequently accessed data</span>
    <span class="n">LoadBalancing</span><span class="p">,</span>    <span class="c1">// Distribute load across nodes</span>
    <span class="n">MemoryPressure</span><span class="p">,</span>   <span class="c1">// Move to node with more available memory</span>
<span class="p">}</span>

<span class="c1">// Actors can send memory hints to optimize cross-actor data access</span>
<span class="k">impl</span> <span class="n">ActorCommunication</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">send_memory_hint</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">hint</span><span class="p">:</span> <span class="n">MemoryHint</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">message</span> <span class="o">=</span> <span class="n">Message</span> <span class="p">{</span>
            <span class="n">content</span><span class="p">:</span> <span class="nn">MessageContent</span><span class="p">::</span><span class="nf">MemoryHint</span><span class="p">(</span><span class="n">hint</span><span class="p">),</span>
            <span class="n">target</span><span class="p">:</span> <span class="nn">MessageTarget</span><span class="p">::</span><span class="n">BroadcastToMemoryManagers</span><span class="p">,</span>
            <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
        <span class="p">};</span>
        
        <span class="k">self</span><span class="nf">.send_message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span><span class="k">.await</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>NUMA-Aware Actor Placement:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">ActorPlacementStrategy</span> <span class="p">{</span>
    <span class="n">pin_manager</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">PinManager</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">extent_index</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">ExtentIndex</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">numa_topology</span><span class="p">:</span> <span class="n">NumaTopology</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">ActorPlacementStrategy</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">optimal_placement</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">actor_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">AddressableReference</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">PlacementDecision</span> <span class="p">{</span>
        <span class="c1">// Analyze which extents this actor will likely access</span>
        <span class="k">let</span> <span class="n">predicted_extents</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.predict_actor_extents</span><span class="p">(</span><span class="n">actor_ref</span><span class="p">);</span>
        
        <span class="c1">// Find NUMA node with most of the actor's data already pinned</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">numa_scores</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">extent</span> <span class="k">in</span> <span class="n">predicted_extents</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">numa_node</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.get_extent_numa_placement</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extent</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">numa_scores</span><span class="nf">.entry</span><span class="p">(</span><span class="n">numa_node</span><span class="p">)</span><span class="nf">.or_insert</span><span class="p">(</span><span class="mi">0u64</span><span class="p">)</span> <span class="o">+=</span> <span class="n">extent</span><span class="py">.len</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">let</span> <span class="n">optimal_numa</span> <span class="o">=</span> <span class="n">numa_scores</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.max_by_key</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">score</span><span class="p">)|</span> <span class="o">*</span><span class="n">score</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">node</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">node</span><span class="p">);</span>
        
        <span class="n">PlacementDecision</span> <span class="p">{</span>
            <span class="n">preferred_numa_node</span><span class="p">:</span> <span class="n">optimal_numa</span><span class="p">,</span>
            <span class="n">co_location_actors</span><span class="p">:</span> <span class="k">self</span><span class="nf">.find_co_location_candidates</span><span class="p">(</span><span class="n">actor_ref</span><span class="p">),</span>
            <span class="n">memory_requirements</span><span class="p">:</span> <span class="k">self</span><span class="nf">.estimate_memory_requirements</span><span class="p">(</span><span class="n">actor_ref</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="775-distributed-memory-coordination">7.7.5 Distributed Memory Coordination</h4>

<p><strong>Cross-Node Memory Management:</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">DistributedMemoryCoordinator</span> <span class="p">{</span>
    <span class="n">local_pin_manager</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">PinManager</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">cluster_memory_view</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">ClusterMemoryView</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">replication_manager</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">ReplicationManager</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DistributedMemoryCoordinator</span> <span class="p">{</span>
    <span class="cd">/// Coordinate pinning across multiple nodes for replicated data</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">coordinate_replicated_pinning</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> 
        <span class="n">extent</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ExtentRef</span><span class="p">,</span> 
        <span class="n">priority</span><span class="p">:</span> <span class="n">PinPriority</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">replica_nodes</span> <span class="o">=</span> <span class="k">self</span><span class="py">.replication_manager</span><span class="nf">.get_replica_nodes</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Pin on primary replica with high priority</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">primary_node</span><span class="p">)</span> <span class="o">=</span> <span class="n">replica_nodes</span><span class="py">.primary</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">primary_node</span> <span class="o">==</span> <span class="k">self</span><span class="nf">.get_local_node_id</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.local_pin_manager</span><span class="nf">.pin_slice</span><span class="p">(</span>
                    <span class="nf">PinKey</span><span class="p">(</span><span class="n">extent</span><span class="nf">.as_pin_key</span><span class="p">()),</span>
                    <span class="o">&amp;</span><span class="n">PinOpts</span> <span class="p">{</span>
                        <span class="n">priority</span><span class="p">,</span>
                        <span class="n">use_hugepages</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
                        <span class="n">lifetime_class</span><span class="p">:</span> <span class="nn">LifetimeClass</span><span class="p">::</span><span class="n">LongLived</span><span class="p">,</span>
                        <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
                    <span class="p">},</span>
                <span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.send_remote_pin_request</span><span class="p">(</span><span class="n">primary_node</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span> <span class="n">priority</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// Pin on secondary replicas with lower priority</span>
        <span class="k">for</span> <span class="n">secondary_node</span> <span class="k">in</span> <span class="n">replica_nodes</span><span class="py">.secondaries</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">secondary_priority</span> <span class="o">=</span> <span class="k">match</span> <span class="n">priority</span> <span class="p">{</span>
                <span class="nn">PinPriority</span><span class="p">::</span><span class="n">TailLatencyCritical</span> <span class="k">=&gt;</span> <span class="nn">PinPriority</span><span class="p">::</span><span class="n">QueryCritical</span><span class="p">,</span>
                <span class="nn">PinPriority</span><span class="p">::</span><span class="n">QueryCritical</span> <span class="k">=&gt;</span> <span class="nn">PinPriority</span><span class="p">::</span><span class="n">Background</span><span class="p">,</span>
                <span class="nn">PinPriority</span><span class="p">::</span><span class="n">Background</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span> <span class="c1">// Skip pinning on secondaries</span>
            <span class="p">};</span>
            
            <span class="k">if</span> <span class="n">secondary_node</span> <span class="o">==</span> <span class="k">self</span><span class="nf">.get_local_node_id</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.local_pin_manager</span><span class="nf">.pin_slice</span><span class="p">(</span>
                    <span class="nf">PinKey</span><span class="p">(</span><span class="n">extent</span><span class="nf">.as_pin_key</span><span class="p">()),</span>
                    <span class="o">&amp;</span><span class="n">PinOpts</span> <span class="p">{</span>
                        <span class="n">priority</span><span class="p">:</span> <span class="n">secondary_priority</span><span class="p">,</span>
                        <span class="n">lifetime_class</span><span class="p">:</span> <span class="nn">LifetimeClass</span><span class="p">::</span><span class="n">Task</span><span class="p">,</span>
                        <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
                    <span class="p">},</span>
                <span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.send_remote_pin_request</span><span class="p">(</span><span class="n">secondary_node</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span> <span class="n">secondary_priority</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
    
    <span class="cd">/// Handle actor migration with memory state preservation</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">migrate_actor_with_memory</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> 
        <span class="n">actor_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">AddressableReference</span><span class="p">,</span>
        <span class="n">target_node</span><span class="p">:</span> <span class="n">NodeId</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// 1. Get current memory state</span>
        <span class="k">let</span> <span class="n">memory_stats</span> <span class="o">=</span> <span class="k">self</span><span class="py">.local_pin_manager</span><span class="nf">.get_actor_memory_stats</span><span class="p">(</span><span class="n">actor_ref</span><span class="p">);</span>
        
        <span class="c1">// 2. Pre-warm target node by pinning actor's data there</span>
        <span class="k">for</span> <span class="n">extent</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">memory_stats</span><span class="py">.pinned_extents</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.send_remote_pin_request</span><span class="p">(</span>
                <span class="n">target_node</span><span class="p">,</span> 
                <span class="n">extent</span><span class="p">,</span> 
                <span class="nn">PinPriority</span><span class="p">::</span><span class="n">QueryCritical</span>
            <span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="c1">// 3. Migrate the actor</span>
        <span class="k">self</span><span class="nf">.migrate_actor</span><span class="p">(</span><span class="n">actor_ref</span><span class="p">,</span> <span class="n">target_node</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// 4. Unpin memory on source node (with delay for safety)</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">extent</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">memory_stats</span><span class="py">.pinned_extents</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.local_pin_manager</span><span class="nf">.unpin_slice</span><span class="p">(</span><span class="nf">PinKey</span><span class="p">(</span><span class="n">extent</span><span class="nf">.as_pin_key</span><span class="p">()));</span>
        <span class="p">}</span>
        
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="776-benefits-of-actor-memory-integration">7.7.6 Benefits of Actor-Memory Integration</h4>

<p><strong>1. Natural Locality Boundaries:</strong></p>
<ul>
  <li>Actors define clear ownership boundaries for memory regions</li>
  <li>Pin/unpin decisions align with actor lifecycle (activate/deactivate)</li>
  <li>Actor relationships guide prefetching strategies</li>
</ul>

<p><strong>2. Workload-Aware Optimization:</strong></p>
<ul>
  <li>Different actor types get different memory profiles (hot/warm/cold)</li>
  <li>Graph actors optimize for traversal locality</li>
  <li>Time series actors optimize for temporal locality</li>
  <li>Document actors optimize for key-based access</li>
</ul>

<p><strong>3. Distributed Coordination:</strong></p>
<ul>
  <li>Actor migration triggers coordinated memory management across nodes</li>
  <li>Replication-aware pinning reduces cross-node data access</li>
  <li>Message-based memory hints enable predictive optimization</li>
</ul>

<p><strong>4. Resource Management:</strong></p>
<ul>
  <li>Pin budgets can be allocated per actor type or priority class</li>
  <li>Actor deactivation automatically frees associated memory</li>
  <li>NUMA-aware placement reduces memory access latency</li>
</ul>

<p><strong>5. Performance Guarantees:</strong></p>
<ul>
  <li>Critical path actors get guaranteed memory pinning</li>
  <li>Tail latency SLAs can be enforced at the actor level</li>
  <li>Memory pressure triggers predictable eviction based on actor priorities</li>
</ul>

<h4 id="expected-performance">Expected Performance</h4>

<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>Per Node</th>
      <th>3-Node Cluster Total</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Storage Capacity</strong></td>
      <td>800TB</td>
      <td>2.4PB (1PB usable)</td>
    </tr>
    <tr>
      <td><strong>Memory Usage</strong></td>
      <td>256-512GB</td>
      <td>768GB-1.5TB</td>
    </tr>
    <tr>
      <td><strong>Read Throughput</strong></td>
      <td>4 GB/s</td>
      <td>12 GB/s</td>
    </tr>
    <tr>
      <td><strong>Write Throughput</strong></td>
      <td>4 GB/s</td>
      <td>12 GB/s</td>
    </tr>
    <tr>
      <td><strong>IOPS</strong></td>
      <td>64K</td>
      <td>192K</td>
    </tr>
    <tr>
      <td><strong>Latency</strong></td>
      <td>&lt;10μs</td>
      <td>&lt;15μs (cross-node)</td>
    </tr>
  </tbody>
</table>

<h4 id="cost-analysis-3-node-vs-traditional">Cost Analysis (3-Node vs Traditional)</h4>

<table>
  <thead>
    <tr>
      <th>Approach</th>
      <th>Nodes</th>
      <th>Monthly Cost</th>
      <th>Savings</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>3-Node Ultra-Dense</strong></td>
      <td>3</td>
      <td><strong>$18K</strong></td>
      <td><strong>$55K saved</strong></td>
    </tr>
    <tr>
      <td>Traditional 50-Node</td>
      <td>50</td>
      <td>$50K</td>
      <td>Baseline</td>
    </tr>
    <tr>
      <td>Traditional 100-Node</td>
      <td>100</td>
      <td>$73K</td>
      <td>Reference</td>
    </tr>
  </tbody>
</table>

<p><strong>Benefits of 3-Node Approach:</strong></p>
<ul>
  <li><strong>94% fewer nodes</strong> than traditional 50-node deployment</li>
  <li><strong>$55K/month savings</strong> vs 50-node cluster</li>
  <li><strong>Simplified operations</strong> with only 3 nodes to manage</li>
  <li><strong>Higher density</strong> utilization per node</li>
  <li><strong>Reduced network complexity</strong> with fewer inter-node connections</li>
</ul>

<h3 id="5-bare-metal-deployment">5. Bare Metal Deployment</h3>

<p>For maximum performance on dedicated hardware:</p>

<p><strong>Hardware Specifications:</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">recommendedHardware</span><span class="pi">:</span>
  <span class="na">cpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">AMD</span><span class="nv"> </span><span class="s">EPYC</span><span class="nv"> </span><span class="s">7763</span><span class="nv"> </span><span class="s">or</span><span class="nv"> </span><span class="s">Intel</span><span class="nv"> </span><span class="s">Xeon</span><span class="nv"> </span><span class="s">Gold</span><span class="nv"> </span><span class="s">6338"</span>
  <span class="na">cores</span><span class="pi">:</span> <span class="s2">"</span><span class="s">64+</span><span class="nv"> </span><span class="s">cores</span><span class="nv"> </span><span class="s">(128+</span><span class="nv"> </span><span class="s">threads)"</span>
  <span class="na">memory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">512GB+</span><span class="nv"> </span><span class="s">DDR4-3200"</span>
  <span class="na">storage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Multiple</span><span class="nv"> </span><span class="s">NVMe</span><span class="nv"> </span><span class="s">Gen4</span><span class="nv"> </span><span class="s">drives</span><span class="nv"> </span><span class="s">(Samsung</span><span class="nv"> </span><span class="s">PM1735)"</span>
  <span class="na">network</span><span class="pi">:</span> <span class="s2">"</span><span class="s">100Gbps</span><span class="nv"> </span><span class="s">Ethernet</span><span class="nv"> </span><span class="s">or</span><span class="nv"> </span><span class="s">InfiniBand"</span>
  <span class="na">numa</span><span class="pi">:</span> <span class="s2">"</span><span class="s">2-4</span><span class="nv"> </span><span class="s">socket</span><span class="nv"> </span><span class="s">configuration"</span>
</code></pre></div></div>

<p><strong>System Preparation:</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">#!/bin/bash</span>
<span class="c"># bare-metal-setup.sh</span>

<span class="c"># Configure BIOS settings (manufacturer-specific)</span>
<span class="c"># - Enable NUMA</span>
<span class="c"># - Configure memory interleaving</span>
<span class="c"># - Enable huge page support</span>
<span class="c"># - Optimize CPU P-states</span>

<span class="c"># Install optimized kernel</span>
<span class="c"># Ubuntu example:</span>
apt <span class="nb">install </span>linux-image-5.15.0-generic-hwe-20.04

<span class="c"># Configure huge pages permanently  </span>
<span class="nb">echo</span> <span class="s2">"vm.nr_hugepages=32768"</span> <span class="o">&gt;&gt;</span> /etc/sysctl.conf  <span class="c"># 64GB of 2MB pages</span>
<span class="nb">echo</span> <span class="s2">"kernel.shmmax=68719476736"</span> <span class="o">&gt;&gt;</span> /etc/sysctl.conf

<span class="c"># Configure NUMA balancing</span>
<span class="nb">echo</span> <span class="s2">"kernel.numa_balancing=1"</span> <span class="o">&gt;&gt;</span> /etc/sysctl.conf
<span class="nb">echo</span> <span class="s2">"vm.zone_reclaim_mode=1"</span> <span class="o">&gt;&gt;</span> /etc/sysctl.conf

<span class="c"># Optimize NVMe drives</span>
<span class="k">for </span>drive <span class="k">in</span> /dev/nvme<span class="k">*</span>n1<span class="p">;</span> <span class="k">do
    </span><span class="nb">echo </span>none <span class="o">&gt;</span> /sys/block/<span class="si">$(</span><span class="nb">basename</span> <span class="nv">$drive</span><span class="si">)</span>/queue/scheduler
    <span class="nb">echo </span>1 <span class="o">&gt;</span> /sys/block/<span class="si">$(</span><span class="nb">basename</span> <span class="nv">$drive</span><span class="si">)</span>/queue/nomerges
<span class="k">done</span>

<span class="c"># Configure CPU governor</span>
<span class="nb">echo </span>performance <span class="o">&gt;</span> /sys/devices/system/cpu/cpu<span class="k">*</span>/cpufreq/scaling_governor

<span class="c"># Setup RAID 0 across multiple NVMe drives for maximum performance</span>
mdadm <span class="nt">--create</span> /dev/md0 <span class="nt">--level</span><span class="o">=</span>0 <span class="nt">--raid-devices</span><span class="o">=</span>4 /dev/nvme[0-3]n1
mkfs.ext4 <span class="nt">-F</span> /dev/md0
mount <span class="nt">-o</span> noatime,nodiratime,data<span class="o">=</span>writeback /dev/md0 /mnt/orbit-data
</code></pre></div></div>

<h2 id="performance-analysis">Performance Analysis</h2>

<h3 id="expected-performance-improvements">Expected Performance Improvements</h3>

<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>Traditional</th>
      <th>Memory-Mapped</th>
      <th>Improvement</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Nodes Required</strong></td>
      <td>100-200</td>
      <td>30-50</td>
      <td>3-4x reduction</td>
    </tr>
    <tr>
      <td><strong>RAM per Node</strong></td>
      <td>64-128GB</td>
      <td>32-64GB</td>
      <td>50% reduction</td>
    </tr>
    <tr>
      <td><strong>Read Latency</strong></td>
      <td>10-50μs</td>
      <td>2-10μs</td>
      <td>2-5x faster</td>
    </tr>
    <tr>
      <td><strong>Write Latency</strong></td>
      <td>50-200μs</td>
      <td>5-20μs</td>
      <td>5-10x faster</td>
    </tr>
    <tr>
      <td><strong>Memory Efficiency</strong></td>
      <td>60%</td>
      <td>85%</td>
      <td>25% better</td>
    </tr>
    <tr>
      <td><strong>Cost per Month</strong></td>
      <td>$100K</td>
      <td>$73K</td>
      <td>$27K savings</td>
    </tr>
  </tbody>
</table>

<h3 id="benchmark-scenarios">Benchmark Scenarios</h3>

<h4 id="1-actor-lease-operations">1. Actor Lease Operations</h4>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Benchmark configuration</span>
<span class="k">const</span> <span class="n">OPERATIONS</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">1_000_000</span><span class="p">;</span>
<span class="k">const</span> <span class="n">CONCURRENCY</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">const</span> <span class="n">LEASE_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span> <span class="c1">// bytes</span>

<span class="c1">// Expected results:</span>
<span class="c1">// - Traditional: 50K ops/sec, 100μs p99 latency</span>
<span class="c1">// - Memory-mapped: 200K ops/sec, 20μs p99 latency</span>
</code></pre></div></div>

<h4 id="2-large-dataset-scans">2. Large Dataset Scans</h4>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Scanning 1TB dataset</span>
<span class="k">const</span> <span class="n">DATASET_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">1_000_000_000_000</span><span class="p">;</span> <span class="c1">// 1TB</span>
<span class="k">const</span> <span class="n">SCAN_PATTERN</span><span class="p">:</span> <span class="n">ScanPattern</span> <span class="o">=</span> <span class="nn">ScanPattern</span><span class="p">::</span><span class="n">Sequential</span><span class="p">;</span>

<span class="c1">// Expected results:</span>
<span class="c1">// - Traditional: 2GB/s throughput, 50% CPU</span>
<span class="c1">// - Memory-mapped: 8GB/s throughput, 30% CPU (OS handles prefetch)</span>
</code></pre></div></div>

<h4 id="3-memory-pressure-tests">3. Memory Pressure Tests</h4>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Simulate memory pressure</span>
<span class="k">const</span> <span class="n">TOTAL_DATA</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">10_000_000_000_000</span><span class="p">;</span> <span class="c1">// 10TB</span>
<span class="k">const</span> <span class="n">AVAILABLE_RAM</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">64_000_000_000</span><span class="p">;</span>   <span class="c1">// 64GB</span>

<span class="c1">// Expected behavior:</span>
<span class="c1">// - Traditional: OOM errors, performance degradation</span>
<span class="c1">// - Memory-mapped: Graceful page eviction, consistent performance</span>
</code></pre></div></div>

<h2 id="security-considerations">Security Considerations</h2>

<h3 id="memory-protection">Memory Protection</h3>

<ol>
  <li><strong>Address Space Layout Randomization (ASLR)</strong>
    <ul>
      <li>Memory-mapped regions should support ASLR</li>
      <li>Random base addresses for security</li>
    </ul>
  </li>
  <li><strong>Memory Encryption</strong>
    <ul>
      <li>Support for Intel TME/SME encryption</li>
      <li>Per-region encryption keys</li>
    </ul>
  </li>
  <li><strong>Access Control</strong>
    <ul>
      <li>Page-level permissions (read/write/execute)</li>
      <li>Integration with existing security model</li>
    </ul>
  </li>
</ol>

<h3 id="implementation">Implementation</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Security configuration for memory-mapped regions</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">MMapSecurityConfig</span> <span class="p">{</span>
    <span class="cd">/// Enable address space randomization</span>
    <span class="k">pub</span> <span class="n">enable_aslr</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="cd">/// Memory encryption settings</span>
    <span class="k">pub</span> <span class="n">encryption</span><span class="p">:</span> <span class="n">MemoryEncryption</span><span class="p">,</span>
    <span class="cd">/// Access control policies</span>
    <span class="k">pub</span> <span class="n">access_control</span><span class="p">:</span> <span class="n">AccessControlPolicy</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">enum</span> <span class="n">MemoryEncryption</span> <span class="p">{</span>
    <span class="nb">None</span><span class="p">,</span>
    <span class="n">SystemDefault</span><span class="p">,</span>
    <span class="n">PerRegion</span> <span class="p">{</span> <span class="n">key_derivation</span><span class="p">:</span> <span class="n">KeyDerivation</span> <span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="testing-strategy">Testing Strategy</h2>

<h3 id="1-unit-tests">1. Unit Tests</h3>
<ul>
  <li>Memory mapping operations</li>
  <li>Configuration parsing</li>
  <li>NUMA topology detection</li>
  <li>Huge page management</li>
  <li>I/O ring operations</li>
</ul>

<h3 id="2-integration-tests">2. Integration Tests</h3>
<ul>
  <li>Full persistence provider functionality</li>
  <li>Kubernetes deployment validation</li>
  <li>Performance regression tests</li>
  <li>Failure recovery scenarios</li>
</ul>

<h3 id="3-performance-tests">3. Performance Tests</h3>
<ul>
  <li>Throughput benchmarks</li>
  <li>Latency measurements</li>
  <li>Memory usage profiling</li>
  <li>Scalability testing</li>
</ul>

<h3 id="4-stress-tests">4. Stress Tests</h3>
<ul>
  <li>Memory pressure scenarios</li>
  <li>High concurrency loads</li>
  <li>Network partition handling</li>
  <li>Hardware failure simulation</li>
</ul>

<h3 id="test-infrastructure">Test Infrastructure</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Comprehensive test suite for mmap architecture</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
    
    <span class="nd">#[tokio::test]</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">test_mmap_provider_basic_operations</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">config</span> <span class="o">=</span> <span class="nn">MMapConfig</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">provider</span> <span class="o">=</span> <span class="nn">MMapPersistenceProvider</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
        
        <span class="c1">// Test basic read/write operations</span>
        <span class="k">let</span> <span class="n">test_data</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
        <span class="n">provider</span><span class="nf">.write_data</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">test_data</span><span class="p">)</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
        
        <span class="k">let</span> <span class="n">read_data</span> <span class="o">=</span> <span class="n">provider</span><span class="nf">.read_data</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">test_data</span><span class="nf">.len</span><span class="p">())</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">test_data</span><span class="p">,</span> <span class="n">read_data</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="nd">#[tokio::test]</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">test_huge_page_allocation</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">config</span> <span class="o">=</span> <span class="nn">MMapConfig</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
        <span class="n">config</span><span class="py">.enable_huge_pages</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">config</span><span class="py">.huge_page_size</span> <span class="o">=</span> <span class="nn">HugePageSize</span><span class="p">::</span><span class="n">Size2MB</span><span class="p">;</span>
        
        <span class="k">let</span> <span class="n">provider</span> <span class="o">=</span> <span class="nn">MMapPersistenceProvider</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
        
        <span class="c1">// Verify huge pages are being used</span>
        <span class="k">let</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">provider</span><span class="nf">.get_memory_stats</span><span class="p">()</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">stats</span><span class="py">.huge_pages_allocated</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="nd">#[tokio::test]</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">test_numa_awareness</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">config</span> <span class="o">=</span> <span class="nn">MMapConfig</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
        <span class="n">config</span><span class="py">.numa_policy</span> <span class="o">=</span> <span class="nn">NumaPolicy</span><span class="p">::</span><span class="n">Local</span><span class="p">;</span>
        
        <span class="k">let</span> <span class="n">provider</span> <span class="o">=</span> <span class="nn">MMapPersistenceProvider</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
        
        <span class="c1">// Verify NUMA-local allocation</span>
        <span class="k">let</span> <span class="n">topology</span> <span class="o">=</span> <span class="nn">NumaTopology</span><span class="p">::</span><span class="nf">detect</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">if</span> <span class="n">topology</span><span class="py">.node_count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">provider</span><span class="nf">.get_numa_stats</span><span class="p">()</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="nd">assert!</span><span class="p">(</span><span class="n">stats</span><span class="py">.local_allocations</span> <span class="o">&gt;</span> <span class="n">stats</span><span class="py">.remote_allocations</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="migration-path">Migration Path</h2>

<h3 id="from-existing-backends">From Existing Backends</h3>

<h4 id="1-assessment-phase">1. Assessment Phase</h4>
<ul>
  <li>Analyze current data size and access patterns</li>
  <li>Estimate resource requirements for mmap deployment</li>
  <li>Plan migration timeline and rollback procedures</li>
</ul>

<h4 id="2-parallel-deployment">2. Parallel Deployment</h4>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Migration configuration</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">MigrationConfig</span> <span class="p">{</span>
    <span class="cd">/// Source persistence backend</span>
    <span class="k">pub</span> <span class="n">source_backend</span><span class="p">:</span> <span class="n">BackendType</span><span class="p">,</span>
    <span class="cd">/// Target mmap configuration</span>
    <span class="k">pub</span> <span class="n">target_config</span><span class="p">:</span> <span class="n">MMapConfig</span><span class="p">,</span>
    <span class="cd">/// Migration batch size</span>
    <span class="k">pub</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="cd">/// Validation settings</span>
    <span class="k">pub</span> <span class="n">validation</span><span class="p">:</span> <span class="n">ValidationConfig</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/// Migration orchestrator</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">MigrationOrchestrator</span> <span class="p">{</span>
    <span class="n">source</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">PersistenceProvider</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">MMapPersistenceProvider</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">MigrationConfig</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">MigrationOrchestrator</span> <span class="p">{</span>
    <span class="cd">/// Execute data migration</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">migrate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">OrbitResult</span><span class="o">&lt;</span><span class="n">MigrationReport</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">report</span> <span class="o">=</span> <span class="nn">MigrationReport</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        
        <span class="c1">// Phase 1: Copy existing data</span>
        <span class="k">self</span><span class="nf">.copy_data_phase</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">report</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Phase 2: Sync incremental changes</span>
        <span class="k">self</span><span class="nf">.sync_changes_phase</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">report</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="c1">// Phase 3: Switch traffic</span>
        <span class="k">self</span><span class="nf">.switch_traffic_phase</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">report</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        
        <span class="nf">Ok</span><span class="p">(</span><span class="n">report</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="3-validation-and-cutover">3. Validation and Cutover</h4>
<ul>
  <li>Data integrity verification</li>
  <li>Performance validation</li>
  <li>Gradual traffic migration</li>
  <li>Rollback capabilities</li>
</ul>

<h2 id="open-questions">Open Questions</h2>

<h3 id="technical-questions">Technical Questions</h3>

<ol>
  <li><strong>Kernel Version Requirements</strong>: What’s the minimum kernel version for optimal mmap performance?</li>
  <li><strong>Container Support</strong>: How well do memory-mapped files work in containerized environments?</li>
  <li><strong>Cross-Platform</strong>: What’s the performance difference between Linux, Windows, and macOS?</li>
  <li><strong>Storage Types</strong>: How do different storage types (NVMe, SATA SSD, cloud block storage) affect performance?</li>
</ol>

<h3 id="operational-questions">Operational Questions</h3>

<ol>
  <li><strong>Backup Strategy</strong>: How to backup memory-mapped files efficiently?</li>
  <li><strong>Disaster Recovery</strong>: What’s the recovery time for large mmap regions?</li>
  <li><strong>Monitoring</strong>: What metrics are most important for mmap-based systems?</li>
  <li><strong>Capacity Planning</strong>: How to predict memory and storage requirements?</li>
</ol>

<h3 id="future-considerations">Future Considerations</h3>

<ol>
  <li><strong>Hardware Trends</strong>: How will future CPU/memory/storage developments affect this architecture?</li>
  <li><strong>Cloud Native</strong>: Integration with cloud-native storage solutions</li>
  <li><strong>Edge Computing</strong>: Applicability to edge deployment scenarios</li>
  <li><strong>Machine Learning</strong>: Optimizations for ML/AI workloads</li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<p>The memory-mapped file architecture represents a significant opportunity to improve orbit-rs’s scalability and cost-effectiveness for large-scale deployments. By leveraging modern hardware capabilities and operating system optimizations, we can achieve better performance with dramatically reduced resource requirements.</p>

<p>The proposed implementation plan balances ambitious performance goals with practical development milestones. The extensive configuration system ensures the architecture can adapt to various deployment scenarios while maintaining operational simplicity.</p>

<p>Success metrics for this RFC include:</p>
<ul>
  <li>50-75% reduction in infrastructure costs</li>
  <li>3x reduction in required nodes for petabyte-scale deployments</li>
  <li>Improved performance across all key metrics</li>
  <li>Successful production deployments within 6 months</li>
</ul>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/index.html">Linux Memory Management Documentation</a></li>
  <li><a href="https://kernel.dk/io_uring.pdf">io_uring Documentation</a></li>
  <li><a href="https://www.kernel.org/doc/html/latest/vm/numa.html">NUMA Optimization Guide</a></li>
  <li><a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html">Transparent Huge Pages</a></li>
  <li><a href="https://nvmexpress.org/resources/">High Performance Computing with NVMe</a></li>
</ul>
