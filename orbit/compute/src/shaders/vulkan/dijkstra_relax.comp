#version 450

// GPU-Accelerated Dijkstra's Shortest Path - Edge Relaxation Kernel
// Each work item processes one node to relax its outgoing edges

layout(local_size_x = 256) in;

// Graph structure
layout(set = 0, binding = 0) readonly buffer EdgeArray {
    uint edges[];
};

layout(set = 0, binding = 1) readonly buffer EdgeOffset {
    uint offsets[];
};

layout(set = 0, binding = 2) readonly buffer EdgeWeights {
    float weights[];
};

// Distance array (atomic access for relaxation)
layout(set = 0, binding = 3) buffer Distances {
    float distances[];
};

// Parent array for path reconstruction
layout(set = 0, binding = 4) buffer Parent {
    uint parent[];
};

// Active nodes mask (optimization)
layout(set = 0, binding = 5) readonly buffer ActiveMask {
    uint active_mask[];
};

// Changed flag (atomic counter for convergence detection)
layout(set = 0, binding = 6) buffer Changed {
    uint changed;
};

// Parameters
layout(set = 0, binding = 7) uniform Params {
    uint node_count;
};

void main() {
    uint id = gl_GlobalInvocationID.x;

    if (id >= node_count) {
        return;
    }

    // Skip inactive nodes (already processed optimally)
    if (active_mask[id] == 0) {
        return;
    }

    // Get current distance for this node
    float current_dist = distances[id];

    // Skip if node is unreachable (INFINITY represented as max float)
    if (isinf(current_dist)) {
        return;
    }

    uint start_idx = offsets[id];
    uint end_idx = offsets[id + 1];

    // Process all outgoing edges (relax neighbors)
    for (uint i = start_idx; i < end_idx; i++) {
        uint neighbor = edges[i];
        float edge_weight = weights[i];
        float new_dist = current_dist + edge_weight;

        // Read neighbor's current distance
        float old_dist = distances[neighbor];

        // Try to update if we found a shorter path
        if (new_dist < old_dist) {
            // Simple atomic min: read old, write if better
            // Note: This is a simplified version - may have race conditions
            // but they are benign (worst case: suboptimal relaxation order)
            distances[neighbor] = min(distances[neighbor], new_dist);

            // Update parent if we improved the distance
            if (distances[neighbor] == new_dist) {
                parent[neighbor] = id;
                atomicAdd(changed, 1);
            }
        }
    }
}
