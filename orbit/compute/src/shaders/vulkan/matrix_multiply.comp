#version 450

// GPU-Accelerated Matrix Multiplication (GEMM) with Tiling
// Computes C = A × B where:
// - A is M×K (flattened row-major)
// - B is K×N (flattened row-major)
// - C is M×N (flattened row-major)

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) readonly buffer MatrixA {
    float matrix_a[];
};

layout(set = 0, binding = 1) readonly buffer MatrixB {
    float matrix_b[];
};

layout(set = 0, binding = 2) writeonly buffer MatrixC {
    float matrix_c[];
};

layout(set = 0, binding = 3) uniform Params {
    uint M;  // Rows in A and C
    uint N;  // Cols in B and C
    uint K;  // Cols in A, Rows in B
};

// Shared memory for tiling (16×16 tiles)
shared float tile_a[16][16];
shared float tile_b[16][16];

void main() {
    uint row = gl_GlobalInvocationID.y;
    uint col = gl_GlobalInvocationID.x;

    uint local_row = gl_LocalInvocationID.y;
    uint local_col = gl_LocalInvocationID.x;

    // Bounds check
    if (row >= M || col >= N) {
        return;
    }

    float sum = 0.0;

    // Number of tiles needed
    uint num_tiles = (K + 15) / 16;

    // Iterate over tiles
    for (uint tile = 0; tile < num_tiles; tile++) {
        uint tile_offset = tile * 16;

        // Load tile from A into shared memory
        uint a_col = tile_offset + local_col;
        if (row < M && a_col < K) {
            tile_a[local_row][local_col] = matrix_a[row * K + a_col];
        } else {
            tile_a[local_row][local_col] = 0.0;
        }

        // Load tile from B into shared memory
        uint b_row = tile_offset + local_row;
        if (b_row < K && col < N) {
            tile_b[local_row][local_col] = matrix_b[b_row * N + col];
        } else {
            tile_b[local_row][local_col] = 0.0;
        }

        // Synchronize to ensure tiles are loaded
        barrier();

        // Compute partial dot product for this tile
        for (uint k = 0; k < 16; k++) {
            sum += tile_a[local_row][k] * tile_b[k][local_col];
        }

        // Synchronize before loading next tile
        barrier();
    }

    // Write result
    if (row < M && col < N) {
        matrix_c[row * N + col] = sum;
    }
}
