//! Actor proxy generation and utilities

use crate::{ActorReference, InvocationSystem};
use orbit_shared::{Addressable, AddressableReference};
use std::sync::Arc;

/// Macro for generating actor proxy methods
/// This provides a compile-time alternative to Java's dynamic proxies
#[macro_export]
macro_rules! actor_proxy {
    (
        $trait_name:ident {
            $(
                async fn $method:ident($($arg:ident: $arg_type:ty),*) -> $return_type:ty;
            )*
        }
    ) => {
        paste::paste! {
            impl<T: ?Sized> [<$trait_name Proxy>]<T> for ActorReference<T> {
                $(
                    async fn $method(&self, $($arg: $arg_type),*) -> OrbitResult<$return_type> {
                        let args = vec![
                            $(serde_json::to_value($arg).map_err(OrbitError::SerializationError)?),*
                        ];
                        self.invoke(stringify!($method), args).await
                    }
                )*
            }
        }
    };
}

/// Trait for creating actor proxies
pub trait ActorProxy<T: ?Sized> {
    fn create_proxy(
        reference: AddressableReference,
        invocation_system: Arc<InvocationSystem>,
    ) -> ActorReference<T> {
        ActorReference::new(reference, invocation_system)
    }
}

/// Default implementation for any addressable type
impl<T: Addressable + ?Sized> ActorProxy<T> for ActorReference<T> {}

/// Helper trait for creating typed actor references
pub trait ActorReferenceExt<T: ?Sized> {
    fn typed(self) -> ActorReference<T>;
}

impl<T: Addressable + ?Sized> ActorReferenceExt<T> for ActorReference<dyn Addressable> {
    fn typed(self) -> ActorReference<T> {
        ActorReference::new(self.reference().clone(), self.invocation_system.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use async_trait::async_trait;
    use orbit_shared::{Key, OrbitError, OrbitResult};

    // Example actor trait for testing
    #[async_trait]
    trait TestActor: Addressable {
        #[allow(dead_code)]
        async fn greet(&self, name: String) -> OrbitResult<String>;
        #[allow(dead_code)]
        async fn count(&self) -> OrbitResult<i32>;
    }

    // This would be generated by the macro in practice
    trait TestActorProxy<T: ?Sized> {
        async fn greet(&self, name: String) -> OrbitResult<String>;
        #[allow(dead_code)]
        async fn count(&self) -> OrbitResult<i32>;
    }

    // Manual implementation for testing (would be generated by macro)
    impl<T: ?Sized> TestActorProxy<T> for ActorReference<T> {
        async fn greet(&self, name: String) -> OrbitResult<String> {
            let args = vec![serde_json::to_value(name).map_err(OrbitError::SerializationError)?];
            self.invoke("greet", args).await
        }

        async fn count(&self) -> OrbitResult<i32> {
            let args = vec![];
            self.invoke("count", args).await
        }
    }

    #[tokio::test]
    async fn test_actor_proxy() {
        let reference = AddressableReference {
            addressable_type: "TestActor".to_string(),
            key: Key::StringKey {
                key: "test".to_string(),
            },
        };

        let system = Arc::new(InvocationSystem::new(None));
        let actor_ref: ActorReference<dyn TestActor> = ActorReference::new(reference, system);

        // Test method invocation through proxy
        let result = actor_ref.greet("World".to_string()).await.unwrap();
        assert_eq!(result, "Hello from actor!");
    }

    #[test]
    fn test_actor_proxy_trait() {
        let reference = AddressableReference {
            addressable_type: "TestActor".to_string(),
            key: Key::StringKey {
                key: "test".to_string(),
            },
        };
        let system = Arc::new(InvocationSystem::new(None));

        // Test create_proxy method
        let actor_ref: ActorReference<dyn TestActor> =
            ActorReference::<dyn TestActor>::create_proxy(reference, system);

        // Verify the reference was set correctly
        assert_eq!(actor_ref.reference().addressable_type, "TestActor");
        assert_eq!(
            actor_ref.reference().key,
            Key::StringKey {
                key: "test".to_string()
            }
        );
    }

    #[test]
    fn test_actor_reference_ext() {
        let reference = AddressableReference {
            addressable_type: "TestActor".to_string(),
            key: Key::StringKey {
                key: "test".to_string(),
            },
        };
        let system = Arc::new(InvocationSystem::new(None));

        // Create untyped reference
        let untyped_ref: ActorReference<dyn Addressable> =
            ActorReference::new(reference.clone(), system);

        // Convert to typed reference
        let typed_ref: ActorReference<dyn TestActor> = untyped_ref.typed();

        // Verify the reference was preserved correctly
        assert_eq!(typed_ref.reference().addressable_type, "TestActor");
        assert_eq!(typed_ref.reference().key, reference.key);
    }

    #[tokio::test]
    async fn test_proxy_with_different_key_types() {
        let system = Arc::new(InvocationSystem::new(None));

        // Test with StringKey
        let string_ref = AddressableReference {
            addressable_type: "TestActor".to_string(),
            key: Key::StringKey {
                key: "test_string".to_string(),
            },
        };
        let string_actor: ActorReference<dyn TestActor> =
            ActorReference::new(string_ref, system.clone());

        // Test with Int32Key
        let int_ref = AddressableReference {
            addressable_type: "TestActor".to_string(),
            key: Key::Int32Key { key: 123 },
        };
        let int_actor: ActorReference<dyn TestActor> = ActorReference::new(int_ref, system);

        // Test that all proxies can invoke methods
        let result1 = string_actor.greet("String".to_string()).await.unwrap();
        let result2 = int_actor.greet("Int".to_string()).await.unwrap();

        assert_eq!(result1, "Hello from actor!");
        assert_eq!(result2, "Hello from actor!");
    }

    #[tokio::test]
    async fn test_proxy_method_with_no_args() {
        let reference = AddressableReference {
            addressable_type: "TestActor".to_string(),
            key: Key::StringKey {
                key: "test".to_string(),
            },
        };

        let system = Arc::new(InvocationSystem::new(None));
        let actor_ref: ActorReference<dyn TestActor> = ActorReference::new(reference, system);

        // Test method with no arguments
        let result = actor_ref.count().await.unwrap();
        assert_eq!(result, 42);
    }

    #[tokio::test]
    async fn test_proxy_serialization_error() {
        // Define a type that can't be serialized
        #[derive(Debug)]
        struct _NonSerializable {
            _private: std::marker::PhantomData<*const u8>,
        }

        // We can't actually test serialization errors easily with the current setup
        // since String is always serializable, but we can test the structure
        let reference = AddressableReference {
            addressable_type: "TestActor".to_string(),
            key: Key::StringKey {
                key: "test".to_string(),
            },
        };

        let system = Arc::new(InvocationSystem::new(None));
        let actor_ref: ActorReference<dyn TestActor> = ActorReference::new(reference, system);

        // Test with valid serializable input
        let result = actor_ref.greet("Valid".to_string()).await;
        assert!(result.is_ok());
    }
}
