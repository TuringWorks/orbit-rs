<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>OrbitQL Reference | Orbit-RS Documentation</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="OrbitQL Reference" />
<meta name="author" content="TuringWorks" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The Next-Generation Distributed Database System - Production-Ready Multi-Model Platform" />
<meta property="og:description" content="The Next-Generation Distributed Database System - Production-Ready Multi-Model Platform" />
<link rel="canonical" href="https://turingworks.github.io/orbit-rs/ORBITQL_REFERENCE.html" />
<meta property="og:url" content="https://turingworks.github.io/orbit-rs/ORBITQL_REFERENCE.html" />
<meta property="og:site_name" content="Orbit-RS Documentation" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="OrbitQL Reference" />
<meta name="twitter:site" content="@TuringWorksAI" />
<meta name="twitter:creator" content="@TuringWorks" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"TuringWorks"},"description":"The Next-Generation Distributed Database System - Production-Ready Multi-Model Platform","headline":"OrbitQL Reference","url":"https://turingworks.github.io/orbit-rs/ORBITQL_REFERENCE.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/orbit-rs/assets/main.css">
  <link rel="stylesheet" href="/orbit-rs/assets/css/custom.css"><link type="application/atom+xml" rel="alternate" href="https://turingworks.github.io/orbit-rs/feed.xml" title="Orbit-RS Documentation" /></head><body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/orbit-rs/">Orbit-RS Documentation</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/orbit-rs/">Orbit-RS Documentation</a><a class="page-link" href="/orbit-rs/project_overview.html">Orbit-RS: Comprehensive Project Overview</a><a class="page-link" href="/orbit-rs/quick_start.html">Quick Start Guide - Multi-Protocol Database Server</a><a class="page-link" href="/orbit-rs/roadmap/">Development Roadmap</a><a class="page-link" href="/orbit-rs/features/">Orbit-RS Feature Index</a><a class="page-link" href="/orbit-rs/compute-acceleration/">Hardware Acceleration Guide</a><a class="page-link" href="/orbit-rs/contributing.html">Contributing Guide</a><a class="page-link" href="/orbit-rs/overview.html">Architecture Overview</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h1 id="orbitql-reference">OrbitQL Reference</h1>

<p>OrbitQL is Orbit-RS’s native query language designed specifically for multi-model distributed systems. It combines the familiarity of SQL with advanced features for graph traversals, time series analytics, and distributed computing, all optimized for the Orbit actor system.</p>

<h2 id="table-of-contents">Table of Contents</h2>

<ol>
  <li><a href="#overview">Overview</a></li>
  <li><a href="#language-design">Language Design</a></li>
  <li><a href="#basic-syntax">Basic Syntax</a></li>
  <li><a href="#data-models">Data Models</a></li>
  <li><a href="#graph-queries">Graph Queries</a></li>
  <li><a href="#time-series-queries">Time Series Queries</a></li>
  <li><a href="#multi-model-queries">Multi-Model Queries</a></li>
  <li><a href="#distributed-operations">Distributed Operations</a></li>
  <li><a href="#advanced-features">Advanced Features</a></li>
  <li><a href="#performance--optimization">Performance &amp; Optimization</a></li>
  <li><a href="#examples">Examples</a></li>
  <li><a href="#api-reference">API Reference</a></li>
</ol>

<h2 id="overview">Overview</h2>

<p>OrbitQL is designed as a unified query language that brings together:</p>

<ul>
  <li><strong>SQL familiarity</strong>: Standard SQL syntax for basic operations</li>
  <li><strong>Graph extensions</strong>: Native graph traversal and pattern matching</li>
  <li><strong>Time series support</strong>: Built-in temporal operations and analytics</li>
  <li><strong>Actor integration</strong>: Query across distributed actor systems</li>
  <li><strong>Type safety</strong>: Strong typing with compile-time validation</li>
  <li><strong>Performance</strong>: Optimized for distributed execution</li>
</ul>

<h3 id="key-features">Key Features</h3>

<ul>
  <li><strong>Multi-model unified syntax</strong>: Query graphs, documents, time series, and relational data in single queries</li>
  <li><strong>Advanced SQL compatibility</strong>: Full support for CTEs, CASE expressions, window functions, and temporal operations</li>
  <li><strong>Temporal functions</strong>: Native NOW(), INTERVAL, and time-based analytics</li>
  <li><strong>Aggregate enhancements</strong>: COUNT(DISTINCT), conditional aggregates, and complex expressions</li>
  <li><strong>Distributed by design</strong>: Native support for cross-node queries and joins</li>
  <li><strong>Actor-aware</strong>: Direct integration with Orbit’s virtual actor system</li>
  <li><strong>Streaming support</strong>: Handle large result sets with streaming execution</li>
  <li><strong>ACID compliance</strong>: Full transaction support across distributed data</li>
</ul>

<h2 id="language-design">Language Design</h2>

<h3 id="design-principles">Design Principles</h3>

<ol>
  <li><strong>Familiarity</strong>: Build on SQL foundations that developers know</li>
  <li><strong>Extensibility</strong>: Clean extensions for graph and time series operations</li>
  <li><strong>Performance</strong>: Query optimization for distributed systems</li>
  <li><strong>Type Safety</strong>: Compile-time query validation and optimization</li>
  <li><strong>Composability</strong>: Combine different data models seamlessly</li>
</ol>

<h3 id="core-extensions-to-sql">Core Extensions to SQL</h3>

<pre><code class="language-orbitql">-- Traditional SQL
SELECT name, age FROM users WHERE age &gt; 21;

-- Graph traversal extension
SELECT u.name, friend.name 
FROM users u 
TRAVERSE OUTBOUND 1..3 STEPS ON follows TO friend
WHERE u.location = 'NYC';

-- Time series extension
SELECT series_id, AVG(value) OVER TIME WINDOW '1 hour'
FROM metrics 
WHERE timestamp &gt;= NOW() - INTERVAL '24 hours'
GROUP BY TIME BUCKET '1 hour';

-- Multi-model combination
SELECT u.name, ts.avg_temp, COUNT(f.name) as friend_count
FROM users u
JOIN TimeSeries ts ON u.sensor_id = ts.series_id
TRAVERSE OUTBOUND 1..1 STEPS ON follows TO f
WHERE ts.timestamp &gt;= NOW() - INTERVAL '1 hour'
GROUP BY u.id, TIME BUCKET '15 minutes';
</code></pre>

<h2 id="basic-syntax">Basic Syntax</h2>

<h3 id="query-structure">Query Structure</h3>

<pre><code class="language-orbitql">[WITH recursive_cte AS (...)]
SELECT [DISTINCT] projection
FROM data_sources
[JOIN other_sources ON conditions]
[TRAVERSE graph_operations]
[WHERE conditions]
[GROUP BY grouping_expressions]
[HAVING group_conditions]
[ORDER BY sort_expressions]
[LIMIT count [OFFSET start]]
[FOR UPDATE | FOR SHARE]
</code></pre>

<h3 id="data-types">Data Types</h3>

<pre><code class="language-orbitql">-- Scalar types
SELECT 
    42 as integer,
    3.14159 as float,
    'Hello World' as string,
    true as boolean,
    null as null_value,
    '2023-10-06T19:00:00Z'::timestamp as time_value,
    '1 hour'::interval as duration;

-- Array types
SELECT 
    ARRAY[1, 2, 3, 4, 5] as numbers,
    ARRAY['red', 'green', 'blue'] as colors;

-- Object types
SELECT 
    OBJECT(
        'name', 'Alice',
        'age', 30,
        'skills', ARRAY['rust', 'sql', 'graph']
    ) as user_profile;
</code></pre>

<h3 id="variables-and-parameters">Variables and Parameters</h3>

<pre><code class="language-orbitql">-- Named parameters
SELECT * FROM users WHERE age &gt; @min_age AND location = @city;

-- Positional parameters
SELECT * FROM products WHERE price BETWEEN $1 AND $2;

-- Variable assignment
WITH 
    current_time AS (SELECT NOW()),
    recent_threshold AS (SELECT current_time.value - INTERVAL '1 hour')
SELECT * FROM events WHERE timestamp &gt;= recent_threshold.value;
</code></pre>

<h2 id="data-models">Data Models</h2>

<h3 id="relational-operations">Relational Operations</h3>

<pre><code class="language-orbitql">-- Standard SQL operations
SELECT u.name, u.email, d.department_name
FROM users u
JOIN departments d ON u.department_id = d.id
WHERE u.active = true
ORDER BY u.created_at DESC;

-- Window functions
SELECT 
    name,
    salary,
    AVG(salary) OVER (PARTITION BY department) as dept_avg,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as salary_rank
FROM employees;

-- Common Table Expressions
WITH monthly_sales AS (
    SELECT 
        DATE_TRUNC('month', order_date) as month,
        SUM(total) as monthly_total
    FROM orders
    GROUP BY DATE_TRUNC('month', order_date)
)
SELECT 
    month,
    monthly_total,
    monthly_total - LAG(monthly_total) OVER (ORDER BY month) as growth
FROM monthly_sales;
</code></pre>

<h2 id="advanced-sql-features">Advanced SQL Features</h2>

<h3 id="common-table-expressions-ctes">Common Table Expressions (CTEs)</h3>

<pre><code class="language-orbitql">-- Basic CTE
WITH user_stats AS (
    SELECT user_id, COUNT(*) AS post_count
    FROM posts
    WHERE created_at &gt; NOW() - INTERVAL '30 days'
    GROUP BY user_id
)
SELECT u.name, COALESCE(us.post_count, 0) AS recent_posts
FROM users u
LEFT JOIN user_stats us ON u.id = us.user_id;

-- Multiple CTEs
WITH 
    active_users AS (
        SELECT user_id FROM sessions 
        WHERE last_seen &gt; NOW() - INTERVAL '7 days'
    ),
    popular_posts AS (
        SELECT post_id, COUNT(*) AS like_count
        FROM likes
        GROUP BY post_id
        HAVING COUNT(*) &gt; 100
    )
SELECT u.name, p.title, pp.like_count
FROM users u
JOIN active_users au ON u.id = au.user_id
JOIN posts p ON u.id = p.author_id
JOIN popular_posts pp ON p.id = pp.post_id;

-- Recursive CTE (planned)
WITH RECURSIVE employee_hierarchy AS (
    SELECT id, name, manager_id, 0 AS level
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    SELECT e.id, e.name, e.manager_id, eh.level + 1
    FROM employees e
    JOIN employee_hierarchy eh ON e.manager_id = eh.id
)
SELECT name, level FROM employee_hierarchy ORDER BY level, name;
</code></pre>

<h3 id="case-expressions">CASE Expressions</h3>

<pre><code class="language-orbitql">-- Simple CASE
SELECT 
    name,
    age,
    CASE 
        WHEN age &lt; 18 THEN 'Minor'
        WHEN age &lt; 65 THEN 'Adult'
        ELSE 'Senior'
    END AS age_category
FROM users;

-- CASE in aggregations
SELECT 
    department,
    COUNT(*) AS total_employees,
    COUNT(CASE WHEN salary &gt; 100000 THEN 1 END) AS high_earners,
    AVG(CASE WHEN performance_rating = 'excellent' THEN salary END) AS avg_excellent_salary
FROM employees
GROUP BY department;

-- Nested CASE expressions
SELECT 
    user_id,
    CASE 
        WHEN subscription_type = 'premium' THEN
            CASE 
                WHEN usage_hours &gt; 100 THEN 'power_user'
                ELSE 'premium_casual'
            END
        WHEN subscription_type = 'basic' THEN 'basic_user'
        ELSE 'free_user'
    END AS user_segment
FROM user_subscriptions;
</code></pre>

<h3 id="temporal-functions">Temporal Functions</h3>

<pre><code class="language-orbitql">-- NOW() function
SELECT NOW() AS current_time;
SELECT * FROM events WHERE created_at &gt; NOW() - INTERVAL '1 hour';

-- INTERVAL expressions
SELECT 
    event_name,
    created_at,
    NOW() - created_at AS time_ago
FROM events
WHERE created_at BETWEEN NOW() - INTERVAL '7 days' AND NOW();

-- Time-based filtering
SELECT user_id, COUNT(*) AS login_count
FROM login_events
WHERE timestamp &gt;= NOW() - INTERVAL '30 days'
  AND timestamp &lt; NOW()
GROUP BY user_id
HAVING COUNT(*) &gt; 10;
</code></pre>

<h3 id="enhanced-aggregates">Enhanced Aggregates</h3>

<pre><code class="language-orbitql">-- COUNT(DISTINCT)
SELECT 
    campaign_id,
    COUNT(*) AS total_clicks,
    COUNT(DISTINCT user_id) AS unique_users,
    COUNT(DISTINCT session_id) AS unique_sessions
FROM ad_clicks
GROUP BY campaign_id;

-- Conditional aggregates
SELECT 
    product_category,
    COUNT(*) AS total_orders,
    SUM(CASE WHEN order_status = 'completed' THEN amount ELSE 0 END) AS completed_revenue,
    AVG(CASE WHEN rating IS NOT NULL THEN rating END) AS avg_rating,
    COUNT(DISTINCT CASE WHEN order_status = 'completed' THEN customer_id END) AS unique_customers
FROM orders
GROUP BY product_category;

-- Complex aggregate expressions
SELECT 
    region,
    COUNT(DISTINCT customer_id) AS customers,
    SUM(order_amount) AS total_revenue,
    SUM(order_amount) / COUNT(DISTINCT customer_id) AS revenue_per_customer,
    COUNT(CASE WHEN order_amount &gt; 1000 THEN 1 END) AS high_value_orders
FROM sales_data
WHERE order_date &gt;= NOW() - INTERVAL '90 days'
GROUP BY region
ORDER BY revenue_per_customer DESC;
</code></pre>

<h3 id="null-handling-functions">Null-Handling Functions</h3>

<pre><code class="language-orbitql">-- COALESCE for null handling
SELECT 
    user_id,
    COALESCE(display_name, username, email) AS name,
    COALESCE(phone, email, 'No contact') AS contact_method
FROM user_profiles;

-- Complex null handling
SELECT 
    order_id,
    customer_name,
    CASE 
        WHEN shipping_address IS NOT NULL THEN shipping_address
        WHEN billing_address IS NOT NULL THEN billing_address
        ELSE 'Address missing'
    END AS delivery_address,
    COALESCE(estimated_delivery, order_date + INTERVAL '7 days') AS expected_delivery
FROM orders;
</code></pre>

<h3 id="document-operations">Document Operations</h3>

<pre><code class="language-orbitql">-- JSON document queries
SELECT 
    user_id,
    profile-&gt;&gt;'name' as name,
    profile-&gt;'preferences'-&gt;&gt;'theme' as theme,
    JSON_ARRAY_LENGTH(profile-&gt;'skills') as skill_count
FROM user_profiles
WHERE profile-&gt;&gt;'active' = 'true';

-- Document updates
UPDATE user_profiles 
SET profile = JSON_SET(profile, 
    '$.last_login', NOW(),
    '$.login_count', CAST(profile-&gt;&gt;'login_count' AS INTEGER) + 1
)
WHERE user_id = @user_id;
</code></pre>

<h2 id="graph-queries">Graph Queries</h2>

<h3 id="basic-traversal">Basic Traversal</h3>

<pre><code class="language-orbitql">-- Simple outbound traversal
SELECT person.name, friend.name
FROM users person
TRAVERSE OUTBOUND 1..1 STEPS ON follows TO friend
WHERE person.location = 'San Francisco';

-- Multi-hop traversal
SELECT start.name, end.name, path_length
FROM users start
TRAVERSE OUTBOUND 1..5 STEPS ON follows TO end
RETURN PATHS AS path_info
WHERE start.name = 'Alice' AND end.location = 'New York';
</code></pre>

<h3 id="advanced-graph-operations">Advanced Graph Operations</h3>

<pre><code class="language-orbitql">-- Bidirectional traversal
SELECT person1.name, person2.name, relationship_type
FROM users person1
TRAVERSE ANY 1..3 STEPS ON [follows, knows, works_with] TO person2
RETURN EDGES AS edge_info
WHERE person1.profession = 'engineer';

-- Shortest path queries
SELECT source.name, target.name, shortest_distance
FROM users source, users target
FIND SHORTEST PATH BETWEEN source AND target
VIA [follows, knows]
WHERE source.location = 'NYC' AND target.location = 'SF';

-- Pattern matching
SELECT company.name, COUNT(*) as employee_count
FROM companies company
TRAVERSE INBOUND 1..1 STEPS ON works_for TO employee
WHERE employee.active = true
GROUP BY company.id, company.name
HAVING employee_count &gt; 100;
</code></pre>

<h3 id="graph-analytics">Graph Analytics</h3>

<pre><code class="language-orbitql">-- Centrality measures
SELECT 
    user.name,
    BETWEENNESS_CENTRALITY(user) as betweenness,
    CLOSENESS_CENTRALITY(user) as closeness,
    DEGREE_CENTRALITY(user) as degree
FROM users user
WHERE user.active = true
ORDER BY betweenness DESC;

-- Community detection
SELECT 
    community_id,
    ARRAY_AGG(user.name) as members,
    COUNT(*) as size
FROM (
    SELECT 
        user,
        LOUVAIN_COMMUNITY(user) as community_id
    FROM users user
    TRAVERSE ANY 1..3 STEPS ON follows
) community_data
GROUP BY community_id
ORDER BY size DESC;
</code></pre>

<h2 id="time-series-queries">Time Series Queries</h2>

<h3 id="basic-time-series-operations">Basic Time Series Operations</h3>

<pre><code class="language-orbitql">-- Simple time series query
SELECT series_id, timestamp, value
FROM metrics
WHERE series_id = 'cpu_usage_server_01'
  AND timestamp &gt;= NOW() - INTERVAL '1 hour'
ORDER BY timestamp;

-- Multiple series aggregation
SELECT 
    series_id,
    MIN(value) as min_val,
    MAX(value) as max_val,
    AVG(value) as avg_val,
    STDDEV(value) as stddev_val
FROM metrics
WHERE series_id LIKE 'temperature_sensor_%'
  AND timestamp &gt;= NOW() - INTERVAL '24 hours'
GROUP BY series_id;
</code></pre>

<h3 id="temporal-windows">Temporal Windows</h3>

<pre><code class="language-orbitql">-- Time-based windows
SELECT 
    TIME_BUCKET('15 minutes', timestamp) as time_window,
    series_id,
    AVG(value) as avg_value,
    MAX(value) as max_value,
    COUNT(*) as sample_count
FROM metrics
WHERE timestamp &gt;= NOW() - INTERVAL '6 hours'
GROUP BY TIME_BUCKET('15 minutes', timestamp), series_id
ORDER BY time_window, series_id;

-- Sliding windows
SELECT 
    timestamp,
    value,
    AVG(value) OVER (
        ORDER BY timestamp 
        ROWS BETWEEN 10 PRECEDING AND CURRENT ROW
    ) as moving_avg_10,
    AVG(value) OVER (
        ORDER BY timestamp 
        RANGE BETWEEN INTERVAL '1 hour' PRECEDING AND CURRENT ROW
    ) as hourly_avg
FROM metrics
WHERE series_id = 'stock_price_AAPL'
ORDER BY timestamp;
</code></pre>

<h3 id="advanced-time-series-analytics">Advanced Time Series Analytics</h3>

<pre><code class="language-orbitql">-- Gap filling and interpolation
SELECT 
    timestamp,
    series_id,
    COALESCE(
        value, 
        INTERPOLATE_LINEAR(timestamp, value) OVER (
            PARTITION BY series_id 
            ORDER BY timestamp
        )
    ) as filled_value
FROM (
    SELECT * FROM metrics
    UNION ALL
    SELECT * FROM GENERATE_TIME_SERIES(
        '2023-01-01'::timestamp,
        '2023-01-31'::timestamp,
        INTERVAL '1 minute'
    )
) time_series
WHERE series_id = 'sensor_data';

-- Anomaly detection
WITH stats AS (
    SELECT 
        series_id,
        AVG(value) as mean_val,
        STDDEV(value) as stddev_val
    FROM metrics
    WHERE timestamp &gt;= NOW() - INTERVAL '7 days'
    GROUP BY series_id
)
SELECT 
    m.timestamp,
    m.series_id,
    m.value,
    s.mean_val,
    s.stddev_val,
    ABS(m.value - s.mean_val) / s.stddev_val as z_score,
    CASE 
        WHEN ABS(m.value - s.mean_val) / s.stddev_val &gt; 3 THEN 'anomaly'
        WHEN ABS(m.value - s.mean_val) / s.stddev_val &gt; 2 THEN 'unusual'
        ELSE 'normal'
    END as status
FROM metrics m
JOIN stats s ON m.series_id = s.series_id
WHERE m.timestamp &gt;= NOW() - INTERVAL '1 hour'
  AND ABS(m.value - s.mean_val) / s.stddev_val &gt; 2
ORDER BY z_score DESC;
</code></pre>

<h2 id="multi-model-queries">Multi-Model Queries</h2>

<h3 id="graph--time-series">Graph + Time Series</h3>

<pre><code class="language-orbitql">-- Sensor network with time series data
SELECT 
    sensor.name,
    sensor.location,
    latest_readings.avg_temp,
    latest_readings.max_temp,
    connected_sensors.count as connected_count
FROM sensors sensor
JOIN (
    SELECT 
        series_id,
        AVG(value) as avg_temp,
        MAX(value) as max_temp
    FROM metrics
    WHERE timestamp &gt;= NOW() - INTERVAL '1 hour'
    GROUP BY series_id
) latest_readings ON sensor.id = latest_readings.series_id
JOIN (
    SELECT 
        source_sensor.id,
        COUNT(*) as count
    FROM sensors source_sensor
    TRAVERSE OUTBOUND 1..1 STEPS ON connected_to TO connected_sensor
    GROUP BY source_sensor.id
) connected_sensors ON sensor.id = connected_sensors.id
WHERE sensor.active = true;
</code></pre>

<h3 id="document--graph--time-series">Document + Graph + Time Series</h3>

<pre><code class="language-orbitql">-- User activity analysis across all models
SELECT 
    u.user_id,
    u.profile-&gt;&gt;'name' as name,
    u.profile-&gt;&gt;'location' as location,
    social_metrics.friend_count,
    social_metrics.avg_influence,
    activity_metrics.recent_activity,
    activity_metrics.activity_trend
FROM user_profiles u
JOIN (
    SELECT 
        user.id,
        COUNT(*) as friend_count,
        AVG(edge.influence_score) as avg_influence
    FROM users user
    TRAVERSE OUTBOUND 1..1 STEPS ON follows TO friend
    RETURN EDGES AS edge
    GROUP BY user.id
) social_metrics ON u.user_id = social_metrics.id
JOIN (
    SELECT 
        series_id,
        COUNT(*) as recent_activity,
        (COUNT(*) - LAG(COUNT(*)) OVER (ORDER BY series_id)) as activity_trend
    FROM activity_events
    WHERE timestamp &gt;= NOW() - INTERVAL '24 hours'
    GROUP BY series_id
) activity_metrics ON u.user_id = activity_metrics.series_id
WHERE u.profile-&gt;&gt;'active' = 'true';
</code></pre>

<h2 id="distributed-operations">Distributed Operations</h2>

<h3 id="cross-node-queries">Cross-Node Queries</h3>

<pre><code class="language-orbitql">-- Query data across cluster nodes
SELECT 
    node_id,
    COUNT(*) as record_count,
    AVG(processing_time) as avg_processing_time
FROM DISTRIBUTED.user_activities
WHERE created_at &gt;= NOW() - INTERVAL '1 day'
GROUP BY node_id
ORDER BY avg_processing_time DESC;

-- Distributed joins
SELECT 
    u.name,
    o.total,
    p.product_name
FROM DISTRIBUTED.users u
JOIN DISTRIBUTED.orders o ON u.id = o.user_id
JOIN products p ON o.product_id = p.id  -- Local join
WHERE o.order_date &gt;= NOW() - INTERVAL '30 days';
</code></pre>

<h3 id="actor-system-integration">Actor System Integration</h3>

<pre><code class="language-orbitql">-- Query actor states
SELECT 
    actor_id,
    actor_type,
    state-&gt;&gt;'status' as status,
    state-&gt;&gt;'last_heartbeat' as last_heartbeat,
    EXTRACT(EPOCH FROM (NOW() - (state-&gt;&gt;'last_heartbeat')::timestamp)) as seconds_since_heartbeat
FROM ACTORS.all_actors
WHERE actor_type = 'UserSession';

-- Actor message patterns
SELECT 
    source_actor,
    target_actor,
    message_type,
    COUNT(*) as message_count,
    AVG(processing_time) as avg_processing_time
FROM ACTORS.message_log
WHERE timestamp &gt;= NOW() - INTERVAL '1 hour'
GROUP BY source_actor, target_actor, message_type
ORDER BY message_count DESC;
</code></pre>

<h2 id="advanced-features">Advanced Features</h2>

<h3 id="recursive-queries">Recursive Queries</h3>

<pre><code class="language-orbitql">-- Organizational hierarchy
WITH RECURSIVE org_hierarchy AS (
    -- Base case: top-level managers
    SELECT id, name, manager_id, 0 as level, name as path
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive case: employees with managers
    SELECT 
        e.id, 
        e.name, 
        e.manager_id,
        oh.level + 1,
        oh.path || ' -&gt; ' || e.name
    FROM employees e
    JOIN org_hierarchy oh ON e.manager_id = oh.id
    WHERE oh.level &lt; 10  -- Prevent infinite recursion
)
SELECT level, name, path
FROM org_hierarchy
ORDER BY level, name;
</code></pre>

<h3 id="user-defined-functions">User-Defined Functions</h3>

<pre><code class="language-orbitql">-- Define custom function
CREATE FUNCTION calculate_distance(lat1 FLOAT, lon1 FLOAT, lat2 FLOAT, lon2 FLOAT)
RETURNS FLOAT
AS $$
    -- Haversine formula implementation
    SELECT 
        2 * 6371 * ASIN(SQRT(
            POW(SIN(RADIANS(lat2 - lat1) / 2), 2) +
            COS(RADIANS(lat1)) * COS(RADIANS(lat2)) *
            POW(SIN(RADIANS(lon2 - lon1) / 2), 2)
        ))
$$;

-- Use custom function
SELECT 
    u1.name,
    u2.name,
    calculate_distance(
        u1.profile-&gt;&gt;'latitude', u1.profile-&gt;&gt;'longitude',
        u2.profile-&gt;&gt;'latitude', u2.profile-&gt;&gt;'longitude'
    ) as distance_km
FROM users u1, users u2
WHERE u1.id != u2.id
  AND calculate_distance(
        u1.profile-&gt;&gt;'latitude', u1.profile-&gt;&gt;'longitude',
        u2.profile-&gt;&gt;'latitude', u2.profile-&gt;&gt;'longitude'
    ) &lt; 10  -- Within 10km
ORDER BY distance_km;
</code></pre>

<h3 id="machine-learning-integration">Machine Learning Integration</h3>

<pre><code class="language-orbitql">-- Feature extraction for ML
SELECT 
    user_id,
    -- User profile features
    CAST(profile-&gt;&gt;'age' AS INTEGER) as age,
    profile-&gt;&gt;'location' as location,
    JSON_ARRAY_LENGTH(profile-&gt;'skills') as skill_count,
    
    -- Social network features
    (SELECT COUNT(*) FROM users TRAVERSE OUTBOUND 1..1 STEPS ON follows WHERE target.active = true) as friend_count,
    (SELECT AVG(CAST(target.profile-&gt;&gt;'age' AS INTEGER)) FROM users TRAVERSE OUTBOUND 1..1 STEPS ON follows) as avg_friend_age,
    
    -- Activity features
    (SELECT COUNT(*) FROM activity_events WHERE series_id = users.user_id AND timestamp &gt;= NOW() - INTERVAL '30 days') as monthly_activity,
    
    -- Time series features
    (SELECT AVG(value) FROM metrics WHERE series_id = users.user_id || '_engagement' AND timestamp &gt;= NOW() - INTERVAL '7 days') as avg_engagement
    
FROM users
WHERE profile-&gt;&gt;'active' = 'true';
</code></pre>

<h2 id="performance--optimization">Performance &amp; Optimization</h2>

<h3 id="index-hints">Index Hints</h3>

<pre><code class="language-orbitql">-- Use specific indexes
SELECT /*+ INDEX(users, idx_users_location_age) */ *
FROM users
WHERE location = 'NYC' AND age &gt; 25;

-- Force specific join order
SELECT /*+ ORDERED */ u.name, o.total
FROM users u, orders o
WHERE u.id = o.user_id;
</code></pre>

<h3 id="query-plans">Query Plans</h3>

<pre><code class="language-orbitql">-- Explain query execution plan
EXPLAIN (ANALYZE, VERBOSE, COSTS) 
SELECT u.name, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.created_at &gt;= '2023-01-01'
GROUP BY u.id, u.name;
</code></pre>

<h3 id="parallel-execution">Parallel Execution</h3>

<pre><code class="language-orbitql">-- Enable parallel processing
SET enable_parallel = true;
SET max_parallel_workers_per_gather = 4;

SELECT /*+ PARALLEL(4) */
    series_id,
    COUNT(*) as point_count,
    AVG(value) as avg_value
FROM metrics
WHERE timestamp &gt;= NOW() - INTERVAL '7 days'
GROUP BY series_id;
</code></pre>

<h2 id="examples">Examples</h2>

<h3 id="real-time-dashboard-query">Real-time Dashboard Query</h3>

<pre><code class="language-orbitql">-- Complete dashboard data in single query
WITH 
    -- System health metrics
    system_health AS (
        SELECT 
            'system_health' as metric_type,
            AVG(CASE WHEN series_id LIKE 'cpu_%' THEN value END) as avg_cpu,
            AVG(CASE WHEN series_id LIKE 'memory_%' THEN value END) as avg_memory,
            AVG(CASE WHEN series_id LIKE 'disk_%' THEN value END) as avg_disk
        FROM metrics
        WHERE timestamp &gt;= NOW() - INTERVAL '5 minutes'
    ),
    
    -- Active user count
    active_users AS (
        SELECT 
            'active_users' as metric_type,
            COUNT(DISTINCT user_id) as count
        FROM activity_events
        WHERE timestamp &gt;= NOW() - INTERVAL '15 minutes'
    ),
    
    -- Top connected sensors
    top_sensors AS (
        SELECT 
            'top_sensors' as metric_type,
            JSON_AGG(
                JSON_BUILD_OBJECT(
                    'name', sensor.name,
                    'value', latest_value.value,
                    'connections', connections.count
                )
                ORDER BY connections.count DESC
            ) as data
        FROM sensors sensor
        JOIN (
            SELECT series_id, LAST(value) as value
            FROM metrics
            WHERE timestamp &gt;= NOW() - INTERVAL '1 minute'
            GROUP BY series_id
        ) latest_value ON sensor.id = latest_value.series_id
        JOIN (
            SELECT source.id, COUNT(*) as count
            FROM sensors source
            TRAVERSE OUTBOUND 1..1 STEPS ON connected_to
            GROUP BY source.id
        ) connections ON sensor.id = connections.id
        LIMIT 10
    )

SELECT * FROM system_health
UNION ALL
SELECT metric_type, count::TEXT, null, null FROM active_users
UNION ALL
SELECT metric_type, data::TEXT, null, null FROM top_sensors;
</code></pre>

<h3 id="fraud-detection-system">Fraud Detection System</h3>

<pre><code class="language-orbitql">-- Multi-model fraud detection
WITH 
    -- Unusual transaction patterns
    suspicious_transactions AS (
        SELECT 
            t.user_id,
            t.amount,
            t.merchant_id,
            -- Compare with user's historical behavior
            (t.amount - user_stats.avg_amount) / user_stats.stddev_amount as amount_zscore,
            -- Time-based anomaly
            EXTRACT(HOUR FROM t.timestamp) as transaction_hour,
            user_stats.common_hours
        FROM transactions t
        JOIN (
            SELECT 
                user_id,
                AVG(amount) as avg_amount,
                STDDEV(amount) as stddev_amount,
                MODE() WITHIN GROUP (ORDER BY EXTRACT(HOUR FROM timestamp)) as common_hours
            FROM transactions
            WHERE timestamp &gt;= NOW() - INTERVAL '90 days'
            GROUP BY user_id
        ) user_stats ON t.user_id = user_stats.user_id
        WHERE t.timestamp &gt;= NOW() - INTERVAL '1 hour'
          AND (
              ABS(t.amount - user_stats.avg_amount) / user_stats.stddev_amount &gt; 2
              OR ABS(EXTRACT(HOUR FROM t.timestamp) - user_stats.common_hours) &gt; 6
          )
    ),
    
    -- Social network risk assessment
    social_risk AS (
        SELECT 
            u.id as user_id,
            COUNT(CASE WHEN friend.profile-&gt;&gt;'risk_score'::FLOAT &gt; 0.7 THEN 1 END) as high_risk_friends,
            AVG(friend.profile-&gt;&gt;'risk_score'::FLOAT) as avg_friend_risk
        FROM users u
        TRAVERSE OUTBOUND 1..2 STEPS ON [friends, knows] TO friend
        WHERE friend.profile-&gt;&gt;'risk_score' IS NOT NULL
        GROUP BY u.id
    )

SELECT 
    st.user_id,
    u.profile-&gt;&gt;'name' as user_name,
    u.profile-&gt;&gt;'email' as email,
    st.amount,
    st.amount_zscore,
    sr.high_risk_friends,
    sr.avg_friend_risk,
    -- Combined risk score
    (
        GREATEST(ABS(st.amount_zscore), 0) * 0.4 +
        COALESCE(sr.high_risk_friends * 0.1, 0) +
        COALESCE(sr.avg_friend_risk * 0.5, 0)
    ) as combined_risk_score
FROM suspicious_transactions st
JOIN user_profiles u ON st.user_id = u.user_id
LEFT JOIN social_risk sr ON st.user_id = sr.user_id
WHERE (
    ABS(st.amount_zscore) &gt; 2.5
    OR sr.high_risk_friends &gt; 2
    OR sr.avg_friend_risk &gt; 0.6
)
ORDER BY combined_risk_score DESC;
</code></pre>

<h2 id="api-reference">API Reference</h2>

<h3 id="query-execution">Query Execution</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">orbit_shared</span><span class="p">::</span><span class="nn">orbitql</span><span class="p">::{</span><span class="n">OrbitQLEngine</span><span class="p">,</span> <span class="n">QueryBuilder</span><span class="p">,</span> <span class="n">ExecutionOptions</span><span class="p">};</span>

<span class="c1">// Basic query execution</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">orbitql_engine</span><span class="nf">.execute</span><span class="p">(</span>
    <span class="s">"SELECT name, age FROM users WHERE age &gt; @min_age"</span><span class="p">,</span>
    <span class="nd">params!</span> <span class="p">{</span> <span class="s">"min_age"</span> <span class="k">=&gt;</span> <span class="mi">21</span> <span class="p">}</span>
<span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

<span class="c1">// Query builder pattern</span>
<span class="k">let</span> <span class="n">query</span> <span class="o">=</span> <span class="nn">QueryBuilder</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
    <span class="nf">.select</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="s">"u.name"</span><span class="p">,</span> <span class="s">"COUNT(f.id) as friend_count"</span><span class="p">])</span>
    <span class="nf">.from</span><span class="p">(</span><span class="s">"users u"</span><span class="p">)</span>
    <span class="nf">.traverse</span><span class="p">(</span><span class="s">"OUTBOUND 1..1 STEPS ON follows TO f"</span><span class="p">)</span>
    <span class="nf">.group_by</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="s">"u.id"</span><span class="p">,</span> <span class="s">"u.name"</span><span class="p">])</span>
    <span class="nf">.having</span><span class="p">(</span><span class="s">"COUNT(f.id) &gt; 5"</span><span class="p">)</span>
    <span class="nf">.order_by</span><span class="p">(</span><span class="s">"friend_count DESC"</span><span class="p">)</span>
    <span class="nf">.limit</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">orbitql_engine</span><span class="nf">.execute_query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="streaming-execution">Streaming Execution</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">futures_util</span><span class="p">::</span><span class="nn">stream</span><span class="p">::</span><span class="n">StreamExt</span><span class="p">;</span>

<span class="c1">// Stream large result sets</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">orbitql_engine</span><span class="nf">.execute_stream</span><span class="p">(</span>
    <span class="s">"SELECT * FROM large_table WHERE created_at &gt;= @start_date"</span><span class="p">,</span>
    <span class="nd">params!</span> <span class="p">{</span> <span class="s">"start_date"</span> <span class="k">=&gt;</span> <span class="n">start_date</span> <span class="p">}</span>
<span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

<span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.next</span><span class="p">()</span><span class="k">.await</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">row</span> <span class="k">in</span> <span class="n">batch</span><span class="o">?</span> <span class="p">{</span>
        <span class="c1">// Process each row</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">row</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="prepared-statements">Prepared Statements</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Prepare statement</span>
<span class="k">let</span> <span class="n">prepared</span> <span class="o">=</span> <span class="n">orbitql_engine</span><span class="nf">.prepare</span><span class="p">(</span>
    <span class="s">"SELECT * FROM users WHERE department = $1 AND age &gt; $2"</span>
<span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

<span class="c1">// Execute with different parameters</span>
<span class="k">let</span> <span class="n">engineers</span> <span class="o">=</span> <span class="n">prepared</span><span class="nf">.execute</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="s">"Engineering"</span><span class="p">,</span> <span class="o">&amp;</span><span class="mi">25</span><span class="p">])</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
<span class="k">let</span> <span class="n">managers</span> <span class="o">=</span> <span class="n">prepared</span><span class="nf">.execute</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="s">"Management"</span><span class="p">,</span> <span class="o">&amp;</span><span class="mi">30</span><span class="p">])</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="transaction-support">Transaction Support</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Execute in transaction</span>
<span class="k">let</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">orbitql_engine</span><span class="nf">.begin_transaction</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

<span class="k">let</span> <span class="n">user_result</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.execute</span><span class="p">(</span>
    <span class="s">"INSERT INTO users (name, email) VALUES (@name, @email) RETURNING id"</span><span class="p">,</span>
    <span class="nd">params!</span> <span class="p">{</span> <span class="s">"name"</span> <span class="k">=&gt;</span> <span class="s">"Alice"</span><span class="p">,</span> <span class="s">"email"</span> <span class="k">=&gt;</span> <span class="s">"alice@example.com"</span> <span class="p">}</span>
<span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

<span class="k">let</span> <span class="n">user_id</span> <span class="o">=</span> <span class="n">user_result</span><span class="py">.get</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">"id"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="n">tx</span><span class="nf">.execute</span><span class="p">(</span>
    <span class="s">"INSERT INTO user_profiles (user_id, preferences) VALUES (@user_id, @prefs)"</span><span class="p">,</span>
    <span class="nd">params!</span> <span class="p">{</span> 
        <span class="s">"user_id"</span> <span class="k">=&gt;</span> <span class="n">user_id</span><span class="p">,</span>
        <span class="s">"prefs"</span> <span class="k">=&gt;</span> <span class="nd">json!</span><span class="p">({</span><span class="s">"theme"</span><span class="p">:</span> <span class="s">"dark"</span><span class="p">,</span> <span class="s">"notifications"</span><span class="p">:</span> <span class="kc">true</span><span class="p">})</span>
    <span class="p">}</span>
<span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

<span class="n">tx</span><span class="nf">.commit</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="schema-integration">Schema Integration</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Define schema</span>
<span class="k">let</span> <span class="n">schema</span> <span class="o">=</span> <span class="nn">Schema</span><span class="p">::</span><span class="nf">builder</span><span class="p">()</span>
    <span class="nf">.table</span><span class="p">(</span><span class="s">"users"</span><span class="p">)</span>
        <span class="nf">.column</span><span class="p">(</span><span class="s">"id"</span><span class="p">,</span> <span class="nn">DataType</span><span class="p">::</span><span class="n">BigInt</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="c1">// primary key</span>
        <span class="nf">.column</span><span class="p">(</span><span class="s">"name"</span><span class="p">,</span> <span class="nn">DataType</span><span class="p">::</span><span class="n">Text</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span>
        <span class="nf">.column</span><span class="p">(</span><span class="s">"email"</span><span class="p">,</span> <span class="nn">DataType</span><span class="p">::</span><span class="n">Text</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span>
        <span class="nf">.index</span><span class="p">(</span><span class="s">"idx_users_email"</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"email"</span><span class="p">],</span> <span class="k">true</span><span class="p">)</span> <span class="c1">// unique</span>
    <span class="nf">.table</span><span class="p">(</span><span class="s">"user_profiles"</span><span class="p">)</span> 
        <span class="nf">.column</span><span class="p">(</span><span class="s">"user_id"</span><span class="p">,</span> <span class="nn">DataType</span><span class="p">::</span><span class="n">BigInt</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span>
        <span class="nf">.column</span><span class="p">(</span><span class="s">"preferences"</span><span class="p">,</span> <span class="nn">DataType</span><span class="p">::</span><span class="n">Json</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span>
        <span class="nf">.foreign_key</span><span class="p">(</span><span class="s">"fk_user_profiles_user_id"</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"user_id"</span><span class="p">],</span> <span class="s">"users"</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"id"</span><span class="p">])</span>
    <span class="nf">.build</span><span class="p">();</span>

<span class="c1">// Register schema</span>
<span class="n">orbitql_engine</span><span class="nf">.register_schema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

<span class="c1">// Type-safe queries with schema validation</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">orbitql_engine</span><span class="py">.execute_typed</span><span class="p">::</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="s">"SELECT id, name, email FROM users WHERE age &gt; @min_age"</span><span class="p">,</span>
    <span class="nd">params!</span> <span class="p">{</span> <span class="s">"min_age"</span> <span class="k">=&gt;</span> <span class="mi">21</span> <span class="p">}</span>
<span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<p>OrbitQL represents the next generation of query languages, designed specifically for modern distributed, multi-model systems while maintaining the familiarity and power that developers expect from SQL.</p>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/orbit-rs/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Orbit-RS Documentation</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">TuringWorks</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>The Next-Generation Distributed Database System - Production-Ready Multi-Model Platform</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>