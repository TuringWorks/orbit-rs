-- =====================================================================
-- OrbitQL Multi-Model Query Examples
-- =====================================================================
-- E-commerce Analytics Platform: Documents + Graphs + Time Series
-- These queries demonstrate OrbitQL's unified multi-model capabilities
-- =====================================================================

-- 1. BASIC DOCUMENT QUERIES
-- =========================

-- Simple user profile query with JSON path access
SELECT 
    id,
    name, 
    email,
    profile.city,
    profile.age,
    profile.interests,
    created_at
FROM users 
WHERE profile.age > 25 
  AND profile.city = 'San Francisco'
  AND profile.interests CONTAINS 'technology'
ORDER BY created_at DESC
LIMIT 10;

-- Product search with category filtering
SELECT 
    product_id,
    name,
    description,
    price,
    category.main,
    category.subcategory,
    inventory.stock_count,
    ratings.average AS avg_rating
FROM products 
WHERE category.main = 'Electronics'
  AND price BETWEEN 100 AND 1000
  AND inventory.stock_count > 0
ORDER BY ratings.average DESC, price ASC;

-- 2. GRAPH RELATIONSHIP QUERIES
-- ==============================

-- Social network analysis: Find user's connections
SELECT 
    u.name AS user,
    f.relationship_type,
    f.created_at AS connected_since,
    target.name AS connected_to,
    target.profile.city AS friend_city
FROM users u
JOIN follows f ON u.id = f.from_user_id
JOIN users target ON f.to_user_id = target.id
WHERE u.name = 'Alice Johnson'
  AND f.relationship_type IN ('follows', 'friend', 'colleague')
ORDER BY f.created_at DESC;

-- Product recommendation through social connections
SELECT 
    p.name AS product_name,
    p.category.main,
    COUNT(DISTINCT pu.user_id) AS friends_who_bought,
    AVG(r.rating) AS avg_friend_rating
FROM products p
JOIN purchases pu ON p.id = pu.product_id
JOIN follows f ON pu.user_id = f.to_user_id
JOIN reviews r ON p.id = r.product_id AND r.user_id = pu.user_id
WHERE f.from_user_id = 'user_12345'  -- Current user
  AND f.relationship_type = 'friend'
  AND pu.created_at > NOW() - INTERVAL '90 days'
GROUP BY p.id, p.name, p.category.main
HAVING COUNT(DISTINCT pu.user_id) >= 2
ORDER BY friends_who_bought DESC, avg_friend_rating DESC;

-- 3. TIME SERIES DATA QUERIES
-- ============================

-- Real-time user activity monitoring
SELECT 
    user_id,
    metric_name,
    value,
    timestamp,
    tags.session_id,
    tags.device_type,
    tags.location
FROM user_metrics 
WHERE timestamp > NOW() - INTERVAL '2 hours'
  AND metric_name IN ('page_views', 'session_duration', 'cart_additions', 'purchases')
  AND tags.device_type IN ('mobile', 'desktop')
ORDER BY timestamp DESC
LIMIT 50;

-- System performance analysis
SELECT 
    server_id,
    AVG(cpu_usage) AS avg_cpu,
    MAX(memory_usage) AS peak_memory,
    AVG(response_time_ms) AS avg_response_time,
    COUNT(*) AS data_points
FROM system_metrics
WHERE timestamp > NOW() - INTERVAL '1 hour'
  AND server_id IN ('web-01', 'web-02', 'web-03')
GROUP BY server_id
ORDER BY avg_response_time DESC;

-- User behavior trend analysis
SELECT 
    DATE_TRUNC('hour', timestamp) AS hour,
    COUNT(CASE WHEN metric_name = 'login' THEN 1 END) AS logins,
    COUNT(CASE WHEN metric_name = 'purchase' THEN 1 END) AS purchases,
    AVG(CASE WHEN metric_name = 'session_duration' THEN value END) AS avg_session_minutes
FROM event_stream
WHERE timestamp > NOW() - INTERVAL '24 hours'
GROUP BY DATE_TRUNC('hour', timestamp)
ORDER BY hour ASC;

-- 4. MULTI-MODEL JOINS: Documents + Graphs
-- =========================================

-- Social influence scoring
SELECT 
    u.name,
    u.email,
    u.profile.city,
    u.profile.follower_count,
    COUNT(DISTINCT f.to_user_id) AS actual_followers,
    COUNT(DISTINCT l.id) AS likes_received,
    COUNT(DISTINCT r.id) AS reviews_written,
    (
        COUNT(DISTINCT f.to_user_id) * 2 +  -- Follower weight
        COUNT(DISTINCT l.id) * 1 +          -- Like weight  
        COUNT(DISTINCT r.id) * 3            -- Review weight
    ) AS influence_score
FROM users u
LEFT JOIN follows f ON u.id = f.to_user_id AND f.relationship_type = 'follows'
LEFT JOIN likes l ON u.id = l.target_user_id
LEFT JOIN reviews r ON u.id = r.user_id
WHERE u.profile.age BETWEEN 25 AND 45
  AND u.created_at > NOW() - INTERVAL '2 years'
GROUP BY u.id, u.name, u.email, u.profile.city, u.profile.follower_count
ORDER BY influence_score DESC
LIMIT 20;

-- Community detection: Users in same city with mutual connections
SELECT 
    u1.name AS user1,
    u2.name AS user2,
    u1.profile.city,
    COUNT(DISTINCT mutual.to_user_id) AS mutual_friends
FROM users u1
JOIN users u2 ON u1.profile.city = u2.profile.city AND u1.id < u2.id
JOIN follows f1 ON u1.id = f1.from_user_id
JOIN follows f2 ON u2.id = f2.from_user_id AND f1.to_user_id = f2.to_user_id
JOIN follows mutual ON f1.to_user_id = mutual.to_user_id
WHERE u1.profile.city IN ('San Francisco', 'New York', 'Austin')
GROUP BY u1.id, u1.name, u2.id, u2.name, u1.profile.city
HAVING COUNT(DISTINCT mutual.to_user_id) >= 3
ORDER BY mutual_friends DESC;

-- 5. MULTI-MODEL JOINS: Documents + Time Series  
-- ===============================================

-- User engagement analysis with behavioral metrics
SELECT 
    u.name,
    u.profile.city,
    u.profile.age,
    COUNT(DISTINCT m.timestamp::date) AS active_days,
    AVG(CASE WHEN m.metric_name = 'session_duration' THEN m.value END) AS avg_session_minutes,
    COUNT(CASE WHEN m.metric_name = 'page_views' THEN 1 END) AS total_page_views,
    COUNT(CASE WHEN m.metric_name = 'purchases' THEN 1 END) AS total_purchases,
    MAX(m.timestamp) AS last_activity
FROM users u
INNER JOIN user_metrics m ON u.id = m.user_id
WHERE m.timestamp > NOW() - INTERVAL '30 days'
  AND u.profile.city IN ('San Francisco', 'New York', 'Austin', 'Seattle')
GROUP BY u.id, u.name, u.profile.city, u.profile.age
HAVING COUNT(DISTINCT m.timestamp::date) >= 7  -- Active at least 7 days
  AND AVG(CASE WHEN m.metric_name = 'session_duration' THEN m.value END) > 300  -- 5+ min sessions
ORDER BY total_purchases DESC, avg_session_minutes DESC;

-- Real-time anomaly detection
SELECT 
    u.name,
    u.email,
    m.metric_name,
    m.value AS current_value,
    m.timestamp,
    AVG(m.value) OVER (
        PARTITION BY m.user_id, m.metric_name 
        ORDER BY m.timestamp 
        ROWS BETWEEN 10 PRECEDING AND 1 PRECEDING
    ) AS rolling_avg,
    CASE 
        WHEN m.value > AVG(m.value) OVER (
            PARTITION BY m.user_id, m.metric_name 
            ORDER BY m.timestamp 
            ROWS BETWEEN 10 PRECEDING AND 1 PRECEDING
        ) * 2 THEN 'HIGH_ANOMALY'
        WHEN m.value < AVG(m.value) OVER (
            PARTITION BY m.user_id, m.metric_name 
            ORDER BY m.timestamp 
            ROWS BETWEEN 10 PRECEDING AND 1 PRECEDING
        ) * 0.5 THEN 'LOW_ANOMALY'
        ELSE 'NORMAL'
    END AS anomaly_status
FROM users u
JOIN user_metrics m ON u.id = m.user_id
WHERE m.timestamp > NOW() - INTERVAL '1 hour'
  AND m.metric_name IN ('session_duration', 'page_views', 'error_count')
ORDER BY m.timestamp DESC;

-- 6. ULTIMATE QUERIES: Documents + Graphs + Time Series
-- ======================================================

-- Complete user 360-degree analysis
SELECT 
    u.name,
    u.email,
    u.profile.city,
    u.profile.age,
    u.profile.interests,
    
    -- Social metrics from graph data
    COUNT(DISTINCT f.to_user_id) AS followers_count,
    COUNT(DISTINCT following.from_user_id) AS following_count,
    COUNT(DISTINCT l.id) AS likes_given,
    COUNT(DISTINCT l2.id) AS likes_received,
    
    -- Purchase behavior from relationships
    COUNT(DISTINCT p.id) AS products_purchased,
    SUM(p.price) AS total_spent,
    AVG(pr.rating) AS avg_product_rating,
    
    -- Behavioral metrics from time series
    COUNT(DISTINCT DATE_TRUNC('day', m.timestamp)) AS active_days_month,
    AVG(CASE WHEN m.metric_name = 'session_duration' THEN m.value END) AS avg_session_time,
    COUNT(CASE WHEN m.metric_name = 'page_views' THEN 1 END) AS total_page_views,
    COUNT(CASE WHEN m.metric_name = 'cart_additions' THEN 1 END) AS items_added_to_cart,
    MAX(m.timestamp) AS last_seen,
    
    -- Computed scores
    (
        COUNT(DISTINCT f.to_user_id) * 0.2 +           -- Social influence
        COUNT(DISTINCT p.id) * 0.3 +                   -- Purchase activity  
        COUNT(DISTINCT DATE_TRUNC('day', m.timestamp)) * 0.3 + -- Engagement frequency
        (AVG(CASE WHEN m.metric_name = 'session_duration' THEN m.value END) / 100) * 0.2  -- Session quality
    ) AS customer_value_score
    
FROM users u
LEFT JOIN follows f ON u.id = f.to_user_id AND f.relationship_type = 'follows'
LEFT JOIN follows following ON u.id = following.from_user_id
LEFT JOIN likes l ON u.id = l.user_id
LEFT JOIN likes l2 ON u.id = l2.target_user_id
LEFT JOIN purchases pu ON u.id = pu.user_id
LEFT JOIN products p ON pu.product_id = p.id
LEFT JOIN reviews pr ON u.id = pr.user_id AND p.id = pr.product_id
LEFT JOIN user_metrics m ON u.id = m.user_id 
WHERE m.timestamp > NOW() - INTERVAL '30 days'  -- Last 30 days activity
  OR m.timestamp IS NULL  -- Include users with no recent activity
GROUP BY u.id, u.name, u.email, u.profile.city, u.profile.age, u.profile.interests
ORDER BY customer_value_score DESC
LIMIT 25;

-- Trending analysis: Users gaining popularity and engagement
WITH recent_growth AS (
    SELECT 
        f.to_user_id AS user_id,
        COUNT(*) AS new_followers_week
    FROM follows f
    WHERE f.created_at > NOW() - INTERVAL '7 days'
      AND f.relationship_type = 'follows'
    GROUP BY f.to_user_id
),
activity_surge AS (
    SELECT 
        m.user_id,
        COUNT(*) AS recent_activities,
        AVG(m.value) AS avg_engagement_value
    FROM user_metrics m
    WHERE m.timestamp > NOW() - INTERVAL '7 days'
      AND m.metric_name IN ('page_views', 'session_duration', 'content_shares')
    GROUP BY m.user_id
    HAVING COUNT(*) > (
        SELECT AVG(activity_count) * 1.5
        FROM (
            SELECT user_id, COUNT(*) as activity_count
            FROM user_metrics 
            WHERE timestamp > NOW() - INTERVAL '7 days'
            GROUP BY user_id
        ) avg_calc
    )
)
SELECT 
    u.name,
    u.profile.city,
    u.profile.age,
    COALESCE(rg.new_followers_week, 0) AS new_followers,
    COALESCE(acs.recent_activities, 0) AS activity_spike,
    COALESCE(acs.avg_engagement_value, 0) AS engagement_quality,
    COUNT(DISTINCT p.id) AS products_interacted,
    (
        COALESCE(rg.new_followers_week, 0) * 0.4 +
        (COALESCE(acs.recent_activities, 0) / 10) * 0.3 +
        COALESCE(acs.avg_engagement_value, 0) * 0.2 +
        COUNT(DISTINCT p.id) * 0.1
    ) AS trending_score
FROM users u
LEFT JOIN recent_growth rg ON u.id = rg.user_id
LEFT JOIN activity_surge acs ON u.id = acs.user_id
LEFT JOIN purchases pu ON u.id = pu.user_id AND pu.created_at > NOW() - INTERVAL '7 days'
LEFT JOIN products p ON pu.product_id = p.id
WHERE u.profile.age BETWEEN 18 AND 65
  AND (rg.new_followers_week > 0 OR acs.recent_activities > 0)
GROUP BY u.id, u.name, u.profile.city, u.profile.age, rg.new_followers_week, acs.recent_activities, acs.avg_engagement_value
ORDER BY trending_score DESC
LIMIT 15;

-- 7. REAL-TIME STREAMING QUERIES (OrbitQL Extension)
-- ===================================================

-- Live user activity dashboard
LIVE SELECT 
    u.name,
    u.profile.city,
    m.metric_name,
    m.value,
    m.timestamp,
    m.tags.device_type,
    CASE 
        WHEN m.metric_name = 'page_views' AND m.value > 100 THEN 'HIGH_TRAFFIC'
        WHEN m.metric_name = 'session_duration' AND m.value > 1800 THEN 'LONG_SESSION'  -- 30 min
        WHEN m.metric_name = 'error_count' AND m.value > 5 THEN 'ERROR_SPIKE'
        ELSE 'NORMAL'
    END AS alert_level
FROM user_metrics m
JOIN users u ON m.user_id = u.id
WHERE m.metric_name IN ('page_views', 'session_duration', 'error_count')
  AND u.profile.city IN ('San Francisco', 'New York')
ORDER BY m.timestamp DESC;

-- Real-time purchase behavior stream
LIVE SELECT 
    u.name AS customer,
    p.name AS product,
    p.category.main,
    pu.purchase_amount,
    pu.timestamp,
    COUNT(*) OVER (
        PARTITION BY u.id 
        ORDER BY pu.timestamp 
        RANGE INTERVAL '1 hour' PRECEDING
    ) AS purchases_last_hour
FROM purchases pu
JOIN users u ON pu.user_id = u.id  
JOIN products p ON pu.product_id = p.id
WHERE pu.purchase_amount > 100  -- High-value purchases only
ORDER BY pu.timestamp DESC;

-- 8. ADVANCED ANALYTICS & MACHINE LEARNING INTEGRATION
-- =====================================================

-- Customer segmentation with behavioral clustering
SELECT 
    customer_segment,
    COUNT(*) AS segment_size,
    AVG(total_spent) AS avg_spending,
    AVG(session_frequency) AS avg_sessions_per_week,
    AVG(social_connections) AS avg_social_score
FROM (
    SELECT 
        u.id,
        u.name,
        CASE 
            WHEN total_spent > 1000 AND session_frequency > 10 THEN 'VIP_ACTIVE'
            WHEN total_spent > 1000 AND session_frequency <= 10 THEN 'VIP_CASUAL' 
            WHEN total_spent <= 1000 AND session_frequency > 10 THEN 'REGULAR_ACTIVE'
            WHEN social_connections > 50 THEN 'SOCIAL_INFLUENCER'
            ELSE 'CASUAL_USER'
        END AS customer_segment,
        total_spent,
        session_frequency,
        social_connections
    FROM (
        SELECT 
            u.id,
            u.name,
            COALESCE(SUM(p.price), 0) AS total_spent,
            COUNT(DISTINCT DATE_TRUNC('week', m.timestamp)) AS session_frequency,
            COUNT(DISTINCT f.to_user_id) AS social_connections
        FROM users u
        LEFT JOIN purchases pu ON u.id = pu.user_id
        LEFT JOIN products p ON pu.product_id = p.id
        LEFT JOIN user_metrics m ON u.id = m.user_id AND m.metric_name = 'session_duration'
        LEFT JOIN follows f ON u.id = f.to_user_id
        WHERE m.timestamp > NOW() - INTERVAL '90 days' OR m.timestamp IS NULL
        GROUP BY u.id, u.name
    ) user_stats
) segmented_users
GROUP BY customer_segment
ORDER BY avg_spending DESC;

-- Predictive churn analysis (simulated ML scoring)
SELECT 
    u.name,
    u.email,
    days_since_last_activity,
    declining_engagement_trend,
    reduced_social_activity,
    (
        CASE WHEN days_since_last_activity > 14 THEN 0.4 ELSE 0.0 END +
        CASE WHEN declining_engagement_trend > 0.3 THEN 0.3 ELSE 0.0 END +
        CASE WHEN reduced_social_activity > 0.2 THEN 0.2 ELSE 0.0 END +
        CASE WHEN recent_purchases = 0 THEN 0.1 ELSE 0.0 END
    ) AS churn_risk_score
FROM (
    SELECT 
        u.id,
        u.name,
        u.email,
        EXTRACT(EPOCH FROM (NOW() - MAX(m.timestamp))) / 86400 AS days_since_last_activity,
        -- Simplified trend calculation (would use proper time series analysis)
        CASE 
            WHEN AVG(CASE WHEN m.timestamp > NOW() - INTERVAL '7 days' THEN m.value END) < 
                 AVG(CASE WHEN m.timestamp BETWEEN NOW() - INTERVAL '14 days' AND NOW() - INTERVAL '7 days' THEN m.value END) 
            THEN 0.5 ELSE 0.0 
        END AS declining_engagement_trend,
        CASE 
            WHEN COUNT(CASE WHEN f.created_at > NOW() - INTERVAL '30 days' THEN 1 END) = 0 
            THEN 0.3 ELSE 0.0 
        END AS reduced_social_activity,
        COUNT(CASE WHEN pu.created_at > NOW() - INTERVAL '30 days' THEN 1 END) AS recent_purchases
    FROM users u
    LEFT JOIN user_metrics m ON u.id = m.user_id AND m.metric_name = 'session_duration'
    LEFT JOIN follows f ON u.id = f.from_user_id
    LEFT JOIN purchases pu ON u.id = pu.user_id
    WHERE u.created_at < NOW() - INTERVAL '90 days'  -- Exclude new users
    GROUP BY u.id, u.name, u.email
) churn_analysis
WHERE churn_risk_score > 0.2  -- Only show at-risk users
ORDER BY churn_risk_score DESC;

-- =====================================================================
-- End of OrbitQL Multi-Model Query Examples
-- =====================================================================
-- These queries demonstrate OrbitQL's power to unify:
--   • Document data (users, products, rich JSON structures)
--   • Graph relationships (social networks, product connections)  
--   • Time series analytics (behavioral metrics, real-time data)
--   • Advanced analytics (segmentation, ML integration, streaming)
-- 
-- In a production system, these would execute against:
--   • Document stores (MongoDB, PostgreSQL JSONB)
--   • Graph databases (Neo4j, ArangoDB) 
--   • Time series databases (InfluxDB, TimescaleDB)
--   • All unified through OrbitQL's multi-model query engine
-- =====================================================================