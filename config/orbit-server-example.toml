# =============================================================================
# Orbit Server Configuration Example
# =============================================================================
# This file contains all available configuration options for the Orbit server.
# Copy this file to orbit-server.toml and customize as needed.
#
# Environment variables can be used with ${ENV_VAR} syntax
# =============================================================================

# -----------------------------------------------------------------------------
# Server Identification and Basic Settings
# -----------------------------------------------------------------------------
[server]
# Unique server/node identifier (auto-generated if not set)
# node_id = "orbit-node-1"

# Default bind address for all servers
bind_address = "0.0.0.0"

# Environment: Development, Testing, Staging, Production
environment = "Development"

# Data directory for persistence
data_dir = "./data"

# Configuration directory
config_dir = "./config"

# -----------------------------------------------------------------------------
# Actor System Configuration
# -----------------------------------------------------------------------------
[actor_system]
# Maximum number of actors per node
max_actors = 10000

# Actor mailbox size
mailbox_size = 1000

# Actor supervision strategy: OneForOne, OneForAll, RestForOne
supervision_strategy = "OneForOne"

# Cluster configuration (optional)
# [actor_system.cluster]
# seed_nodes = ["192.168.1.10:7946", "192.168.1.11:7946"]
# gossip_port = 7946
# heartbeat_interval_ms = 1000
# failure_timeout_ms = 5000

# -----------------------------------------------------------------------------
# Protocol Server Configurations
# -----------------------------------------------------------------------------

# gRPC Server (Orbit Actor API)
[protocols.grpc]
enabled = true
port = 50051
max_concurrent_streams = 1000
max_message_size = 4194304  # 4MB

# gRPC Keep-Alive (optional)
# [protocols.grpc.keep_alive]
# interval_secs = 30
# timeout_secs = 20

# gRPC TLS (optional)
# [protocols.grpc.tls]
# enabled = true
# cert_file = "/path/to/cert.pem"
# key_file = "/path/to/key.pem"
# ca_cert_file = "/path/to/ca.pem"
# require_client_cert = false

# PostgreSQL Wire Protocol Server
[protocols.postgresql]
enabled = true
port = 5432
max_connections = 1000
connection_timeout_secs = 30

[protocols.postgresql.sql_engine]
max_query_complexity = 1000
query_timeout_secs = 30
enable_optimization = true
enable_caching = true
cache_size_mb = 256

[protocols.postgresql.vector_ops]
default_metric = "cosine"
max_dimensions = 4096
batch_size = 1000
enable_simd = true

[protocols.postgresql.vector_ops.indexing]
default_algorithm = "hnsw"

[protocols.postgresql.vector_ops.indexing.hnsw]
m = 16
ef_construction = 200
ef_search = 50

[protocols.postgresql.vector_ops.indexing.ivf]
nlist = 100
nprobe = 10

[protocols.postgresql.features]
enable_pgvector = true
enable_postgis = false
enable_json = true
enable_fulltext = true
enable_prepared_statements = true
enable_transactions = true

# Redis RESP Protocol Server
[protocols.redis]
enabled = true
port = 6379
max_connections = 1000
connection_timeout_secs = 30

[protocols.redis.commands]
enabled_groups = [
    "generic",
    "string",
    "list",
    "hash",
    "set",
    "zset",
    "vector",
    "search",
    "json",
    "graph",
    "stream",
    "pubsub"
]
disabled_commands = []
command_timeout_secs = 30
max_pipeline_size = 1000

[protocols.redis.vector_ops]
default_metric = "cosine"
max_dimensions = 4096
batch_size = 1000
enable_simd = true

[protocols.redis.vector_ops.indexing]
default_algorithm = "hnsw"

[protocols.redis.vector_ops.indexing.hnsw]
m = 16
ef_construction = 200
ef_search = 50

[protocols.redis.vector_ops.indexing.ivf]
nlist = 100
nprobe = 10

[protocols.redis.features]
enable_streams = true
enable_pubsub = true
enable_modules = false
enable_redisearch = true
enable_redisjson = true
enable_redisgraph = true
enable_cluster = false

# HTTP REST API Server
[protocols.rest]
enabled = true
port = 8080
max_connections = 1000
request_timeout_secs = 30

# REST CORS (optional)
# [protocols.rest.cors]
# allowed_origins = ["*"]
# allowed_methods = ["GET", "POST", "PUT", "DELETE"]
# allowed_headers = ["Content-Type", "Authorization"]
# max_age_secs = 3600

# REST Rate Limiting (optional)
# [protocols.rest.rate_limit]
# requests_per_minute = 1000
# burst_capacity = 100

# MySQL Wire Protocol Server
[protocols.mysql]
enabled = true
port = 3306
max_connections = 1000
connection_timeout_secs = 30
server_version = "8.0.0-Orbit"
authentication_enabled = false

# CQL (Cassandra Query Language) Server
[protocols.cql]
enabled = true
port = 9042
max_connections = 1000
connection_timeout_secs = 30
protocol_version = 4
authentication_enabled = false

# AQL (ArangoDB Query Language) Server
[protocols.aql]
enabled = true
port = 8529
max_connections = 1000
connection_timeout_secs = 30
authentication_enabled = false

# OrbitQL Query Language Server
[protocols.orbitql]
enabled = true
port = 8081
max_connections = 1000
connection_timeout_secs = 30
authentication_enabled = false

# Cypher (Neo4j-compatible) Server (optional)
# [protocols.cypher]
# enabled = true
# port = 7687
# max_connections = 1000
# [protocols.cypher.graph_engine]
# max_query_complexity = 1000
# query_timeout_secs = 30
# enable_optimization = true
# storage_backend = "memory"

# MCP (Model Context Protocol) Server (optional)
# [protocols.mcp]
# enabled = true
# port = 3000
# version = "1.0"
# [protocols.mcp.tools]
# available_tools = ["query", "vector_search", "graph_traverse"]
# [protocols.mcp.tools.tool_configs]

# -----------------------------------------------------------------------------
# Security Configuration
# -----------------------------------------------------------------------------
[security.authentication]
enabled = false
methods = ["Basic"]

# JWT Configuration (optional)
# [security.authentication.jwt]
# secret_key = "your-secret-key-here"
# expiration_secs = 3600
# algorithm = "HS256"

# Session Configuration (optional)
# [security.authentication.session]
# timeout_secs = 3600
# storage = "memory"

[security.authorization]
enabled = false
model = "rbac"
default_permissions = ["read", "write"]

# Encryption at Rest (optional)
# [security.encryption.at_rest]
# enabled = true
# algorithm = "AES-256-GCM"
# [security.encryption.at_rest.kms]
# provider = "vault"
# endpoint = "http://localhost:8200"
# key_id = "orbit-master-key"

# Encryption in Transit (optional)
# [security.encryption.in_transit]
# enabled = true
# tls_version = "TLS1.3"
# cipher_suites = ["TLS_AES_256_GCM_SHA384", "TLS_CHACHA20_POLY1305_SHA256"]

# -----------------------------------------------------------------------------
# Performance Configuration
# -----------------------------------------------------------------------------
[performance.memory]
max_memory_mb = 4096

[performance.memory.pool_config]
initial_size_mb = 256
max_size_mb = 2048
growth_factor = 1.5

[performance.memory.gc_settings]
auto_gc = true
interval_secs = 300
memory_threshold_pct = 80.0

[performance.io]
max_concurrent_ops = 1000
timeout_secs = 30
buffer_size_kb = 64
enable_direct_io = false

[performance.network]
tcp_nodelay = true
keep_alive = true
# recv_buffer_size = 65536
# send_buffer_size = 65536

[performance.cpu]
# worker_threads = 4  # Defaults to number of CPU cores
enable_affinity = false
enable_simd = true

# -----------------------------------------------------------------------------
# Logging Configuration
# -----------------------------------------------------------------------------
[logging]
level = "info"
format = "plain"  # Options: plain, json

[[logging.outputs]]
output_type = "stdout"

# File logging with rotation (optional)
# [[logging.outputs]]
# output_type = "file"
# file_path = "/var/log/orbit/orbit-server.log"
# [logging.outputs.rotation]
# strategy = "size"
# max_size_mb = 100
# max_files = 10

# Component-specific log levels
# [logging.component_levels]
# orbit_server = "debug"
# orbit_protocols = "info"
# hyper = "warn"

# -----------------------------------------------------------------------------
# Monitoring Configuration
# -----------------------------------------------------------------------------
[monitoring.metrics]
enabled = true
port = 9090
format = "prometheus"
collection_interval_secs = 30
retention_days = 7

[monitoring.health_checks]
enabled = true
port = 8082
interval_secs = 30
timeout_secs = 5

[monitoring.tracing]
enabled = false
backend = "jaeger"  # Options: jaeger, zipkin, otlp
sampling_rate = 0.1
# endpoint = "http://localhost:14268/api/traces"

# -----------------------------------------------------------------------------
# Connection Pooling Configuration
# -----------------------------------------------------------------------------
[pooling]
enabled = true
min_connections = 5
max_connections = 100
connection_timeout_secs = 30
idle_timeout_secs = 300
max_lifetime_secs = 3600
health_check_interval_secs = 30
load_balancing_strategy = "LeastConnections"  # Options: RoundRobin, LeastConnections, Random, Weighted
tier = "Application"  # Options: Application, System, Critical
enable_dynamic_sizing = true
target_utilization = 0.75

[pooling.circuit_breaker]
enabled = true
failure_threshold = 5
failure_window_secs = 60
recovery_timeout_secs = 30
success_threshold = 3
half_open_max_calls = 3

# Per-protocol pool overrides (optional)
# [pooling.protocol_overrides.postgresql]
# min_connections = 10
# max_connections = 200
# load_balancing_strategy = "LeastConnections"
# [[pooling.protocol_overrides.postgresql.nodes]]
# node_id = "pg-node-1"
# address = "192.168.1.10:5432"
# max_connections = 100
# weight = 10

# -----------------------------------------------------------------------------
# Persistence Provider Configuration
# -----------------------------------------------------------------------------
# Default providers for addressable directories and cluster state
[persistence.defaults]
addressable = "memory"
cluster = "memory"

# Dynamic provider configuration with health monitoring and failover
[persistence.dynamic]
enable_performance_monitoring = true
performance_window = 300
enable_auto_scaling = false

[persistence.dynamic.health_monitor]
check_interval = 30
check_timeout = 5
failure_threshold = 3
success_threshold = 2
enable_circuit_breaker = true
circuit_breaker_timeout = 300

[persistence.dynamic.failover]
enable_auto_failover = true
strategy = "Priority"  # Options: RoundRobin, Priority, LowestLatency, LoadBased
max_attempts = 3
retry_delay = 10
enable_failback = true
failback_delay = 300

# Memory provider (default, no external dependencies)
[persistence.providers.memory]
type = "Memory"
max_entries = 100000

# Memory provider with disk backup
# [persistence.providers.memory.disk_backup]
# path = "/var/lib/orbit/backup.json"
# sync_interval = 300
# compression = "Gzip"  # Options: None, Gzip, Lz4, Zstd

# RocksDB embedded database (high-performance local storage)
# [persistence.providers.rocksdb]
# type = "RocksDB"
# path = "/var/lib/orbit/rocksdb"
# create_if_missing = true
# max_open_files = 1000
# write_buffer_size = 67108864  # 64MB
# max_write_buffer_number = 3
# target_file_size_base = 67108864  # 64MB
# compression = "Lz4"
# enable_statistics = true

# S3-compatible storage (MinIO, AWS S3, etc.)
# [persistence.providers.s3]
# type = "S3"
# endpoint = "http://localhost:9000"
# region = "us-east-1"
# bucket = "orbit-data"
# access_key_id = "minioadmin"
# secret_access_key = "minioadmin"
# prefix = "orbit"
# enable_ssl = false
# connection_timeout = 30
# read_timeout = 60
# write_timeout = 60
# retry_count = 3

# AWS S3 with advanced features
# [persistence.providers.aws_s3]
# type = "AWSS3"
# region = "us-east-1"
# bucket = "orbit-production"
# access_key_id = "${AWS_ACCESS_KEY_ID}"
# secret_access_key = "${AWS_SECRET_ACCESS_KEY}"
# prefix = "orbit"
# enable_ssl = true
# storage_class = "StandardIA"  # Options: Standard, StandardIA, OneZoneIA, Glacier, DeepArchive, IntelligentTiering
# enable_transfer_acceleration = false
# retry_count = 3

# Azure Blob Storage
# [persistence.providers.azure]
# type = "Azure"
# account_name = "orbitdata"
# account_key = "${AZURE_STORAGE_KEY}"
# container_name = "orbit"
# prefix = "orbit"
# connection_timeout = 30
# retry_count = 3

# Google Cloud Storage
# [persistence.providers.gcp]
# type = "GoogleCloud"
# project_id = "your-project-id"
# bucket_name = "orbit-data"
# credentials_path = "/path/to/service-account.json"
# prefix = "orbit"
# connection_timeout = 30
# retry_count = 3

# Digital Ocean Spaces
# [persistence.providers.do_spaces]
# type = "DigitalOceanSpaces"
# endpoint = "nyc3.digitaloceanspaces.com"
# region = "nyc3"
# space_name = "orbit-data"
# access_key_id = "${DO_SPACES_KEY}"
# secret_access_key = "${DO_SPACES_SECRET}"
# prefix = "orbit"
# enable_ssl = true
# enable_cdn = false
# enable_encryption = true
# retry_count = 3

# MinIO (S3-compatible object storage)
# [persistence.providers.minio]
# type = "MinIO"
# endpoint = "http://localhost:9000"
# access_key = "minioadmin"
# secret_key = "minioadmin"
# bucket_name = "orbit"
# region = "us-east-1"
# secure = false
# prefix = "orbit"

# etcd distributed key-value store
# [persistence.providers.etcd]
# type = "Etcd"
# endpoints = ["http://localhost:2379"]
# prefix = "/orbit"
# lease_ttl = 300
# connection_timeout = 30
# username = "orbit"
# password = "${ETCD_PASSWORD}"

# Redis persistence provider
# [persistence.providers.redis]
# type = "Redis"
# url = "redis://localhost:6379"
# cluster_mode = false
# database = 0
# password = "${REDIS_PASSWORD}"
# prefix = "orbit:"
# pool_size = 10
# connection_timeout = 30
# retry_count = 3

# TiKV distributed transactional key-value store
# [persistence.providers.tikv]
# type = "TiKV"
# pd_endpoints = ["127.0.0.1:2379"]
# key_prefix = "orbit"
# connection_timeout = 30
# max_batch_size = 1000

# Kubernetes ConfigMap/Secret storage
# [persistence.providers.kubernetes]
# type = "Kubernetes"
# namespace = "orbit"
# config_map_name = "orbit-state"
# secret_name = "orbit-secrets"
# in_cluster = true

# Composite provider with failover
# [persistence.providers.composite]
# type = "Composite"
# sync_interval = 60
# health_check_interval = 30
# failover_threshold = 3
#
# [persistence.providers.composite.primary]
# type = "Memory"
# max_entries = 50000
#
# [persistence.providers.composite.backup]
# type = "S3"
# endpoint = "http://localhost:9000"
# region = "us-east-1"
# bucket = "orbit-backup"
# access_key_id = "minioadmin"
# secret_access_key = "minioadmin"
# enable_ssl = false

# -----------------------------------------------------------------------------
# Deployment Configuration (for clustered/distributed deployments)
# -----------------------------------------------------------------------------
[deployment]
# Deployment mode: standalone, docker, kubernetes
mode = "standalone"

# Cluster name for identification
cluster_name = "orbit-cluster"

# Node Discovery Configuration
[deployment.discovery]
# Discovery method: static, dns, consul, etcd, kubernetes_api
method = "static"

# Static node configuration
[[deployment.discovery.static_nodes]]
id = "node-1"
address = "127.0.0.1:50051"

# [[deployment.discovery.static_nodes]]
# id = "node-2"
# address = "192.168.1.11:50051"

# [[deployment.discovery.static_nodes]]
# id = "node-3"
# address = "192.168.1.12:50051"

# DNS-based discovery (for Docker/Kubernetes)
# [deployment.discovery.dns]
# service_name = "orbit-server"
# port = 50051
# query_interval = "30s"

# Consul-based discovery
# [deployment.discovery.consul]
# address = "consul.service.consul:8500"
# service_name = "orbit-server"
# health_check = true
# query_interval = "30s"

# etcd-based discovery
# [deployment.discovery.etcd]
# endpoints = ["etcd-1.orbit.local:2379", "etcd-2.orbit.local:2379"]
# key_prefix = "/orbit-rs/nodes"
# query_interval = "30s"

# Leader Election Configuration
[deployment.election]
# Election method: raft, k8s_lease
method = "raft"

# Enable Kubernetes fallback if available
enable_k8s_fallback = false

# Raft consensus configuration
[deployment.election.raft]
election_timeout_min = "150ms"
election_timeout_max = "300ms"
heartbeat_interval = "50ms"
max_entries_per_request = 100
log_compaction_threshold = 1000

# Quorum configuration
[deployment.election.quorum]
min_quorum_size = 1
max_failures = 0
quorum_timeout = "10s"
dynamic_quorum = false

# Storage paths for cluster state
[deployment.storage]
data_dir = "./data"
election_state_file = "election-state.json"
transaction_log_file = "transactions.db"
backup_enabled = false
backup_interval = "1h"

# -----------------------------------------------------------------------------
# Environment-specific Overrides
# -----------------------------------------------------------------------------
# Development environment
# [environments.development]
# [environments.development.logging]
# level = "debug"
# format = "plain"
#
# [environments.development.deployment.election.raft]
# election_timeout_min = "50ms"
# election_timeout_max = "100ms"
# heartbeat_interval = "25ms"

# Production environment
# [environments.production]
# [environments.production.server]
# environment = "Production"
#
# [environments.production.security]
# [environments.production.security.authentication]
# enabled = true
#
# [environments.production.security.encryption.in_transit]
# enabled = true
# tls_version = "TLS1.3"
#
# [environments.production.logging]
# level = "warn"
# format = "json"
#
# [environments.production.performance]
# [environments.production.performance.cpu]
# worker_threads = 8

# Docker environment
# [environments.docker]
# [environments.docker.deployment.discovery]
# method = "dns"
#
# [environments.docker.logging]
# format = "json"

# Kubernetes environment
# [environments.kubernetes]
# [environments.kubernetes.deployment.discovery]
# method = "kubernetes_api"
#
# [environments.kubernetes.deployment.election]
# method = "k8s_lease"
