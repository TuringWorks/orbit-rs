//! Actor proxy generation and utilities

use crate::*;
use orbit_shared::*;
use std::sync::Arc;

/// Macro for generating actor proxy methods
/// This provides a compile-time alternative to Java's dynamic proxies
#[macro_export]
macro_rules! actor_proxy {
    (
        $trait_name:ident {
            $(
                async fn $method:ident($($arg:ident: $arg_type:ty),*) -> $return_type:ty;
            )*
        }
    ) => {
        paste::paste! {
            impl<T: ?Sized> [<$trait_name Proxy>]<T> for ActorReference<T> {
                $(
                    async fn $method(&self, $($arg: $arg_type),*) -> OrbitResult<$return_type> {
                        let args = vec![
                            $(serde_json::to_value($arg).map_err(OrbitError::SerializationError)?),*
                        ];
                        self.invoke(stringify!($method), args).await
                    }
                )*
            }
        }
    };
}

/// Trait for creating actor proxies
pub trait ActorProxy<T: ?Sized> {
    fn create_proxy(
        reference: AddressableReference,
        invocation_system: Arc<InvocationSystem>,
    ) -> ActorReference<T> {
        ActorReference::new(reference, invocation_system)
    }
}

/// Default implementation for any addressable type
impl<T: Addressable + ?Sized> ActorProxy<T> for ActorReference<T> {}

/// Helper trait for creating typed actor references
pub trait ActorReferenceExt<T: ?Sized> {
    fn typed(self) -> ActorReference<T>;
}

impl<T: Addressable + ?Sized> ActorReferenceExt<T> for ActorReference<dyn Addressable> {
    fn typed(self) -> ActorReference<T> {
        ActorReference::new(self.reference().clone(), self.invocation_system.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use async_trait::async_trait;

    // Example actor trait for testing
    #[async_trait]
    trait TestActor: Addressable {
        #[allow(dead_code)]
        async fn greet(&self, name: String) -> OrbitResult<String>;
        #[allow(dead_code)]
        async fn count(&self) -> OrbitResult<i32>;
    }

    // This would be generated by the macro in practice
    trait TestActorProxy<T: ?Sized> {
        async fn greet(&self, name: String) -> OrbitResult<String>;
        #[allow(dead_code)]
        async fn count(&self) -> OrbitResult<i32>;
    }

    // Manual implementation for testing (would be generated by macro)
    impl<T: ?Sized> TestActorProxy<T> for ActorReference<T> {
        async fn greet(&self, name: String) -> OrbitResult<String> {
            let args = vec![serde_json::to_value(name).map_err(OrbitError::SerializationError)?];
            self.invoke("greet", args).await
        }

        async fn count(&self) -> OrbitResult<i32> {
            let args = vec![];
            self.invoke("count", args).await
        }
    }

    #[tokio::test]
    async fn test_actor_proxy() {
        let reference = AddressableReference {
            addressable_type: "TestActor".to_string(),
            key: Key::StringKey {
                key: "test".to_string(),
            },
        };

        let system = Arc::new(InvocationSystem::new());
        let actor_ref: ActorReference<dyn TestActor> = ActorReference::new(reference, system);

        // Test method invocation through proxy
        let result = actor_ref.greet("World".to_string()).await.unwrap();
        assert_eq!(result, "Hello from actor!");
    }
}
